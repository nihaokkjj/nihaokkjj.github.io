[{"title":"前端学习","url":"/posts/2025/07/Fronted/前端学习/4723d6e9.html","content":"# 前端学习\n\n## 学习路线\n\n跟着发的视频学就可以了，一定要记笔记 (东西很多会忘)\n\n> 我是整体跟着这套视频学下来的，但是学完之后的感觉就是内容很杂很多，学的过程中也不知道哪些是重点，所以有必要在这里列一下哪些是着重需要关注的知识。\n\n总之所有视频都要看一遍，按照自己的节奏来，不需要赶进度，重点一定要自己都理解了。\n\n### 三件套\n\n***HTML部分***\n\n可以适当倍速看，很多标签其实不用学，重点学会 **HTML基础结构** + 标签**div**、**h**、**a**、**img**、**iframe**、**table**(后面两个其实已经过时了，但面试会问) + **浏览器原理**(面试) + **URL**(面试)\n\n***CSS部分***\n\n👇目前常用的，也就是必须掌握的：\n\n文本字体属性\n\n伪元素+伪类\n\n**选择器**理解+笔记记好就ok、后期的话要会用深度选择器\n\n**flex布局**、绝对定位、相对定位、浮动、粘性定位(面试)\n\n居中 (要学会所有居中方式)\n\n**盒子模型**\n\n在CSS基础学完后，跟着做一个完整的页面(我们当时做的是视频里的网易云)，跟着视频做一遍CSS基本上都会用了。（后面仿王者荣耀的我们没做，如果你觉得对CSS力不从心的话可以继续做，基本做一个就🆗了）\n\n> 这部分笔记一定要记好，以后可能会经常翻出来看\n>\n> 不会的要经常查MDN文档 [CSS：层叠样式表 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS)\n\n如果可以学学Less和Sass，是CSS的扩展，很好用可以简化CSS语法编写\n\n移动端适配（就是rem-vw-vh-@media这些） (这一块我当时没当重点学也没咋学好，听说GitHub上是有写好的适配)（可以自己抉择放后面学也行）\n\n***JS部分***\n\n去翻看了一下课\n\n这一块视频有*（掌握）*标签的都得认真学\n\n不会的或者哪里很难懂的可以去b站找相应视频看，一般b站的视频都讲的很通俗易懂\n\nJS学习有一定难度，按自己节奏来不能赶\n\n### 框架\n\n> 这一块到学完三件套再说，学完记得告知学姐学长一下。\n\n## 能力要求\n\n***看文档的能力***\n\n前端当前所有的无论技术，框架，语法都有相应的文档，前期在学习三件套期间我们就要接触MDN文档，很多API或是属性词条都应以官方文档为主\n\n在有一定基础后，后续学习大部分时间是和文档&AI打交道\n\n***GitHub***\n\n前期拥有有一个自己的GitHub账号，可以学一些简单的操作，把自己的笔记，简单的程序demo什么的都可以放到Github上。\n\n***自学能力***\n\n前端具有一定的广度和深度，不同方向的入门难度、体系成熟度(生态建设)都有很大的差异，当然我们前期三件套是每个前端都得掌握的，而在后的扩展，比如说：新奇的技术栈(太多了根本学不完😭)、优化方案手段、好用的插件、博客建设等等，很多东西是需要自发探索的。\n\n## 工具资料\n\n推荐播放器👇（支持绑定阿里云盘，可以开几十倍速）\n\n[蜗牛云盘 - 全面的阿里云盘、115网盘第三方客户端](https://snail8.cn/html/index.html)\n\n要是嫌Typora字量大会卡的话可以试试👇\n\n[Obsidian - Sharpen your thinking](https://obsidian.md/)\n\n👆这个可以自定义样式，还有很多第三方插件\n\n### 各类视频资源\n\n[青知木杂货铺-程序员资源网](https://www.qzmzhp.cn/)\n\n账号：15729962898@163.com\n\n密码：chen6411\n\n> ```ABAP\n> 使用完后务必退出，同一账号只支持一台设备登录\n> ```\n\n## VSCode插件\n\n### 实用\n\n**Chinese (Simplified) (简体中文)**\n\n**Chinese Lorem**\n\n> 汉化\n\n**Auto Rename Tag**\n\n> 自动成对HTML标签\n\n**Live Server**\n\n> 在HTML文件中，右键Open Live Server可直接打开页面，可以实时更新\n\n**Image preview**\n\n> 鼠标悬停img链接可预览显示图片\n\n**Path Intellisense**\n\n> 代码自动补全\n\n**Prettier - Code formatter**\n\n> 格式化程序，为代码执行一致的样式\n\n**Error Lens**\n\n> 报错提示\n\n**project-tree**\n\n> `ctre + shift + p` 输入 `Project Tree` 生成项目结构树到README文件（写文章博客可能会用到）\n\n### 美化\n\n**VSCode Great Icons**\n\n> 改变你左侧栏的文件图标\n\n**background-cover**\n\n> 可以改你编辑器的背景图\n\n**Gradient Theme**\n\n> 我当前在用的主题，非常好看\n\n**SynthWave '84**\n\n> 特别闪的主题样式 (当时豪哥给我配的)\n\n\n\n更多的插件自己探索喽😼","tags":["前端学习路线"],"categories":["前端开发"]},{"title":"学习网站","url":"/posts/2025/07/Fronted/学习网站/52e318f2.html","content":"\n一些有用的网站值得被记录, 但是总是因为一些原因而搁置, 遗忘\n搜藏夹里面有一大堆网站, 但我从来不会打开看看\n\n\n这里放个标, 希望以后还能找到, 而不是吃灰\n\n# 前端学习\n## 学习网站\n### 1, 学长推荐的网站\nYoutube\nhttps://app.daily.dev/\nyoutube的大火博主\n- Net Ninja \n- Traversy Media\n- Ryan Carniato\n- Web Dev Simplified\n- Fireship\n\n### 2 博客园里面看到的一个前端路线笔记\nhttps://www.cnblogs.com/qianguyihao/p/16370961.html\n\n### 3 浏览器工作和实践原理\nhttps://zhqwq.github.io/broswer-working-principle/guide/intro.html\n\n### 4 前端交流网站 stack overflow\nhttps://stackoverflow.com/questions\n\n## 组件库\nhttps://uiverse.io/elements\n\n\n# 小工具\n## 提高图片分辨率\nhttps://upscayl.org/\n","tags":["前端"],"categories":["进修"]},{"title":"butterfly安装之旅","url":"/posts/2025/07/blog/butterfly安装/e70f18fc.html","content":"创建一个文件夹\n\n在文件夹打开git\n```\ngit clone -b main https://github.com/jerryc127/hexo -theme-butterfly .git themes/butterfly\n```\n\n应用主题\n修改Hexo 根目录下的_config.yml，把主题改为butterfly\n```\ntheme:  butterfly\n```\n\n安装插件\n下载安装渲染器：\n```\nnpm install hexo -renderer-pug hexo -renderer-stylus  --save\n```\n\n重中之重\n\n在hexo 的根目录创建一个文件_config.butterfly.yml，并把主题目录的_config.yml 内容复制_config.butterfly.yml到 去。\n\n>注意:\n\n复制的是主题的_config.yml，而不是hexo 的_config.yml\n\n不要把主题目录的_config.yml删掉\n\n以后只需要在_config.butterfly.yml进行配置就行。如果使用了_config.butterfly.yml， 配置主题的_config.yml将不会有效果。\n\n\nHexo 会自动合并主题中的_config.yml和_config.butterfly.yml里的配置，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。\n\n","tags":["blog"],"categories":["blog"]},{"title":"魔改之旅","url":"/posts/2025/07/blog/魔改之旅/afacad78.html","content":"```\n文档指路\nhttps://butterfly.zhheo.com/create.html\n\n我的主题色 : rgb(191, 219, 221)\n\n加载动画 (安知鱼)\nhttps://blog.anheyu.com/posts/52d8.html\n\n导航栏修改(安知鱼)\nhttps://blog.anheyu.com/posts/8e53.html\n试了一下, 每次改完网站就挂了(细节处理太麻烦了), 以后再试试其他主题\n```\n\n上面这些适合想要完全按照自己喜好搭建博客的仔仔啊\n\n但是框框太懒了, 搭一半就放弃了 , 直接去用别人现成的主题去了\n\n找到了一个现成的主题(安知鱼)\nhttps://docs.anheyu.com/intro.html\n\n基本clone下来就可以了, 不需要过多的配置, up主已经帮我们配好了\n\n同时推荐一下这个up主发的部署视频(默认你已经有github了啊)\n<a href=\"【07.通过github page部署至互联网】https://www.bilibili.com/video/BV1zT411A7XL?vd_source=26eb5025743189cb77f15d6e356b6da3\">07.通过github page部署至互联网</a>\n\n记得将autodeploy.yml中的node版本改成自己电脑上的版本哦, ```node-version: \"22.x\"```\n\n自动部署, 完成之后只需要把更新的内容上传就可以了, 不用再自己部署了\n<a href=\"【13.hexo完成github action自动部署】https://www.bilibili.com/video/BV19P41157no?vd_source=26eb5025743189cb77f15d6e356b6da3\">hexo完成github action自动部署</a>\n\n## 问题\n中间主包遇到了一个小问题: 没有给每个文章设置自己的访问链接, 这里分享一下\n\n首先安装一个插件\n```\n npm install hexo-abbrlink --save\n```\n\n在 _config.yml(不是主题的)添加\n\n```\n# abbrlink config\nabbrlink:\n  alg: crc32  # 算法：crc16(default) and crc32\n  rep: hex    # 进制：dec(default) and hex\n  draft: false ## 草稿是否永久链接\n  field: post ## only support 'post'\n  # enable: true # 是否开启，可不写，默认开启\n```\n把这个设置好(可以按照自己的喜好设置哦)\n```\npermalink: posts/:year/:month/:title/:abbrlink.html\n```\n\n大功告成😘\n\n# 感悟\n这些都是框框的血泪史, 中间遇到了无数的bug, 光是blog就重装了四五次了, 希望这篇帖子能帮助到你🤣","tags":["blog"],"categories":["blog"]},{"title":"日记","url":"/posts/2025/07/大学生活/随笔/3458e8f8.html","content":"\n路漫漫其修远兮, 路还长, 一切才刚刚开始\n\n总体来讲, 我的大学生活算是幸运的了\n\n## 冥冥之中, 自有定义\n\n### 初识Lec\n\n2024-07\n说来也巧, 加入学校官方新生群后, 并没有很多卖卡卖被子(就一两个) 的\"热心\" 学长学姐加我, 所以我眼中的西柚学长学姐们都是十分善良的\n\n也正是因为这一点, 在看到计算机团队在招新宣传的时候, 我才没有把团队归为社团, 部门这类相对没有意义的组织\n(就像一位学长说的: \"能加入lec, 本身就是莫大的缘分. 有人不相信所谓的团队招新, 认为是推销骗子; 有人哪怕加入了招新群, 但在暑假没有准备开学的考试. 我们能顺利加入团队, 本身就是lec最好的选择与安排\")\n\n2024-08\n感谢当时充满好奇心的我啊, 挑选了一个当时在群里发言比较积极, 看着十分乐于助人的学长(后来知道, cxh学长是lec团队非常优秀的一个人, 不仅技术好, 人也很好相处, 经常在群里发一些有用的资料 (框框经常看这个学长的blog, 争取像他一样, 进大厂!)). 后来么, 就被拉入了lec招新群. \n\n转折点开始!\n\n就此框框也是知道团队的存在了, 不止lec, 当时我基本把所有的计算机团队都加了一遍(呵呵). 但是除了lec, 其他的群都不大活跃, 也有加进来的第一个群是lec的原因, 我后来主要活跃在lec招新群, (里面有个qq机器人,经常戳他签到啥的, 哈哈哈哈. 后面统计的时候, 框框积分名列前茅, 还有一杯奶茶奖励, 哈哈哈哈哈)\n\n后面认识了jjl学姐, 她真的非常热情啊, 情绪价值给满, 聊天欲望直线上升. 从她口中, 我逐渐了解到什么是团队, 加入团队的心也越来越强烈\n\n再就是和杨队的相遇了, 刚开始还不太敢加她的, 哈哈哈哈. 幸好当时迈出那一步了, 正式成为她门下的第一名弟子, 开启C语言学习之路\n\n整个八月的时间, 除了完, 再就是学C语言. 我当时也不知到我学的咋样, 因为框框在此之前没咋接触过电脑, 对电脑的一些设置都不太了解(最熟悉的就是浏览器搜索东西, 呵呵), 就直接按照团队招新的范围要求, 从0开始学到了字符串(但是当时题刷的太少了, 基础根本没打劳). 感谢杨队的督促, 感谢ggl学姐, 不然当时的我肯定玩嗨了\n\n## 招新考试\n\n2024-09\n\n开学了, jjl学姐亲自把我带到团队里面去了, 以后这里就是我学习的地方啦(哈哈).\n\n2024-10\n\n要考试了, 我好紧张. 把十楼所有的团队考试都报了一遍, 但是考的时候我根本不知道我考的咋样啊, 看不到排名. 但是两个学姐说我考的还可以\n\n考lec了, 考完的时候我感觉我完蛋了, 糟了, 怎么才考五十几分啊 (当时部分团队的分支设置的比较高, 框框考的时候能考到一两百分, 所以这时候根本没概念自己考的咋样).\n当时跟杨队说我可能进不了了, 杨队让我相信自己, 哈哈哈\n\n## 进入团队\n\n我进团队了, 招新考试排名还不错, 但是lec有点邪门啊, 怎么我这届只有我一个女生进来, 其他女生呢? 跑哪去了(框框内心emmo)\n\n进团队后就是学习之旅啦, \n\n欲知后事如何, 且看其他笔记\n\n\n","tags":["没有营养的话"],"categories":["生活"]},{"title":"使用电脑clash verge给手机共享代理","url":"/posts/2025/07/生活小技巧/手机代理/6c1cb663.html","content":"\n框框灵机一动, 想在手机上面也能访问github, 这里做个记录, 免得之后忘记怎么设置了\n\n# 前提\n我现在的手机型号是 oppo Pro12, 安卓, 电脑用的是clash verge, 节点购买的 <a href=\"https://xn--cp3a08l.com/\">赔钱机场</a>\n\n# 网上的资料\n使用电脑clash verge给手机共享代理\n【电脑上的准备】\n\n1.首先打开clash verge的设置界面，打开“局域网连接”，若弹出防火墙提示，请选择允许访问\n\n\n2.使用win+r快捷键，在弹出页面输入“cmd”并点击确定或回车\n\n\n3.在新弹出的页面中输入”ipconfig/all“并回车\n\n\n4.在显示的列表中找到“ IPv4 地址 . . . . . . . . . . . . :”一栏\n\n\n【手机上的设置】\n\n1.进入网络设置中的wifi设置，通常在你连接的wifi右侧会有感叹号图标，或者长按可以修改网络具体设置，若没有，请自行在网上查询您所使用的设备如何设置手动代理\n\n\n2.在网络的具体设置中找到代理设置，通常默认为关闭，请将其设置为手动\n\n\n3.在服务器一栏内填写上方电脑中获取到的ipv4地址（通常格式为192.168.*.*或10.236.*.*）\n\n\n4.在端口一栏填写clash verge设置页面“端口设置”后方的数字，默认为“7890”您也可以自行更改\n\n\n5.填写完之后点击保存即可，若提示已连接网络但无法访问互联网，请不要在意，直接打开浏览器尝试访问外网即可，此时不出意外的话应该已经能够正常连接\n\n# 实际\n\n## 电脑\n跟网上找的资料说的一样, 记录下电脑的端口号 和 IPv4的数值\n\n## 手机\n进入wife连接界面 -> 点击wife右边那个感叹号 -> 找到高级选项 -> 把代理换成手动设置 -> 将 IP设置改为静态 -> IP地址设置为电脑提供的 IPv4 的数值 -> 端口号也改成电脑的值 -> 隐私那里改成\"使用设备MAC地址\"\n\nok, 恭喜你\n\n现在, 你可以自由的在手机上访问github啦!","tags":["手机设置代理"],"categories":["生活"]},{"title":"Vue3","url":"/posts/2025/07/Fronted/Vue/Vue3/3a42db2d.html","content":"# 1. Vue3简介\n- 2020年9月18日，`Vue.js`发布版`3.0`版本，代号：`One Piece`（n\n- 经历了：[4800+次提交](https://github.com/vuejs/core/commits/main)、[40+个RFC](https://github.com/vuejs/rfcs/tree/master/active-rfcs)、[600+次PR](https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+)、[300+贡献者](https://github.com/vuejs/core/graphs/contributors)\n- 官方发版地址：[Release v3.0.0 One Piece · vuejs/core](https://github.com/vuejs/core/releases/tag/v3.0.0)\n- 截止2023年10月，最新的公开版本为：`3.3.4`\n\n  <img src=\"images/1695089947298-161c1b47-eb86-42fb-b1f8-d6a4fcab8ee2.png\" alt=\"image.png\" style=\"zoom:30%;\" /> \n\n## 1.1. 【性能的提升】\n\n- 打包大小减少`41%`。\n\n- 初次渲染快`55%`, 更新渲染快`133%`。\n\n- 内存减少`54%`。\n\n  \n## 1.2.【 源码的升级】\n\n- 使用`Proxy`代替`defineProperty`实现响应式。\n\n- 重写虚拟`DOM`的实现和`Tree-Shaking`。\n\n  \n## 1.3. 【拥抱TypeScript】\n\n- `Vue3`可以更好的支持`TypeScript`。\n\n  \n## 1.4. 【新的特性】\n\n1. `Composition API`（组合`API`）：\n   - `setup`\n   - `ref`与`reactive`\n   - `computed`与`watch`\n   \n     ......\n   \n2. 新的内置组件：\n   - `Fragment`\n   - `Teleport`\n   - `Suspense`\n\n     ......\n\n3. 其他改变：\n   - 新的生命周期钩子\n   - `data` 选项应始终被声明为一个函数\n   - 移除`keyCode`支持作为` v-on` 的修饰符\n\n     ......\n\n\n\n# 2. 创建Vue3工程\n\n## 2.1. 【基于 vue-cli 创建】\n\n点击查看[官方文档](https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create)\n\n> 备注：目前`vue-cli`已处于维护模式，官方推荐基于 `Vite` 创建项目。\n\n```powershell\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version\n\n## 安装或者升级你的@vue/cli \nnpm install -g @vue/cli\n\n## 执行创建命令\nvue create vue_test\n\n##  随后选择3.x\n##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)\n##  > 3.x\n##    2.x\n\n## 启动\ncd vue_test\nnpm run serve\n```\n\n---\n\n## 2.2. 【基于 vite 创建】(推荐)\n`vite` 是新一代前端构建工具，官网地址：[https://vitejs.cn](https://vitejs.cn/)，`vite`的优势如下：\n\n- 轻量快速的热重载（`HMR`），能实现极速的服务启动。\n- 对 `TypeScript`、`JSX`、`CSS` 等支持开箱即用。\n- 真正的按需编译，不再等待整个应用编译完成。\n- `webpack`构建 与 `vite`构建对比图如下：\n<img src=\"images/1683167182037-71c78210-8217-4e7d-9a83-e463035efbbe.png\" alt=\"webpack构建\" title=\"webpack构建\" style=\"zoom:20%;box-shadow:0 0 10px black\" />\t<img src=\"images/1683167204081-582dc237-72bc-499e-9589-2cdfd452e62f.png\" alt=\"vite构建\" title=\"vite构建\" style=\"zoom: 20%;box-shadow:0 0 10px black\" />\n* 具体操作如下（点击查看[官方文档](https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application)）\n\n```powershell\n## 1.创建命令\nnpm create vue@latest\n\n## 2.具体配置\n## 配置项目名称\n√ Project name: vue3_test\n## 是否添加TypeScript支持\n√ Add TypeScript?  Yes\n## 是否添加JSX支持\n√ Add JSX Support?  No\n## 是否添加路由环境\n√ Add Vue Router for Single Page Application development?  No\n## 是否添加pinia环境\n√ Add Pinia for state management?  No\n## 是否添加单元测试\n√ Add Vitest for Unit Testing?  No\n## 是否添加端到端测试方案\n√ Add an End-to-End Testing Solution? » No\n## 是否添加ESLint语法检查\n√ Add ESLint for code quality?  Yes\n## 是否添加Prettiert代码格式化\n√ Add Prettier for code formatting?  No\n```\n自己动手编写一个App组件\n\n```vue\n<template>\n  <div class=\"app\">\n    <h1>你好啊！</h1>\n  </div>\n</template>\n\n<script lang=\"ts\">\n  export default {\n    name:'App' //组件名\n  }\n</script>\n\n<style>\n  .app {\n    background-color: #ddd;\n    box-shadow: 0 0 10px;\n    border-radius: 10px;\n    padding: 20px;\n  }\n</style>\n```\n\n安装官方推荐的`vscode`插件：\n\n<img src=\"images/volar.png\" alt=\"Snipaste_2023-10-08_20-46-34\" style=\"zoom:50%;\" /> \n\n<img src=\"images/image-20231218085906380.png\" alt=\"image-20231218085906380\" style=\"zoom:42%;\" /> \n\n总结：\n\n- `Vite` 项目中，`index.html` 是项目的入口文件，在项目最外层。\n- 加载`index.html`后，`Vite` 解析 `<script type=\"module\" src=\"xxx\">` 指向的`JavaScript`。\n- `Vue3`**中是通过 **`createApp` 函数创建一个应用实例。\n## 2.3. 【一个简单的效果】\n\n`Vue3`向下兼容`Vue2`语法，且`Vue3`中的模板中可以没有根标签\n\n```vue\n<template>\n  <div class=\"person\">\n    <h2>姓名：{{name}}</h2>\n    <h2>年龄：{{age}}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">年龄+1</button>\n    <button @click=\"showTel\">点我查看联系方式</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\n  export default {\n    name:'App',\n    data() {\n      return {\n        name:'张三',\n        age:18,\n        tel:'13888888888'\n      }\n    },\n    methods:{\n      changeName(){\n        this.name = 'zhang-san'\n      },\n      changeAge(){\n        this.age += 1\n      },\n      showTel(){\n        alert(this.tel)\n      }\n    },\n  }\n</script>\n```\n\n\n# 3. Vue3核心语法\n## 3.1.  【OptionsAPI 与 CompositionAPI】\n\n- `Vue2`的`API`设计是`Options`（配置）风格的。\n- `Vue3`的`API`设计是`Composition`（组合）风格的。\n###  Options API 的弊端\n\n`Options`类型的 `API`，数据、方法、计算属性等，是分散在：`data`、`methods`、`computed`中的，若想新增或者修改一个需求，就需要分别修改：`data`、`methods`、`computed`，不便于维护和复用。\n\n<img src=\"images/1696662197101-55d2b251-f6e5-47f4-b3f1-d8531bbf9279.gif\" alt=\"1.gif\" style=\"zoom:70%;border-radius:20px\" /><img src=\"images/1696662200734-1bad8249-d7a2-423e-a3c3-ab4c110628be.gif\" alt=\"2.gif\" style=\"zoom:70%;border-radius:20px\" />\n\n### Composition API 的优势\n\n可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。\n\n<img src=\"images/1696662249851-db6403a1-acb5-481a-88e0-e1e34d2ef53a.gif\" alt=\"3.gif\" style=\"height:300px;border-radius:10px\"  /><img src=\"images/1696662256560-7239b9f9-a770-43c1-9386-6cc12ef1e9c0.gif\" alt=\"4.gif\" style=\"height:300px;border-radius:10px\"  />\n\n> 说明：以上四张动图原创作者：大帅老猿\n\n## 3.2. 【拉开序幕的 setup】\n### setup 概述\n`setup`是`Vue3`中一个新的配置项，值是一个函数，它是 `Composition API` **“表演的舞台**_**”**_，组件中所用到的：数据、方法、计算属性、监视......等等，均配置在`setup`中。\n\n特点如下：\n\n- `setup`函数返回的对象中的内容，可直接在模板中使用。\n- `setup`中访问`this`是`undefined`。\n- `setup`函数会在`beforeCreate`之前调用，它是“领先”所有钩子执行的。\n```vue\n<template>\n  <div class=\"person\">\n    <h2>姓名：{{name}}</h2>\n    <h2>年龄：{{age}}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">年龄+1</button>\n    <button @click=\"showTel\">点我查看联系方式</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\n  export default {\n    name:'Person',\n    setup(){\n      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）\n      let name = '张三'\n      let age = 18\n      let tel = '13888888888'\n\n      // 方法，原来写在methods中\n      function changeName(){\n        name = 'zhang-san' //注意：此时这么修改name页面是不变化的\n        console.log(name)\n      }\n      function changeAge(){\n        age += 1 //注意：此时这么修改age页面是不变化的\n        console.log(age)\n      }\n      function showTel(){\n        alert(tel)\n      }\n\n      // 返回一个对象，对象中的内容，模板中可以直接使用\n      return {name,age,tel,changeName,changeAge,showTel}\n    }\n  }\n</script>\n```\n### setup 的返回值\n\n- 若返回一个**对象**：则对象中的：属性、方法等，在模板中均可以直接使用**（重点关注）。**\n- 若返回一个**函数**：则可以自定义渲染内容，代码如下：\n```jsx\nsetup(){\n  return ()=> '你好啊！'\n}\n```\n### setup 与 Options API 的关系\n\n- `Vue2` 的配置（`data`、`methos`......）中**可以访问到** `setup`中的属性、方法。\n- 但在`setup`中**不能访问到**`Vue2`的配置（`data`、`methos`......）。\n- 如果与`Vue2`冲突，则`setup`优先。\n### setup 语法糖\n`setup`函数有一个语法糖，这个语法糖，可以让我们把`setup`独立出去，代码如下：\n\n```vue\n<template>\n  <div class=\"person\">\n    <h2>姓名：{{name}}</h2>\n    <h2>年龄：{{age}}</h2>\n    <button @click=\"changName\">修改名字</button>\n    <button @click=\"changAge\">年龄+1</button>\n    <button @click=\"showTel\">点我查看联系方式</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\n  export default {\n    name:'Person',\n  }\n</script>\n\n<!-- 下面的写法是setup语法糖 -->\n<script setup lang=\"ts\">\n  console.log(this) //undefined\n  \n  // 数据（注意：此时的name、age、tel都不是响应式数据）\n  let name = '张三'\n  let age = 18\n  let tel = '13888888888'\n\n  // 方法\n  function changName(){\n    name = '李四'//注意：此时这么修改name页面是不变化的\n  }\n  function changAge(){\n    console.log(age)\n    age += 1 //注意：此时这么修改age页面是不变化的\n  }\n  function showTel(){\n    alert(tel)\n  }\n</script>\n```\n扩展：上述代码，还需要编写一个不写`setup`的`script`标签，去指定组件名字，比较麻烦，我们可以借助`vite`中的插件简化\n\n1. 第一步：`npm i vite-plugin-vue-setup-extend -D`\n2. 第二步：`vite.config.ts`\n```jsx\nimport { defineConfig } from 'vite'\nimport VueSetupExtend from 'vite-plugin-vue-setup-extend'\n\nexport default defineConfig({\n  plugins: [ VueSetupExtend() ]\n})\n```\n\n3. 第三步：`<script setup lang=\"ts\" name=\"Person\">`\n## 3.3. 【ref 创建：基本类型的响应式数据】\n\n- **作用：**定义响应式变量。\n- **语法：**`let xxx = ref(初始值)`。\n- **返回值：**一个`RefImpl`的实例对象，简称`ref对象`或`ref`，`ref`对象的`value`**属性是响应式的**。\n- **注意点：**\n   - `JS`中操作数据需要：`xxx.value`，但模板中不需要`.value`，直接使用即可。\n   - 对于`let name = ref('张三')`来说，`name`不是响应式的，`name.value`是响应式的。\n```vue\n<template>\n  <div class=\"person\">\n    <h2>姓名：{{name}}</h2>\n    <h2>年龄：{{age}}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">年龄+1</button>\n    <button @click=\"showTel\">点我查看联系方式</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\" name=\"Person\">\n  import {ref} from 'vue'\n  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。\n  let name = ref('张三')\n  let age = ref(18)\n  // tel就是一个普通的字符串，不是响应式的\n  let tel = '13888888888'\n\n  function changeName(){\n    // JS中操作ref对象时候需要.value\n    name.value = '李四'\n    console.log(name.value)\n\n    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。\n    // name = ref('zhang-san')\n  }\n  function changeAge(){\n    // JS中操作ref对象时候需要.value\n    age.value += 1 \n    console.log(age.value)\n  }\n  function showTel(){\n    alert(tel)\n  }\n</script>\n```\n## 3.4. 【reactive 创建：对象类型的响应式数据】\n\n- **作用：**定义一个**响应式对象**（基本类型不要用它，要用`ref`，否则报错）\n- **语法：**`let 响应式对象= reactive(源对象)`。\n- **返回值：**一个`Proxy`的实例对象，简称：响应式对象。\n- **注意点：**`reactive`定义的响应式数据是“深层次”的。\n```vue\n<template>\n  <div class=\"person\">\n    <h2>汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万</h2>\n    <h2>游戏列表：</h2>\n    <ul>\n      <li v-for=\"g in games\" :key=\"g.id\">{{ g.name }}</li>\n    </ul>\n    <h2>测试：{{obj.a.b.c.d}}</h2>\n    <button @click=\"changeCarPrice\">修改汽车价格</button>\n    <button @click=\"changeFirstGame\">修改第一游戏</button>\n    <button @click=\"test\">测试</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\nimport { reactive } from 'vue'\n\n// 数据\nlet car = reactive({ brand: '奔驰', price: 100 })\nlet games = reactive([\n  { id: 'ahsgdyfa01', name: '英雄联盟' },\n  { id: 'ahsgdyfa02', name: '王者荣耀' },\n  { id: 'ahsgdyfa03', name: '原神' }\n])\nlet obj = reactive({\n  a:{\n    b:{\n      c:{\n        d:666\n      }\n    }\n  }\n})\n\nfunction changeCarPrice() {\n  car.price += 10\n}\nfunction changeFirstGame() {\n  games[0].name = '流星蝴蝶剑'\n}\nfunction test(){\n  obj.a.b.c.d = 999\n}\n</script>\n```\n## 3.5. 【ref 创建：对象类型的响应式数据】\n\n- 其实`ref`接收的数据可以是：**基本类型**、**对象类型**。\n- 若`ref`接收的是对象类型，内部其实也是调用了`reactive`函数。\n```vue\n<template>\n  <div class=\"person\">\n    <h2>汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万</h2>\n    <h2>游戏列表：</h2>\n    <ul>\n      <li v-for=\"g in games\" :key=\"g.id\">{{ g.name }}</li>\n    </ul>\n    <h2>测试：{{obj.a.b.c.d}}</h2>\n    <button @click=\"changeCarPrice\">修改汽车价格</button>\n    <button @click=\"changeFirstGame\">修改第一游戏</button>\n    <button @click=\"test\">测试</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\nimport { ref } from 'vue'\n\n// 数据\nlet car = ref({ brand: '奔驰', price: 100 })\nlet games = ref([\n  { id: 'ahsgdyfa01', name: '英雄联盟' },\n  { id: 'ahsgdyfa02', name: '王者荣耀' },\n  { id: 'ahsgdyfa03', name: '原神' }\n])\nlet obj = ref({\n  a:{\n    b:{\n      c:{\n        d:666\n      }\n    }\n  }\n})\n\nconsole.log(car)\n\nfunction changeCarPrice() {\n  car.value.price += 10\n}\nfunction changeFirstGame() {\n  games.value[0].name = '流星蝴蝶剑'\n}\nfunction test(){\n  obj.value.a.b.c.d = 999\n}\n</script>\n```\n## 3.6. 【ref 对比 reactive】\n宏观角度看：\n\n> 1. `ref`用来定义：**基本类型数据**、**对象类型数据**；\n>\n> 2. `reactive`用来定义：**对象类型数据**。\n\n- 区别：\n\n> 1. `ref`创建的变量必须使用`.value`（可以使用`volar`插件自动添加`.value`）。\n>\n>    <img src=\"images/自动补充value.png\" alt=\"自动补充value\" style=\"zoom:50%;border-radius:20px\" /> \n>\n> 2. `reactive`重新分配一个新对象，会**失去**响应式（可以使用`Object.assign`去整体替换）。\n\n- 使用原则：\n> 1. 若需要一个基本类型的响应式数据，必须使用`ref`。\n> 2. 若需要一个响应式对象，层级不深，`ref`、`reactive`都可以。\n> 3. 若需要一个响应式对象，且层级较深，推荐使用`reactive`。\n\n## 3.7. 【toRefs 与 toRef】\n\n- 作用：将一个响应式对象中的每一个属性，转换为`ref`对象。\n- 备注：`toRefs`与`toRef`功能一致，但`toRefs`可以批量转换。\n- 语法如下：\n```vue\n<template>\n  <div class=\"person\">\n    <h2>姓名：{{person.name}}</h2>\n    <h2>年龄：{{person.age}}</h2>\n    <h2>性别：{{person.gender}}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">修改年龄</button>\n    <button @click=\"changeGender\">修改性别</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\n  import {ref,reactive,toRefs,toRef} from 'vue'\n\n  // 数据\n  let person = reactive({name:'张三', age:18, gender:'男'})\n\t\n  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力\n  let {name,gender} =  toRefs(person)\n\t\n  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力\n  let age = toRef(person,'age')\n\n  // 方法\n  function changeName(){\n    name.value += '~'\n  }\n  function changeAge(){\n    age.value += 1\n  }\n  function changeGender(){\n    gender.value = '女'\n  }\n</script>\n```\n## 3.8. 【computed】\n\n作用：根据已有数据计算出新数据（和`Vue2`中的`computed`作用一致）。\n\n<img src=\"images/computed.gif\" style=\"zoom:20%;\" />  \n\n```vue\n<template>\n  <div class=\"person\">\n    姓：<input type=\"text\" v-model=\"firstName\"> <br>\n    名：<input type=\"text\" v-model=\"lastName\"> <br>\n    全名：<span>{{fullName}}</span> <br>\n    <button @click=\"changeFullName\">全名改为：li-si</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\" name=\"App\">\n  import {ref,computed} from 'vue'\n\n  let firstName = ref('zhang')\n  let lastName = ref('san')\n\n  // 计算属性——只读取，不修改\n  /* let fullName = computed(()=>{\n    return firstName.value + '-' + lastName.value\n  }) */\n\n\n  // 计算属性——既读取又修改\n  let fullName = computed({\n    // 读取\n    get(){\n      return firstName.value + '-' + lastName.value\n    },\n    // 修改\n    set(val){\n      console.log('有人修改了fullName',val)\n      firstName.value = val.split('-')[0]\n      lastName.value = val.split('-')[1]\n    }\n  })\n\n  function changeFullName(){\n    fullName.value = 'li-si'\n  } \n</script>\n```\n## 3.9.【watch】\n\n- 作用：监视数据的变化（和`Vue2`中的`watch`作用一致）\n- 特点：`Vue3`中的`watch`只能监视以下**四种数据**：\n> 1. `ref`定义的数据。\n> 2. `reactive`定义的数据。\n> 3. 函数返回一个值（`getter`函数）。\n> 4. 一个包含上述内容的数组。\n\n我们在`Vue3`中使用`watch`的时候，通常会遇到以下几种情况：\n### * 情况一\n监视`ref`定义的【基本类型】数据：直接写数据名即可，监视的是其`value`值的改变。\n\n```vue\n<template>\n  <div class=\"person\">\n    <h1>情况一：监视【ref】定义的【基本类型】数据</h1>\n    <h2>当前求和为：{{sum}}</h2>\n    <button @click=\"changeSum\">点我sum+1</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\n  import {ref,watch} from 'vue'\n  // 数据\n  let sum = ref(0)\n  // 方法\n  function changeSum(){\n    sum.value += 1\n  }\n  // 监视，情况一：监视【ref】定义的【基本类型】数据\n  const stopWatch = watch(sum,(newValue,oldValue)=>{\n    console.log('sum变化了',newValue,oldValue)\n    if(newValue >= 10){\n      stopWatch()\n    }\n  })\n</script>\n```\n### * 情况二\n监视`ref`定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。\n\n> 注意：\n>\n> * 若修改的是`ref`定义的对象中的属性，`newValue` 和 `oldValue` 都是新值，因为它们是同一个对象。\n>\n> * 若修改整个`ref`定义的对象，`newValue` 是新值， `oldValue` 是旧值，因为不是同一个对象了。\n\n```vue\n<template>\n  <div class=\"person\">\n    <h1>情况二：监视【ref】定义的【对象类型】数据</h1>\n    <h2>姓名：{{ person.name }}</h2>\n    <h2>年龄：{{ person.age }}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">修改年龄</button>\n    <button @click=\"changePerson\">修改整个人</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\n  import {ref,watch} from 'vue'\n  // 数据\n  let person = ref({\n    name:'张三',\n    age:18\n  })\n  // 方法\n  function changeName(){\n    person.value.name += '~'\n  }\n  function changeAge(){\n    person.value.age += 1\n  }\n  function changePerson(){\n    person.value = {name:'李四',age:90}\n  }\n  /* \n    监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视\n    watch的第一个参数是：被监视的数据\n    watch的第二个参数是：监视的回调\n    watch的第三个参数是：配置对象（deep、immediate等等.....） \n  */\n  watch(person,(newValue,oldValue)=>{\n    console.log('person变化了',newValue,oldValue)\n  },{deep:true})\n  \n</script>\n```\n### *  情况三\n监视`reactive`定义的【对象类型】数据，且默认开启了深度监视。\n```vue\n<template>\n  <div class=\"person\">\n    <h1>情况三：监视【reactive】定义的【对象类型】数据</h1>\n    <h2>姓名：{{ person.name }}</h2>\n    <h2>年龄：{{ person.age }}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">修改年龄</button>\n    <button @click=\"changePerson\">修改整个人</button>\n    <hr>\n    <h2>测试：{{obj.a.b.c}}</h2>\n    <button @click=\"test\">修改obj.a.b.c</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\n  import {reactive,watch} from 'vue'\n  // 数据\n  let person = reactive({\n    name:'张三',\n    age:18\n  })\n  let obj = reactive({\n    a:{\n      b:{\n        c:666\n      }\n    }\n  })\n  // 方法\n  function changeName(){\n    person.name += '~'\n  }\n  function changeAge(){\n    person.age += 1\n  }\n  function changePerson(){\n    Object.assign(person,{name:'李四',age:80})\n  }\n  function test(){\n    obj.a.b.c = 888\n  }\n\n  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的\n  watch(person,(newValue,oldValue)=>{\n    console.log('person变化了',newValue,oldValue)\n  })\n  watch(obj,(newValue,oldValue)=>{\n    console.log('Obj变化了',newValue,oldValue)\n  })\n</script>\n```\n### * 情况四\n监视`ref`或`reactive`定义的【对象类型】数据中的**某个属性**，注意点如下：\n\n1. 若该属性值**不是**【对象类型】，需要写成函数形式。\n2. 若该属性值是**依然**是【对象类型】，可直接编，也可写成函数，建议写成函数。\n\n结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。\n\n```vue\n<template>\n  <div class=\"person\">\n    <h1>情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性</h1>\n    <h2>姓名：{{ person.name }}</h2>\n    <h2>年龄：{{ person.age }}</h2>\n    <h2>汽车：{{ person.car.c1 }}、{{ person.car.c2 }}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">修改年龄</button>\n    <button @click=\"changeC1\">修改第一台车</button>\n    <button @click=\"changeC2\">修改第二台车</button>\n    <button @click=\"changeCar\">修改整个车</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\n  import {reactive,watch} from 'vue'\n\n  // 数据\n  let person = reactive({\n    name:'张三',\n    age:18,\n    car:{\n      c1:'奔驰',\n      c2:'宝马'\n    }\n  })\n  // 方法\n  function changeName(){\n    person.name += '~'\n  }\n  function changeAge(){\n    person.age += 1\n  }\n  function changeC1(){\n    person.car.c1 = '奥迪'\n  }\n  function changeC2(){\n    person.car.c2 = '大众'\n  }\n  function changeCar(){\n    person.car = {c1:'雅迪',c2:'爱玛'}\n  }\n\n  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式\n  /* watch(()=> person.name,(newValue,oldValue)=>{\n    console.log('person.name变化了',newValue,oldValue)\n  }) */\n\n  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数\n  watch(()=>person.car,(newValue,oldValue)=>{\n    console.log('person.car变化了',newValue,oldValue)\n  },{deep:true})\n</script>\n```\n### * 情况五\n监视上述的多个数据\n```vue\n<template>\n  <div class=\"person\">\n    <h1>情况五：监视上述的多个数据</h1>\n    <h2>姓名：{{ person.name }}</h2>\n    <h2>年龄：{{ person.age }}</h2>\n    <h2>汽车：{{ person.car.c1 }}、{{ person.car.c2 }}</h2>\n    <button @click=\"changeName\">修改名字</button>\n    <button @click=\"changeAge\">修改年龄</button>\n    <button @click=\"changeC1\">修改第一台车</button>\n    <button @click=\"changeC2\">修改第二台车</button>\n    <button @click=\"changeCar\">修改整个车</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\n  import {reactive,watch} from 'vue'\n\n  // 数据\n  let person = reactive({\n    name:'张三',\n    age:18,\n    car:{\n      c1:'奔驰',\n      c2:'宝马'\n    }\n  })\n  // 方法\n  function changeName(){\n    person.name += '~'\n  }\n  function changeAge(){\n    person.age += 1\n  }\n  function changeC1(){\n    person.car.c1 = '奥迪'\n  }\n  function changeC2(){\n    person.car.c2 = '大众'\n  }\n  function changeCar(){\n    person.car = {c1:'雅迪',c2:'爱玛'}\n  }\n\n  // 监视，情况五：监视上述的多个数据\n  watch([()=>person.name,person.car],(newValue,oldValue)=>{\n    console.log('person.car变化了',newValue,oldValue)\n  },{deep:true})\n\n</script>\n```\n## 3.10. 【watchEffect】\n\n* 官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。\n\n* `watch`对比`watchEffect`\n\n  > 1. 都能监听响应式数据的变化，不同的是监听数据变化的方式不同\n  >\n  > 2. `watch`：要明确指出监视的数据\n  >\n  > 3. `watchEffect`：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。\n\n* 示例代码：\n\n  ```vue\n  <template>\n    <div class=\"person\">\n      <h1>需求：水温达到50℃，或水位达到20cm，则联系服务器</h1>\n      <h2 id=\"demo\">水温：{{temp}}</h2>\n      <h2>水位：{{height}}</h2>\n      <button @click=\"changePrice\">水温+1</button>\n      <button @click=\"changeSum\">水位+10</button>\n    </div>\n  </template>\n  \n  <script lang=\"ts\" setup name=\"Person\">\n    import {ref,watch,watchEffect} from 'vue'\n    // 数据\n    let temp = ref(0)\n    let height = ref(0)\n  \n    // 方法\n    function changePrice(){\n      temp.value += 10\n    }\n    function changeSum(){\n      height.value += 1\n    }\n  \n    // 用watch实现，需要明确的指出要监视：temp、height\n    watch([temp,height],(value)=>{\n      // 从value中获取最新的temp值、height值\n      const [newTemp,newHeight] = value\n      // 室温达到50℃，或水位达到20cm，立刻联系服务器\n      if(newTemp >= 50 || newHeight >= 20){\n        console.log('联系服务器')\n      }\n    })\n  \n    // 用watchEffect实现，不用\n    const stopWtach = watchEffect(()=>{\n      // 室温达到50℃，或水位达到20cm，立刻联系服务器\n      if(temp.value >= 50 || height.value >= 20){\n        console.log(document.getElementById('demo')?.innerText)\n        console.log('联系服务器')\n      }\n      // 水温达到100，或水位达到50，取消监视\n      if(temp.value === 100 || height.value === 50){\n        console.log('清理了')\n        stopWtach()\n      }\n    })\n  </script>\n  ```\n  \n  \n\n## 3.11. 【标签的 ref 属性】\n\n作用：用于注册模板引用。\n\n> * 用在普通`DOM`标签上，获取的是`DOM`节点。\n>\n> * 用在组件标签上，获取的是组件实例对象。\n\n用在普通`DOM`标签上：\n\n```vue\n<template>\n  <div class=\"person\">\n    <h1 ref=\"title1\">尚硅谷</h1>\n    <h2 ref=\"title2\">前端</h2>\n    <h3 ref=\"title3\">Vue</h3>\n    <input type=\"text\" ref=\"inpt\"> <br><br>\n    <button @click=\"showLog\">点我打印内容</button>\n  </div>\n</template>\n\n<script lang=\"ts\" setup name=\"Person\">\n  import {ref} from 'vue'\n\t\n  let title1 = ref()\n  let title2 = ref()\n  let title3 = ref()\n\n  function showLog(){\n    // 通过id获取元素\n    const t1 = document.getElementById('title1')\n    // 打印内容\n    console.log((t1 as HTMLElement).innerText)\n    console.log((<HTMLElement>t1).innerText)\n    console.log(t1?.innerText)\n    \n\t\t/************************************/\n\t\t\n    // 通过ref获取元素\n    console.log(title1.value)\n    console.log(title2.value)\n    console.log(title3.value)\n  }\n</script>\n```\n\n用在组件标签上：\n\n```vue\n<!-- 父组件App.vue -->\n<template>\n  <Person ref=\"ren\"/>\n  <button @click=\"test\">测试</button>\n</template>\n\n<script lang=\"ts\" setup name=\"App\">\n  import Person from './components/Person.vue'\n  import {ref} from 'vue'\n\n  let ren = ref()\n\n  function test(){\n    console.log(ren.value.name)\n    console.log(ren.value.age)\n  }\n</script>\n\n\n<!-- 子组件Person.vue中要使用defineExpose暴露内容 -->\n<script lang=\"ts\" setup name=\"Person\">\n  import {ref,defineExpose} from 'vue'\n\t// 数据\n  let name = ref('张三')\n  let age = ref(18)\n  /****************************/\n  /****************************/\n  // 使用defineExpose将组件中的数据交给外部\n  defineExpose({name,age})\n</script>\n```\n\n\n\n## 3.12. 【props】\n\n> ```js\n>// 定义一个接口，限制每个Person对象的格式\n> export interface PersonInter {\n>  id:string,\n>  name:string,\n>     age:number\n>    }\n>    \n> // 定义一个自定义类型Persons\n> export type Persons = Array<PersonInter>\n> ```\n> \n> `App.vue`中代码：\n>\n> ```vue\n><template>\n> \t<Person :list=\"persons\"/>\n> </template>\n>   \n> <script lang=\"ts\" setup name=\"App\">\n>   import Person from './components/Person.vue'\n>   import {reactive} from 'vue'\n>     import {type Persons} from './types'\n>   \n>     let persons = reactive<Persons>([\n>      {id:'e98219e12',name:'张三',age:18},\n>       {id:'e98219e13',name:'李四',age:19},\n>        {id:'e98219e14',name:'王五',age:20}\n>      ])\n>    </script>\n>   \n> ```\n> \n> `Person.vue`中代码：\n>\n> ```Vue\n><template>\n> <div class=\"person\">\n>  <ul>\n>      <li v-for=\"item in list\" :key=\"item.id\">\n>         {{item.name}}--{{item.age}}\n>       </li>\n>     </ul>\n>    </div>\n>    </template>\n>   \n> <script lang=\"ts\" setup name=\"Person\">\n> import {defineProps} from 'vue'\n> import {type PersonInter} from '@/types'\n>   \n>   // 第一种写法：仅接收\n> // const props = defineProps(['list'])\n>   \n>   // 第二种写法：接收+限制类型\n> // defineProps<{list:Persons}>()\n>   \n>   // 第三种写法：接收+限制类型+指定默认值+限制必要性\n> let props = withDefaults(defineProps<{list?:Persons}>(),{\n>      list:()=>[{id:'asdasg01',name:'小猪佩奇',age:18}]\n>   })\n>    console.log(props)\n>   </script>\n>   ```\n> \n\n## 3.13. 【生命周期】\n\n* 概念：`Vue`组件实例在创建时要经历一系列的初始化步骤，在此过程中`Vue`会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子\n\n* 规律：\n\n  > 生命周期整体分为四个阶段，分别是：**创建、挂载、更新、销毁**，每个阶段都有两个钩子，一前一后。\n\n* `Vue2`的生命周期\n\n  > 创建阶段：`beforeCreate`、`created`\n  >\n  > 挂载阶段：`beforeMount`、`mounted`\n  >\n  > 更新阶段：`beforeUpdate`、`updated`\n  >\n  > 销毁阶段：`beforeDestroy`、`destroyed`\n\n* `Vue3`的生命周期\n\n  > 创建阶段：`setup`\n  >\n  > 挂载阶段：`onBeforeMount`、`onMounted`\n  >\n  > 更新阶段：`onBeforeUpdate`、`onUpdated`\n  >\n  > 卸载阶段：`onBeforeUnmount`、`onUnmounted`\n\n* 常用的钩子：`onMounted`(挂载完毕)、`onUpdated`(更新完毕)、`onBeforeUnmount`(卸载之前)\n\n* 示例代码：\n\n  ```vue\n  <template>\n    <div class=\"person\">\n      <h2>当前求和为：{{ sum }}</h2>\n      <button @click=\"changeSum\">点我sum+1</button>\n    </div>\n  </template>\n  \n  <!-- vue3写法 -->\n  <script lang=\"ts\" setup name=\"Person\">\n    import { \n      ref, \n      onBeforeMount, \n      onMounted, \n      onBeforeUpdate, \n      onUpdated, \n      onBeforeUnmount, \n      onUnmounted \n    } from 'vue'\n  \n    // 数据\n    let sum = ref(0)\n    // 方法\n    function changeSum() {\n      sum.value += 1\n    }\n    console.log('setup')\n    // 生命周期钩子\n    onBeforeMount(()=>{\n      console.log('挂载之前')\n    })\n    onMounted(()=>{\n      console.log('挂载完毕')\n    })\n    onBeforeUpdate(()=>{\n      console.log('更新之前')\n    })\n    onUpdated(()=>{\n      console.log('更新完毕')\n    })\n    onBeforeUnmount(()=>{\n      console.log('卸载之前')\n    })\n    onUnmounted(()=>{\n      console.log('卸载完毕')\n    })\n  </script>\n  ```\n\n## 3.14. 【自定义hook】\n\n- 什么是`hook`？—— 本质是一个函数，把`setup`函数中使用的`Composition API`进行了封装，类似于`vue2.x`中的`mixin`。\n\n- 自定义`hook`的优势：复用代码, 让`setup`中的逻辑更清楚易懂。\n\n示例代码：\n\n- `useSum.ts`中内容如下：\n\n  ```js\n  import {ref,onMounted} from 'vue'\n  \n  export default function(){\n    let sum = ref(0)\n  \n    const increment = ()=>{\n      sum.value += 1\n    }\n    const decrement = ()=>{\n      sum.value -= 1\n    }\n    onMounted(()=>{\n      increment()\n    })\n  \n    //向外部暴露数据\n    return {sum,increment,decrement}\n  }\t\t\n  ```\n  \n- `useDog.ts`中内容如下：\n\n  ```js\n  import {reactive,onMounted} from 'vue'\n  import axios,{AxiosError} from 'axios'\n  \n  export default function(){\n    let dogList = reactive<string[]>([])\n  \n    // 方法\n    async function getDog(){\n      try {\n        // 发请求\n        let {data} = await axios.get('https://dog.ceo/api/breed/pembroke/images/random')\n        // 维护数据\n        dogList.push(data.message)\n      } catch (error) {\n        // 处理错误\n        const err = <AxiosError>error\n        console.log(err.message)\n      }\n    }\n  \n    // 挂载钩子\n    onMounted(()=>{\n      getDog()\n    })\n  \t\n    //向外部暴露数据\n    return {dogList,getDog}\n  }\n  ```\n\n- 组件中具体使用：\n\n  ```vue\n  <template>\n    <h2>当前求和为：{{sum}}</h2>\n    <button @click=\"increment\">点我+1</button>\n    <button @click=\"decrement\">点我-1</button>\n    <hr>\n    <img v-for=\"(u,index) in dogList.urlList\" :key=\"index\" :src=\"(u as string)\"> \n    <span v-show=\"dogList.isLoading\">加载中......</span><br>\n    <button @click=\"getDog\">再来一只狗</button>\n  </template>\n  \n  <script lang=\"ts\">\n    import {defineComponent} from 'vue'\n  \n    export default defineComponent({\n      name:'App',\n    })\n  </script>\n  \n  <script setup lang=\"ts\">\n    import useSum from './hooks/useSum'\n    import useDog from './hooks/useDog'\n  \t\n    let {sum,increment,decrement} = useSum()\n    let {dogList,getDog} = useDog()\n  </script>\n  ```\n\n    \n\n---\n\n# 4. 路由\n\n## 4.1. 【对路由的理解】\n\n<img src=\"images/image-20231018144351536.png\" alt=\"image-20231018144351536\" style=\"zoom:20%;border-radius:40px\" /> \n\n## 4.2. 【基本切换效果】\n\n- `Vue3`中要使用`vue-router`的最新版本，目前是`4`版本。\n\n- 路由配置文件代码如下：\n\n  ```js\n  import {createRouter,createWebHistory} from 'vue-router'\n  import Home from '@/pages/Home.vue'\n  import News from '@/pages/News.vue'\n  import About from '@/pages/About.vue'\n  \n  const router = createRouter({\n  \thistory:createWebHistory(),\n  \troutes:[\n  \t\t{\n  \t\t\tpath:'/home',\n  \t\t\tcomponent:Home\n  \t\t},\n  \t\t{\n  \t\t\tpath:'/about',\n  \t\t\tcomponent:About\n  \t\t}\n  \t]\n  })\n  export default router\n  ```\n* `main.ts`代码如下：\n\n  ```js\n  import router from './router/index'\n  app.use(router)\n  \n  app.mount('#app')\n  ```\n\n- `App.vue`代码如下\n\n  ```vue\n  <template>\n    <div class=\"app\">\n      <h2 class=\"title\">Vue路由测试</h2>\n      <!-- 导航区 -->\n      <div class=\"navigate\">\n        <RouterLink to=\"/home\" active-class=\"active\">首页</RouterLink>\n        <RouterLink to=\"/news\" active-class=\"active\">新闻</RouterLink>\n        <RouterLink to=\"/about\" active-class=\"active\">关于</RouterLink>\n      </div>\n      <!-- 展示区 -->\n      <div class=\"main-content\">\n        <RouterView></RouterView>\n      </div>\n    </div>\n  </template>\n  \n  <script lang=\"ts\" setup name=\"App\">\n    import {RouterLink,RouterView} from 'vue-router'  \n  </script>\n  ```\n\n## 4.3. 【两个注意点】\n\n> 1. 路由组件通常存放在`pages` 或 `views`文件夹，一般组件通常存放在`components`文件夹。\n>\n> 2. 通过点击导航，视觉效果上“消失” 了的路由组件，默认是被**卸载**掉的，需要的时候再去**挂载**。\n\n## 4.4.【路由器工作模式】\n\n1. `history`模式\n\n   > 优点：`URL`更加美观，不带有`#`，更接近传统的网站`URL`。\n   >\n   > 缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有`404`错误。\n   >\n   > ```js\n   > const router = createRouter({\n   >   \thistory:createWebHistory(), //history模式\n   >   \t/******/\n   > })\n   > ```\n\n2. `hash`模式\n\n   > 优点：兼容性更好，因为不需要服务器端处理路径。\n   >\n   > 缺点：`URL`带有`#`不太美观，且在`SEO`优化方面相对较差。\n   >\n   > ```js\n   > const router = createRouter({\n   >   \thistory:createWebHashHistory(), //hash模式\n   >   \t/******/\n   > })\n   > ```\n\n## 4.5. 【to的两种写法】\n\n```vue\n<!-- 第一种：to的字符串写法 -->\n<router-link active-class=\"active\" to=\"/home\">主页</router-link>\n\n<!-- 第二种：to的对象写法 -->\n<router-link active-class=\"active\" :to=\"{path:'/home'}\">Home</router-link>\n```\n\n## 4.6. 【命名路由】\n\n作用：可以简化路由跳转及传参（后面就讲）。\n\n给路由规则命名：\n\n```js\nroutes:[\n  {\n    name:'zhuye',\n    path:'/home',\n    component:Home\n  },\n  {\n    name:'xinwen',\n    path:'/news',\n    component:News,\n  },\n  {\n    name:'guanyu',\n    path:'/about',\n    component:About\n  }\n]\n```\n\n跳转路由：\n\n```vue\n<!--简化前：需要写完整的路径（to的字符串写法） -->\n<router-link to=\"/news/detail\">跳转</router-link>\n\n<!--简化后：直接通过名字跳转（to的对象写法配合name属性） -->\n<router-link :to=\"{name:'guanyu'}\">跳转</router-link>\n```\n\n\n\n## 4.7. 【嵌套路由】\n\n1. 编写`News`的子路由：`Detail.vue`\n\n2. 配置路由规则，使用`children`配置项：\n\n   ```ts\n   const router = createRouter({\n     history:createWebHistory(),\n   \troutes:[\n   \t\t{\n   \t\t\tname:'zhuye',\n   \t\t\tpath:'/home',\n   \t\t\tcomponent:Home\n   \t\t},\n   \t\t{\n   \t\t\tname:'xinwen',\n   \t\t\tpath:'/news',\n   \t\t\tcomponent:News,\n   \t\t\tchildren:[\n   \t\t\t\t{\n   \t\t\t\t\tname:'xiang',\n   \t\t\t\t\tpath:'detail',\n   \t\t\t\t\tcomponent:Detail\n   \t\t\t\t}\n   \t\t\t]\n   \t\t},\n   \t\t{\n   \t\t\tname:'guanyu',\n   \t\t\tpath:'/about',\n   \t\t\tcomponent:About\n   \t\t}\n   \t]\n   })\n   export default router\n   ```\n   \n3. 跳转路由（记得要加完整路径）：\n\n   ```vue\n   <router-link to=\"/news/detail\">xxxx</router-link>\n   <!-- 或 -->\n   <router-link :to=\"{path:'/news/detail'}\">xxxx</router-link>\n   ```\n\n4. 记得去`Home`组件中预留一个`<router-view>`\n\n   ```vue\n   <template>\n     <div class=\"news\">\n       <nav class=\"news-list\">\n         <RouterLink v-for=\"news in newsList\" :key=\"news.id\" :to=\"{path:'/news/detail'}\">\n           {{news.name}}\n         </RouterLink>\n       </nav>\n       <div class=\"news-detail\">\n         <RouterView/>\n       </div>\n     </div>\n   </template>\n   ```\n\n   \n\n## 4.8. 【路由传参】\n\n### query参数\n\n   1. 传递参数\n\n      ```vue\n      <!-- 跳转并携带query参数（to的字符串写法） -->\n      <router-link to=\"/news/detail?a=1&b=2&content=欢迎你\">\n      \t跳转\n      </router-link>\n      \t\t\t\t\n      <!-- 跳转并携带query参数（to的对象写法） -->\n      <RouterLink \n        :to=\"{\n          //name:'xiang', //用name也可以跳转\n          path:'/news/detail',\n          query:{\n            id:news.id,\n            title:news.title,\n            content:news.content\n          }\n        }\"\n      >\n        {{news.title}}\n      </RouterLink>\n      ```\n\n   2. 接收参数：\n\n      ```js\n      import {useRoute} from 'vue-router'\n      const route = useRoute()\n      // 打印query参数\n      console.log(route.query)\n      ```\n\n\n### params参数\n\n   1. 传递参数\n\n      ```vue\n      <!-- 跳转并携带params参数（to的字符串写法） -->\n      <RouterLink :to=\"`/news/detail/001/新闻001/内容001`\">{{news.title}}</RouterLink>\n      \t\t\t\t\n      <!-- 跳转并携带params参数（to的对象写法） -->\n      <RouterLink \n        :to=\"{\n          name:'xiang', //用name跳转\n          params:{\n            id:news.id,\n            title:news.title,\n            content:news.title\n          }\n        }\"\n      >\n        {{news.title}}\n      </RouterLink>\n      ```\n\n   2. 接收参数：\n\n      ```js\n      import {useRoute} from 'vue-router'\n      const route = useRoute()\n      // 打印params参数\n      console.log(route.params)\n      ```\n\n> 备注1：传递`params`参数时，若使用`to`的对象写法，必须使用`name`配置项，不能用`path`。\n>\n> 备注2：传递`params`参数时，需要提前在规则中占位。\n\n## 4.9. 【路由的props配置】\n\n作用：让路由组件更方便的收到参数（可以将路由参数作为`props`传给组件）\n\n```js\n{\n\tname:'xiang',\n\tpath:'detail/:id/:title/:content',\n\tcomponent:Detail,\n\n  // props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件\n  // props:{a:1,b:2,c:3}, \n\n  // props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件\n  // props:true\n  \n  // props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件\n  props(route){\n    return route.query\n  }\n}\n```\n\n## 4.10. 【 replace属性】\n\n  1. 作用：控制路由跳转时操作浏览器历史记录的模式。\n\n  2. 浏览器的历史记录有两种写入方式：分别为```push```和```replace```：\n\n     - ```push```是追加历史记录（默认值）。\n     - `replace`是替换当前记录。\n\n  3. 开启`replace`模式：\n\n     ```vue\n     <RouterLink replace .......>News</RouterLink>\n     ```\n\n## 4.11. 【编程式导航】\n\n路由组件的两个重要的属性：`$route`和`$router`变成了两个`hooks`\n\n```js\nimport {useRoute,useRouter} from 'vue-router'\n\nconst route = useRoute()\nconst router = useRouter()\n\nconsole.log(route.query)\nconsole.log(route.parmas)\nconsole.log(router.push)\nconsole.log(router.replace)\n```\n\n## 4.12. 【重定向】\n\n1. 作用：将特定的路径，重新定向到已有路由。\n\n2. 具体编码：\n\n   ```js\n   {\n       path:'/',\n       redirect:'/about'\n   }\n   ```\n\n\n\n# 5. pinia \n\n## 5.1【准备一个效果】\n\n<img src=\"./images/pinia_example.gif\" alt=\"pinia_example\" style=\"zoom:30%;border:3px solid\" /> \n\n## 5.2【搭建 pinia 环境】\n\n第一步：`npm install pinia`\n\n第二步：操作`src/main.ts`\n\n```ts\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\n/* 引入createPinia，用于创建pinia */\nimport { createPinia } from 'pinia'\n\n/* 创建pinia */\nconst pinia = createPinia()\nconst app = createApp(App)\n\n/* 使用插件 */{}\napp.use(pinia)\napp.mount('#app')\n```\n\n此时开发者工具中已经有了`pinia`选项\n\n<img src=\"https://cdn.nlark.com/yuque/0/2023/png/35780599/1684309952481-c67f67f9-d1a3-4d69-8bd6-2b381e003f31.png\" style=\"zoom:80%;border:1px solid black;border-radius:10px\" />\n\n## 5.3【存储+读取数据】\n\n1. `Store`是一个保存：**状态**、**业务逻辑** 的实体，每个组件都可以**读取**、**写入**它。\n\n2. 它有三个概念：`state`、`getter`、`action`，相当于组件中的： `data`、 `computed` 和 `methods`。\n\n3. 具体编码：`src/store/count.ts`\n\n   ```ts\n   // 引入defineStore用于创建store\n   import {defineStore} from 'pinia'\n   \n   // 定义并暴露一个store\n   export const useCountStore = defineStore('count',{\n     // 动作\n     actions:{},\n     // 状态\n     state(){\n       return {\n         sum:6\n       }\n     },\n     // 计算\n     getters:{}\n   })\n   ```\n\n4. 具体编码：`src/store/talk.ts`\n\n   ```js\n   // 引入defineStore用于创建store\n   import {defineStore} from 'pinia'\n   \n   // 定义并暴露一个store\n   export const useTalkStore = defineStore('talk',{\n     // 动作\n     actions:{},\n     // 状态\n     state(){\n       return {\n         talkList:[\n           {id:'yuysada01',content:'你今天有点怪，哪里怪？怪好看的！'},\n        \t\t{id:'yuysada02',content:'草莓、蓝莓、蔓越莓，你想我了没？'},\n           {id:'yuysada03',content:'心里给你留了一块地，我的死心塌地'}\n         ]\n       }\n     },\n     // 计算\n     getters:{}\n   })\n   ```\n   \n5. 组件中使用`state`中的数据\n\n   ```vue\n   <template>\n     <h2>当前求和为：{{ sumStore.sum }}</h2>\n   </template>\n   \n   <script setup lang=\"ts\" name=\"Count\">\n     // 引入对应的useXxxxxStore\t\n     import {useSumStore} from '@/store/sum'\n     \n     // 调用useXxxxxStore得到对应的store\n     const sumStore = useSumStore()\n   </script>\n   ```\n\n   ```vue\n   <template>\n   \t<ul>\n       <li v-for=\"talk in talkStore.talkList\" :key=\"talk.id\">\n         {{ talk.content }}\n       </li>\n     </ul>\n   </template>\n   \n   <script setup lang=\"ts\" name=\"Count\">\n     import axios from 'axios'\n     import {useTalkStore} from '@/store/talk'\n   \n     const talkStore = useTalkStore()\n   </script>\n   ```\n\n   \n\n## 5.4.【修改数据】(三种方式)\n\n1. 第一种修改方式，直接修改\n\n   ```ts\n   countStore.sum = 666\n   ```\n\n2. 第二种修改方式：批量修改\n\n   ```ts\n   countStore.$patch({\n     sum:999,\n     school:'atguigu'\n   })\n   ```\n\n3. 第三种修改方式：借助`action`修改（`action`中可以编写一些业务逻辑）\n\n   ```js\n   import { defineStore } from 'pinia'\n   \n   export const useCountStore = defineStore('count', {\n     /*************/\n     actions: {\n       //加\n       increment(value:number) {\n         if (this.sum < 10) {\n           //操作countStore中的sum\n           this.sum += value\n         }\n       },\n       //减\n       decrement(value:number){\n         if(this.sum > 1){\n           this.sum -= value\n         }\n       }\n     },\n     /*************/\n   })\n   ```\n\n4. 组件中调用`action`即可\n\n   ```js\n   // 使用countStore\n   const countStore = useCountStore()\n   \n   // 调用对应action\n   countStore.incrementOdd(n.value)\n   ```\n\n\n## 5.5.【storeToRefs】\n\n- 借助`storeToRefs`将`store`中的数据转为`ref`对象，方便在模板中使用。\n- 注意：`pinia`提供的`storeToRefs`只会将数据做转换，而`Vue`的`toRefs`会转换`store`中数据。\n\n```vue\n<template>\n\t<div class=\"count\">\n\t\t<h2>当前求和为：{{sum}}</h2>\n\t</div>\n</template>\n\n<script setup lang=\"ts\" name=\"Count\">\n  import { useCountStore } from '@/store/count'\n  /* 引入storeToRefs */\n  import { storeToRefs } from 'pinia'\n\n\t/* 得到countStore */\n  const countStore = useCountStore()\n  /* 使用storeToRefs转换countStore，随后解构 */\n  const {sum} = storeToRefs(countStore)\n</script>\n\n```\n\n## 5.6.【getters】\n\n  1. 概念：当`state`中的数据，需要经过处理后再使用时，可以使用`getters`配置。\n\n  2. 追加```getters```配置。\n\n     ```js\n     // 引入defineStore用于创建store\n     import {defineStore} from 'pinia'\n     \n     // 定义并暴露一个store\n     export const useCountStore = defineStore('count',{\n       // 动作\n       actions:{\n         /************/\n       },\n       // 状态\n       state(){\n         return {\n           sum:1,\n           school:'atguigu'\n         }\n       },\n       // 计算\n       getters:{\n         bigSum:(state):number => state.sum *10,\n         upperSchool():string{\n           return this. school.toUpperCase()\n         }\n       }\n     })\n     ```\n\n  3. 组件中读取数据：\n\n     ```js\n     const {increment,decrement} = countStore\n     let {sum,school,bigSum,upperSchool} = storeToRefs(countStore)\n     ```\n\n     \n\n## 5.7.【$subscribe】\n\n通过 store 的 `$subscribe()` 方法侦听 `state` 及其变化\n\n```ts\ntalkStore.$subscribe((mutate,state)=>{\n  console.log('LoveTalk',mutate,state)\n  localStorage.setItem('talk',JSON.stringify(talkList.value))\n})\n```\n\n\n\n## 5.8. 【store组合式写法】\n\n```ts\nimport {defineStore} from 'pinia'\nimport axios from 'axios'\nimport {nanoid} from 'nanoid'\nimport {reactive} from 'vue'\n\nexport const useTalkStore = defineStore('talk',()=>{\n  // talkList就是state\n  const talkList = reactive(\n    JSON.parse(localStorage.getItem('talkList') as string) || []\n  )\n\n  // getATalk函数相当于action\n  async function getATalk(){\n    // 发请求，下面这行的写法是：连续解构赋值+重命名\n    let {data:{content:title}} = await axios.get('https://api.uomg.com/api/rand.qinghua?format=json')\n    // 把请求回来的字符串，包装成一个对象\n    let obj = {id:nanoid(),title}\n    // 放到数组中\n    talkList.unshift(obj)\n  }\n  return {talkList,getATalk}\n})\n```\n\n\n\n# 6. 组件通信\n\n**`Vue3`组件通信和`Vue2`的区别：**\n\n* 移出事件总线，使用`mitt`代替。\n\n- `vuex`换成了`pinia`。\n- 把`.sync`优化到了`v-model`里面了。\n- 把`$listeners`所有的东西，合并到`$attrs`中了。\n- `$children`被砍掉了。\n\n**常见搭配形式：**\n\n<img src=\"images/image-20231119185900990.png\" alt=\"image-20231119185900990\" style=\"zoom:60%;\" /> \n\n## 6.1. 【props】\n\n概述：`props`是使用频率最高的一种通信方式，常用与 ：**父 ↔ 子**。\n\n- 若 **父传子**：属性值是**非函数**。\n- 若 **子传父**：属性值是**函数**。\n\n父组件：\n\n```vue\n<template>\n  <div class=\"father\">\n    <h3>父组件，</h3>\n\t\t<h4>我的车：{{ car }}</h4>\n\t\t<h4>儿子给的玩具：{{ toy }}</h4>\n\t\t<Child :car=\"car\" :getToy=\"getToy\"/>\n  </div>\n</template>\n\n<script setup lang=\"ts\" name=\"Father\">\n\timport Child from './Child.vue'\n\timport { ref } from \"vue\";\n\t// 数据\n\tconst car = ref('奔驰')\n\tconst toy = ref()\n\t// 方法\n\tfunction getToy(value:string){\n\t\ttoy.value = value\n\t}\n</script>\n```\n\n子组件\n\n```vue\n<template>\n  <div class=\"child\">\n    <h3>子组件</h3>\n\t\t<h4>我的玩具：{{ toy }}</h4>\n\t\t<h4>父给我的车：{{ car }}</h4>\n\t\t<button @click=\"getToy(toy)\">玩具给父亲</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\" name=\"Child\">\n\timport { ref } from \"vue\";\n\tconst toy = ref('奥特曼')\n\t\n\tdefineProps(['car','getToy'])\n</script>\n```\n\n## 6.2. 【自定义事件】\n\n1. 概述：自定义事件常用于：**子 => 父。**\n2. 注意区分好：原生事件、自定义事件。\n\n- 原生事件：\n  - 事件名是特定的（`click`、`mosueenter`等等）\t\n  - 事件对象`$event`: 是包含事件相关信息的对象（`pageX`、`pageY`、`target`、`keyCode`）\n- 自定义事件：\n  - 事件名是任意名称\n  - <strong style=\"color:red\">事件对象`$event`: 是调用`emit`时所提供的数据，可以是任意类型！！！</strong >\n\n3. 示例：\n\n   ```html\n   <!--在父组件中，给子组件绑定自定义事件：-->\n   <Child @send-toy=\"toy = $event\"/>\n   \n   <!--注意区分原生事件与自定义事件中的$event-->\n   <button @click=\"toy = $event\">测试</button>\n   ```\n\n   ```js\n   //子组件中，触发事件：\n   this.$emit('send-toy', 具体数据)\n   ```\n\n## 6.3. 【mitt】\n\n概述：与消息订阅与发布（`pubsub`）功能类似，可以实现任意组件间通信。\n\n安装`mitt`\n\n```shell\nnpm i mitt\n```\n\n新建文件：`src\\utils\\emitter.ts`\n\n```javascript\n// 引入mitt \nimport mitt from \"mitt\";\n\n// 创建emitter\nconst emitter = mitt()\n\n/*\n  // 绑定事件\n  emitter.on('abc',(value)=>{\n    console.log('abc事件被触发',value)\n  })\n  emitter.on('xyz',(value)=>{\n    console.log('xyz事件被触发',value)\n  })\n\n  setInterval(() => {\n    // 触发事件\n    emitter.emit('abc',666)\n    emitter.emit('xyz',777)\n  }, 1000);\n\n  setTimeout(() => {\n    // 清理事件\n    emitter.all.clear()\n  }, 3000); \n*/\n\n// 创建并暴露mitt\nexport default emitter\n```\n\n接收数据的组件中：绑定事件、同时在销毁前解绑事件：\n\n```typescript\nimport emitter from \"@/utils/emitter\";\nimport { onUnmounted } from \"vue\";\n\n// 绑定事件\nemitter.on('send-toy',(value)=>{\n  console.log('send-toy事件被触发',value)\n})\n\nonUnmounted(()=>{\n  // 解绑事件\n  emitter.off('send-toy')\n})\n```\n\n【第三步】：提供数据的组件，在合适的时候触发事件\n\n```javascript\nimport emitter from \"@/utils/emitter\";\n\nfunction sendToy(){\n  // 触发事件\n  emitter.emit('send-toy',toy.value)\n}\n```\n\n**注意这个重要的内置关系，总线依赖着这个内置关系**\n\n## 6.4.【v-model】\n\n1. 概述：实现 **父↔子** 之间相互通信。\n\n2. 前序知识 —— `v-model`的本质\n\n   ```vue\n   <!-- 使用v-model指令 -->\n   <input type=\"text\" v-model=\"userName\">\n   \n   <!-- v-model的本质是下面这行代码 -->\n   <input \n     type=\"text\" \n     :value=\"userName\" \n     @input=\"userName =(<HTMLInputElement>$event.target).value\"\n   >\n   ```\n\n3. 组件标签上的`v-model`的本质：`:moldeValue` ＋ `update:modelValue`事件。\n\n   ```vue\n   <!-- 组件标签上使用v-model指令 -->\n   <AtguiguInput v-model=\"userName\"/>\n   \n   <!-- 组件标签上v-model的本质 -->\n   <AtguiguInput :modelValue=\"userName\" @update:model-value=\"userName = $event\"/>\n   ```\n\n   `AtguiguInput`组件中：\n\n   ```vue\n   <template>\n     <div class=\"box\">\n       <!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 -->\n   \t\t<!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件-->\n       <input \n          type=\"text\" \n          :value=\"modelValue\" \n          @input=\"emit('update:model-value',$event.target.value)\"\n       >\n     </div>\n   </template>\n   \n   <script setup lang=\"ts\" name=\"AtguiguInput\">\n     // 接收props\n     defineProps(['modelValue'])\n     // 声明事件\n     const emit = defineEmits(['update:model-value'])\n   </script>\n   ```\n\n4. 也可以更换`value`，例如改成`abc`\n\n   ```vue\n   <!-- 也可以更换value，例如改成abc-->\n   <AtguiguInput v-model:abc=\"userName\"/>\n   \n   <!-- 上面代码的本质如下 -->\n   <AtguiguInput :abc=\"userName\" @update:abc=\"userName = $event\"/>\n   ```\n\n   `AtguiguInput`组件中：\n\n   ```vue\n   <template>\n     <div class=\"box\">\n       <input \n          type=\"text\" \n          :value=\"abc\" \n          @input=\"emit('update:abc',$event.target.value)\"\n       >\n     </div>\n   </template>\n   \n   <script setup lang=\"ts\" name=\"AtguiguInput\">\n     // 接收props\n     defineProps(['abc'])\n     // 声明事件\n     const emit = defineEmits(['update:abc'])\n   </script>\n   ```\n\n5. 如果`value`可以更换，那么就可以在组件标签上多次使用`v-model`\n\n   ```vue\n   <AtguiguInput v-model:abc=\"userName\" v-model:xyz=\"password\"/>\n   ```\n\n   \n\n\n## 6.5.【$attrs 】\n\n1. 概述：`$attrs`用于实现**当前组件的父组件**，向**当前组件的子组件**通信（**祖→孙**）。\n\n2. 具体说明：`$attrs`是一个对象，包含所有父组件传入的标签属性。\n\n   >  注意：`$attrs`会自动排除`props`中声明的属性(可以认为声明过的 `props` 被子组件自己“消费”了)\n\n父组件：\n\n```vue\n<template>\n  <div class=\"father\">\n    <h3>父组件</h3>\n\t\t<Child :a=\"a\" :b=\"b\" :c=\"c\" :d=\"d\" v-bind=\"{x:100,y:200}\" :updateA=\"updateA\"/>\n  </div>\n</template>\n\n<script setup lang=\"ts\" name=\"Father\">\n\timport Child from './Child.vue'\n\timport { ref } from \"vue\";\n\tlet a = ref(1)\n\tlet b = ref(2)\n\tlet c = ref(3)\n\tlet d = ref(4)\n\n\tfunction updateA(value){\n\t\ta.value = value\n\t}\n</script>\n```\n\n子组件：\n\n```vue\n<template>\n\t<div class=\"child\">\n\t\t<h3>子组件</h3>\n\t\t<GrandChild v-bind=\"$attrs\"/>\n\t</div>\n</template>\n\n<script setup lang=\"ts\" name=\"Child\">\n\timport GrandChild from './GrandChild.vue'\n</script>\n```\n\n孙组件：\n\n```vue\n<template>\n\t<div class=\"grand-child\">\n\t\t<h3>孙组件</h3>\n\t\t<h4>a：{{ a }}</h4>\n\t\t<h4>b：{{ b }}</h4>\n\t\t<h4>c：{{ c }}</h4>\n\t\t<h4>d：{{ d }}</h4>\n\t\t<h4>x：{{ x }}</h4>\n\t\t<h4>y：{{ y }}</h4>\n\t\t<button @click=\"updateA(666)\">点我更新A</button>\n\t</div>\n</template>\n\n<script setup lang=\"ts\" name=\"GrandChild\">\n\tdefineProps(['a','b','c','d','x','y','updateA'])\n</script>\n```\n\n## 6.6. 【$refs、$parent】\n\n1. 概述：\n\n   * `$refs`用于 ：**父→子。**\n   * `$parent`用于：**子→父。**\n\n2. 原理如下：\n\n   | 属性      | 说明                                                     |\n   | --------- | -------------------------------------------------------- |\n   | `$refs`   | 值为对象，包含所有被`ref`属性标识的`DOM`元素或组件实例。 |\n   | `$parent` | 值为对象，当前组件的父组件实例对象。                     |\n\n## 6.7. 【provide、inject】\n\n1. 概述：实现**祖孙组件**直接通信\n\n2. 具体使用：\n\n   * 在祖先组件中通过`provide`配置向后代组件提供数据\n   * 在后代组件中通过`inject`配置来声明接收数据\n\n4. 具体编码：\n\n   【第一步】父组件中，使用`provide`提供数据\n\n   ```vue\n   <template>\n     <div class=\"father\">\n       <h3>父组件</h3>\n       <h4>资产：{{ money }}</h4>\n       <h4>汽车：{{ car }}</h4>\n       <button @click=\"money += 1\">资产+1</button>\n       <button @click=\"car.price += 1\">汽车价格+1</button>\n       <Child/>\n     </div>\n   </template>\n   \n   <script setup lang=\"ts\" name=\"Father\">\n     import Child from './Child.vue'\n     import { ref,reactive,provide } from \"vue\";\n     // 数据\n     let money = ref(100)\n     let car = reactive({\n       brand:'奔驰',\n       price:100\n     })\n     // 用于更新money的方法\n     function updateMoney(value:number){\n       money.value += value\n     }\n     // 提供数据\n     provide('moneyContext',{money,updateMoney})\n     provide('car',car)\n   </script>\n   ```\n   \n   > 注意：子组件中不用编写任何东西，是不受到任何打扰的\n   \n   【第二步】孙组件中使用`inject`配置项接受数据。\n   \n   ```vue\n   <template>\n     <div class=\"grand-child\">\n       <h3>我是孙组件</h3>\n       <h4>资产：{{ money }}</h4>\n       <h4>汽车：{{ car }}</h4>\n       <button @click=\"updateMoney(6)\">点我</button>\n     </div>\n   </template>\n   \n   <script setup lang=\"ts\" name=\"GrandChild\">\n     import { inject } from 'vue';\n     // 注入数据\n    let {money,updateMoney} = inject('moneyContext',{money:0,updateMoney:(x:number)=>{}})\n     let car = inject('car')\n   </script>\n   ```\n\n\n## 6.8. 【pinia】\n\n参考之前`pinia`部分的讲解\n\n## 6.9. 【slot】\n\n### 1. 默认插槽\n\n![[前端了解/vue/_resources/Vue3快速上手/b23349c818acb70a1969d7300ae27368_MD5.png]]\n\n```vue\n父组件中：\n        <Category title=\"今日热门游戏\">\n          <ul>\n            <li v-for=\"g in games\" :key=\"g.id\">{{ g.name }}</li>\n          </ul>\n        </Category>\n子组件中：\n        <template>\n          <div class=\"item\">\n            <h3>{{ title }}</h3>\n            <!-- 默认插槽 -->\n            <slot></slot>\n          </div>\n        </template>\n```\n\n### 2. 具名插槽\n\n```vue\n父组件中：\n        <Category title=\"今日热门游戏\">\n          <template v-slot:s1>\n            <ul>\n              <li v-for=\"g in games\" :key=\"g.id\">{{ g.name }}</li>\n            </ul>\n          </template>\n          <template #s2>\n            <a href=\"\">更多</a>\n          </template>\n        </Category>\n子组件中：\n        <template>\n          <div class=\"item\">\n            <h3>{{ title }}</h3>\n            <slot name=\"s1\"></slot>\n            <slot name=\"s2\"></slot>\n          </div>\n        </template>\n```\n\n### 3. 作用域插槽 \n\n1. 理解：<span style=\"color:red\">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（新闻数据在`News`组件中，但使用数据所遍历出来的结构由`App`组件决定）\n\n3. 具体编码：\n\n   ```vue\n   父组件中：\n         <Game v-slot=\"params\">\n         <!-- <Game v-slot:default=\"params\"> -->\n         <!-- <Game #default=\"params\"> -->\n           <ul>\n             <li v-for=\"g in params.games\" :key=\"g.id\">{{ g.name }}</li>\n           </ul>\n         </Game>\n   \n   子组件中：\n         <template>\n           <div class=\"category\">\n             <h2>今日游戏榜单</h2>\n             <slot :games=\"games\" a=\"哈哈\"></slot>\n           </div>\n         </template>\n   \n         <script setup lang=\"ts\" name=\"Category\">\n           import {reactive} from 'vue'\n           let games = reactive([\n             {id:'asgdytsa01',name:'英雄联盟'},\n             {id:'asgdytsa02',name:'王者荣耀'},\n             {id:'asgdytsa03',name:'红色警戒'},\n             {id:'asgdytsa04',name:'斗罗大陆'}\n           ])\n         </script>\n   ```\n\n\n\n# 7. 其它 API\n\n## 7.1.【shallowRef 与 shallowReactive 】\n\n### `shallowRef`\n\n1. 作用：创建一个响应式数据，但只对顶层属性进行响应式处理。\n\n2. 用法：\n\n   ```js\n   let myVar = shallowRef(initialValue);\n   ```\n\n3. 特点：只跟踪引用值的变化，不关心值内部的属性变化。\n\n### `shallowReactive`\n\n1. 作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的\n\n2. 用法：\n\n   ```js\n   const myObj = shallowReactive({ ... });\n   ```\n\n3. 特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。\n\n### 总结\n\n> 通过使用 [`shallowRef()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref) 和 [`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) 来绕开深度响应。浅层式 `API` 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。\n\n\n\n## 7.2.【readonly 与 shallowReadonly】\n\n### **`readonly`**\n\n1. 作用：用于创建一个对象的深只读副本。\n\n2. 用法：\n\n   ```js\n   const original = reactive({ ... });\n   const readOnlyCopy = readonly(original);\n   ```\n\n3. 特点：\n\n   * 对象的所有嵌套属性都将变为只读。\n   * 任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。\n\n4. 应用场景：\n   * 创建不可变的状态快照。\n   * 保护全局状态或配置不被修改。\n\n### **`shallowReadonly`**\n\n1. 作用：与 `readonly` 类似，但只作用于对象的顶层属性。\n\n2. 用法：\n\n   ```js\n   const original = reactive({ ... });\n   const shallowReadOnlyCopy = shallowReadonly(original);\n   ```\n\n3. 特点：\n\n   * 只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。\n\n   * 适用于只需保护对象顶层属性的场景。\n\n     \n\n## 7.3.【toRaw 与 markRaw】\n\n### `toRaw`\n \n1. 作用：用于获取一个响应式对象的原始对象， `toRaw` 返回的对象不再是响应式的，不会触发视图更新。\n\n   > 官网描述：这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。\n\n   > 何时使用？ —— 在需要将响应式对象传递给非 `Vue` 的库或外部系统时，使用 `toRaw` 可以确保它们收到的是普通对象\n\n2. 具体编码：\n\n   ```js\n   import { reactive,toRaw,markRaw,isReactive } from \"vue\";\n   \n   /* toRaw */\n   // 响应式对象\n   let person = reactive({name:'tony',age:18})\n   // 原始对象\n   let rawPerson = toRaw(person)\n   \n   \n   /* markRaw */\n   let citysd = markRaw([\n     {id:'asdda01',name:'北京'},\n     {id:'asdda02',name:'上海'},\n     {id:'asdda03',name:'天津'},\n     {id:'asdda04',name:'重庆'}\n   ])\n   // 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了\n   let citys2 = reactive(citys)\n   console.log(isReactive(person))\n   console.log(isReactive(rawPerson))\n   console.log(isReactive(citys))\n   console.log(isReactive(citys2))\n   ```\n\n### `markRaw`\n\n1. 作用：标记一个对象，使其**永远不会**变成响应式的。\n\n   > 例如使用`mockjs`时，为了防止误把`mockjs`变为响应式对象，可以使用 `markRaw` 去标记`mockjs`\n\n2. 编码：\n\n   ```js\n   /* markRaw */\n   let citys = markRaw([\n     {id:'asdda01',name:'北京'},\n     {id:'asdda02',name:'上海'},\n     {id:'asdda03',name:'天津'},\n     {id:'asdda04',name:'重庆'}\n   ])\n   // 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了\n   let citys2 = reactive(citys)\n   ```\n\n## 7.4.【customRef】\n\n作用：创建一个自定义的`ref`，并对其依赖项跟踪和更新触发进行逻辑控制。\n\n实现防抖效果（`useSumRef.ts`）：\n\n```typescript\nimport {customRef } from \"vue\";\n\nexport default function(initValue:string,delay:number){\n  let msg = customRef((track,trigger)=>{\n    let timer:number\n    return {\n      get(){\n        track() // 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新\n        return initValue\n      },\n      set(value){\n        clearTimeout(timer)\n        timer = setTimeout(() => {\n          initValue = value\n          trigger() //通知Vue数据msg变化了\n        }, delay);\n      }\n    }\n  }) \n  return {msg}\n}\n```\n\n组件中使用：\n\n\n\n\n\n# 8. Vue3新组件\n\n## 8.1. 【Teleport】\n\n- 什么是Teleport？—— Teleport 是一种能够将我们的**组件html结构**移动到指定位置的技术。\n\n```html\n<teleport to='body' >\n    <div class=\"modal\" v-show=\"isShow\">\n      <h2>我是一个弹窗</h2>\n      <p>我是弹窗中的一些内容</p>\n      <button @click=\"isShow = false\">关闭弹窗</button>\n    </div>\n</teleport>\n```\n\n## 8.2. 【Suspense】\n\n-  等待异步组件时渲染一些额外内容，让应用有更好的用户体验 \n-  使用步骤： \n   -  异步引入组件\n   -  使用`Suspense`包裹组件，并配置好`default` 与 `fallback`\n\n```tsx\nimport { defineAsyncComponent,Suspense } from \"vue\";\nconst Child = defineAsyncComponent(()=>import('./Child.vue'))\n```\n\n```vue\n<template>\n    <div class=\"app\">\n        <h3>我是App组件</h3>\n        <Suspense>\n          <template v-slot:default>\n            <Child/>\n          </template>\n          <template v-slot:fallback>\n            <h3>加载中.......</h3>\n          </template>\n        </Suspense>\n    </div>\n</template>\n```\n\n\n\n## 8.3.【全局API转移到应用对象】\n\n- `app.component`\n- `app.config`\n- `app.directive`\n- `app.mount`\n- `app.unmount`\n- `app.use`\n\n## 8.4.【其他】\n\n- 过渡类名 `v-enter` 修改为 `v-enter-from`、过渡类名 `v-leave` 修改为 `v-leave-from`。\n\n\n- `keyCode` 作为 `v-on` 修饰符的支持。\n\n- `v-model` 指令在组件上的使用已经被重新设计，替换掉了 `v-bind.sync。`\n\n- `v-if` 和 `v-for` 在同一个元素身上使用时的优先级发生了变化。\n\n- 移除了`$on`、`$off` 和 `$once` 实例方法。\n\n- 移除了过滤器 `filter`。\n\n- 移除了`$children` 实例 `propert`。\n\n  ......\n","tags":["Vue"],"categories":["前端开发"]},{"title":"Vue3","url":"/posts/2025/07/Fronted/Vue/pinia源码/a42dfghf.html","content":"\n<a href=\"https://juejin.cn/post/7225038708965818426?searchId=202508302153197F4A9372EB6EFDF1229D\">参考资料</a>\n<a href=\"https://juejin.cn/post/7078281612013764616\">pinia的使用(原链接)</a>\nPinia支持compositionApi同时也兼容optionsApi(this指向)\nPinia可以采用多个store,store之间可以互相调用（扁平化），不用担心命名冲突问题\n\n# Pinia基本使用\n\n组合式 与 选项式 写法\n```\nimport {defineStore} from '../pinia/store'\nimport {ref, computed} from 'vue'\nexport const useCounterStore = defineStore('counter', ()=>{\n    const count = ref(0)\n\n    const double = computed(()=>{\n        return count.value * 2\n    })\n\n    const increment = (num)=>{\n        count.value += num\n        console.log(todosStore.todos)\n    }\n\n    return {\n        count,\n        double,\n        increment\n    }\n})\n// export const useCounterStore = defineStore('counter', {\n//     state: () => {\n//         return {count: 0}\n//     },\n//     getters: {\n//         double() {\n//             return this.count * 2\n//         }\n//     },\n//     actions: {\n//         increment(num) {\n//             this.count += num\n//         }\n//     }\n// })\n\n```\n## Pinia实现原理\n\npinia中的最近数据存储在state中\n`_s` 记录了state的各个时态, 存放各个时期的state, 有利于重复使用\n\n### 创建原理\n```\nimport { PiniaSymbol } from \"./rootStore\"\nimport {ref} from 'vue'\n\nexport function createPinia () {\n    \n    const state = ref({})\n    const pinia = {\n        install(app) {\n            app.config.globalProperties.$pinia = pinia //更新\n            app.provide(PiniaSymbol, pinia)\n        },\n        state,\n        _s:new Map(),\n    }\n    return pinia\n}\n```\n\n### 存储原理\n其中参数含义如下：\n\n- `id`：store 的 id，必须唯一。\n    \n- `options`： 与 Vue 的选项式 API 类似，我们也可以传入一个带有 `id`、 `state`、`actions`与 `getters`属性的 Option 对象。\n    \n- `storeSetup`：以 `setup` 的方式创建，与 Vue 的 **setup 函数** 相似。在 storeSetup 中：\n    \n    - `ref()` 等同于 `state`。\n    - `computed()` 等同于 `getters`。\n    - `function()` 等同于 `actions`\n\n\n`getCurrentInstance` 是 Vue 3 Composition API 中的一个函数，用于获取当前组件实例的内部对象\n\n在调用useStore时, 首先会在`_s`中寻找所求值是否存在, 如果存在则直接赋值, 不存在则再创建一个新的值\n\n```\n\nexport function defineStore(idOrOptions, setup) {\n    let id\n    let options\n\n    //判断是组合式还是选项式\n    const isSetupStore = typeof setup === 'function'\n\n    if(typeof idOrOptions == 'string') {\n        id = idOrOptions\n        options = setup\n    } else { //不是字符串, 说明传入了对象\n        options = idOrOptions\n        id = idOrOptions.id\n    }\n    \n    function useStore() {\n        const currentInstance = getCurrentInstance()\n        const pinia = currentInstance && inject(PiniaSymbol)\n        \n        if (!pinia._s.has(id)) { //这个store时第一次使用\n            \n            if(isSetupStore){\n                createSetupStore(id, setup, pinia)\n                //创建组合式store\n            } else {\n                createOptionStore(id, options, pinia)\n                //创建后的store只需要存到_s中即可\n            }\n        }\n        //如果已经有了store, 不用创建, 直接拿到store就行了\n        const store = pinia._s.get(id)\n\n        return store\n    }\n    return useStore\n}\n```\n\n### 组合式\n\n**this指向**\n当传入的值中含有方法对象时, 直接处理会改变对象的this指向, 这时候需要进行特殊处理\n保证传入的类的this指向不改变\n通过wrapAction函数显示转换他们的this指向\n\n将处理好的值与旧值进行更新 (`Object.assign`)\n加入到`_s`中, 在二次调用时减少计算\n```\n//setupStore 用户已经提供了完整的setup方法了, 我们只需执行setup函数即可,\n//通过这个返回值, 将其放在store上即可\n\nfunction createSetupStore(id, setup, pinia) {\n    const store = reactive({})\n\n        //处理this指向\n    function wrapAction (action) {\n        return function () {\n            //将action中的this永远处理成store, 保证this指向正确\n            return action.call(store, ...arguments)\n        }\n    }\n\n    const setupStore = setup()\n    //拿到的setupStore可能没有处理this指向\n\n    //处理this\n    for (let prop in setupStore) {\n        const value = setupStore[prop]\n        if (typeof value === 'function') {\n            setupStore[prop] = wrapAction(value)\n        }\n    }\n    Object.assign(store, setupStore)//加入到队伍里面\n    \n    pinia._s.set(id, store)\n    return store \n}\n```\n\n### 选项式\n\n相比与组合式, 选项式多了一个setup()函数\n\n在此过程中，state 的内容也会被存储到 `pinia.state` 中。action 则会被 `wrapAction` 处理\n\n每一项 action 进行处理，目的是为了支持 `$onAction` 方法，此方法会在执行 action 时执行回调函数，回调函数可以接收三个参数分别是：**被调用的 store**、**action 的名字**、**传递给 action 的参数**。\n\ngetters处理时, 需将他的逻辑执行完后,得到的值存入store\n```\nfunction createOptionStore(id, options, pinia) {\n    const {state, actions, getters={}} = options //store里面的数据, 已定义\n\n    const store = reactive({}) //pinia就是创建了一个响应式对象而已\n    //需要将这个api转换成组合式\n    function setup() {\n        pinia.state.value[id] = state ? state() : {}\n\n        let localState = toRefs(pinia.state.value[id])\n\n        return Object.assign(\n            localState,\n            actions,\n            Object.keys(getters).reduce((computeds, getterKey)=>{\n                computeds[getterKey] = computed(()=>{\n                    return getters[getterKey].call(store)\n                })\n                return computeds\n            }, {})\n        )\n    }\n    //减少代码的重复书写, 此时选项式store已经将数据处理, 剩下的逻辑和处理组合式一致\n    createSetupStore(id, setup, pinia)\n    return store \n}\n```\n\n## store中的基础api实现\n\n**定义**\n```\n    const actionSubscriptions = [] //所有订阅的actions时间, 都应该放在这个数组中\n    const partialStore = {\n        $patch,\n        //订阅状态\n        $subscribe(callback) {\n            watch(pinia.state.value[id], state => {\n                callback({id}, state)\n            })\n        },\n\n        //订阅用户的action操作\n        $onAction: addSubscription.bind(null, actionSubscriptions), //订阅\n   }\n    //pinia就是创建了一个响应式对象而已\n    const store = reactive(partialStore)\n```\n### patch\n将一个 state 补丁应用于当前状态。允许传递嵌套值。\n\n`$patch` 允许两种参数传递方式，传入一个函数，或一个 state 的补丁。\n\n```\n    //这里需要获取原来的所有状态\n\n    function $patch(partialStateOrMutator) {\n\n        //partialStateOrMutator部分状态\n\n        if(typeof partialStateOrMutator !== 'function') {\n\n            //当前store中的全部状态, pinia.state.value[i]\n\n            merge(pinia.state.value[id], partialStateOrMutator)\n\n        } else {\n\n            partialStateOrMutator(pinia.state.value[id])\n\n        }\n\n    }\n        function merge(target, partialState) {\n\n        for (const key in partialState) {\n\n            if(!partialState.hasOwnProperty(key)) continue\n\n            //原始的值\n\n            const targetValue = target[key]\n\n            //后来的值\n\n            const subPatch = partialState[key]\n\n            if (isObject(targetValue) && isObject(subPatch) && !isRef(subPatch)) { //ref也是对象\n\n                target[key] = merge(targetValue, subPatch)\n\n            } else {\n\n                //如果不需要合并直接用新的覆盖掉老的即可\n\n                target[key] = subPatch\n            }\n        }\n    }\n     if(isSetupStore) {\n        pinia.state.value[id] = {}\n        //用于存放setupStore中的状态\n    }\n```\n\n### reset\n\n**功能**: 通过建立一个新的状态对象，将 store 重设为初始状态。\n\n重置方法只能在optionStore中书写\n因为在setupStore中, 用户自己控制状态; \n\n - state: () => ({count: 1}) 是一个函数，只要重新调用就可以获取原始值，\n  - 而 组合式 构建的话 state 以 ref() 的形式实现，无法获取原始值。\n\n```\n    store.$reset = function() { //这个方法只支持optionAPI, 因为setupAPI中, 用户自己控制状态\n\n        const newState = state ? state() : {}\n\n        this.$patch(newState)\n\n    }\n```\n\n### subscribe\n设置一个回调，当状态发生变化时被调用。它会返回一个用来移除此回调的函数。 请注意，当在组件内调用 `store.$subscribe()` 时，除非 `detached` 被设置为 true， 否则当组件被卸载时，它将被自动清理掉。\n\n在store中的实现\n```\n        //订阅状态\n\n        $subscribe(callback) {\n\n            watch(pinia.state.value[id], state => {\n\n                callback({id}, state)\n\n            })\n\n        },\n```\n\n### onAction\n设置一个回调，当一个 action 即将被调用时，就会被调用。 回调接收一个对象， 其包含被调用 action 的所有相关信息：\n\n- `store`: 被调用的 store\n- `name`: action 的名称\n- `args`: 传递给 action 的参数\n\n除此之外，它会接收两个函数， 允许在 action 完成或失败时执行的回调。\n\n它还会返回一个用来删除回调的函数。 请注意，当在组件内调用 `store.$onAction()` 时，除非 `detached` 被设置为 true， 否则当组件被卸载时，它将被自动清理掉。\n\n调用方法\n```\nexport function addSubscription(subscriptions, callback) {\n\n    subscriptions.push(callback)//将回调函数放在数组中\n\n  \n\n    const removeSubscription = () => {\n\n       const idx = subscriptions.indexOf(callback)\n\n       if(idx > -1) {\n\n        subscriptions.splice(idx, 1)\n\n       }\n\n    }\n\n    return removeSubscription\n\n}\n\n  \n\nexport function triggerSubscriptions(subscriptions, ...args) {\n\n    subscriptions.slice().forEach(cb=>cb(...args))\n\n}\n```\n\n定义\n```\nconst actionSubscriptions = [] //所有订阅的actions时间, 都应该放在这个数组中\n\nconst partialStore = {\n\t...\n        //订阅用户的action操作\n\n        $onAction: addSubscription.bind(null, actionSubscriptions),\n\n   }\n```\n实现\n```\n\n  //处理this指向\n\n    function wrapAction (action) {\n\n        return function () {\n\n            const afterCallbacks = []\n\n            const onErrorCallbacks = []\n\n            const after = (callback) => {\n\n                afterCallbacks.push(callback)\n\n            }\n\n            const onError = (callback) => {\n\n                onErrorCallbacks.push(callback)\n\n            }\n\n            triggerSubscriptions(actionSubscriptions, {after, onError}) //让用户传递after和error\n\n            //将action中的this永远处理成store, 保证this指向正确\n\n  \n\n            //回调的方式\n\n            let result\n\n            try {//正常action是一个回调的情况, 可以直接拿到返回值出发after回调\n\n            result =  action.call(store, ...arguments)\n\n            triggerSubscriptions(afterCallbacks, result)\n\n            } catch (e){\n\n                triggerSubscriptions(onErrorCallbacks, e)\n\n            }\n\n            //如果返回值是一个Promise, 针对场景做处理  \n\n            if(result instanceof Promise) {\n\n                return result.then(value => {\n\n                    triggerSubscriptions(afterCallbacks, value)\n\n                }).catch(error => {\n\n                    triggerSubscriptions(onErrorCallbacks, error)\n\n                })\n            }  \n\n            return result\n        }\n    }\n```\n\n## pinia插件写法\n\nmain.js中\n\n```\nconst pinia = createPinia()\n\nfunction persitisPlugin() { //为了用户传递参数, 所以用函数\n\n    return ({store, id}) => { //所有的store都会执行此方法 \n\n        let oldState = JSON.parse(localStorage.getItem(id) || '{}')\n\n        store.$state = oldState\n\n        // store.$patch(oldState) //将老状态进行替换\n\n        store.$subscribe((mutation, state) => {\n\n            localStorage.setItem(id, JSON.stringify(state))\n\n        })\n    }\n}\n\npinia.use(persitisPlugin()) \n\n//use API可以去调用插件的install方法，将app注入进来\n\napp.use(pinia) //使用pinia插件\n```\n\n\ncreateStore中\n```\nimport { PiniaSymbol } from \"./rootStore\"\n\nimport {ref} from 'vue'\n\nexport function createPinia () {\n\n    //pinia是管理多个state状态的\n\n    const state = ref({})\n\n    const _p = [] //插件\n\n    const pinia = {\n\n        install(app) {\n\n            app.config.globalProperties.$pinia = pinia\n\n            app.provide(PiniaSymbol, pinia)\n\n        },\n\n        use(plugin) {\n\n            _p.push(plugin)\n\n            return pinia\n        },\n\n        state,\n\n        _s:new Map(),\n\n        _p\n    }\n    return pinia\n}\n```\n# 总结\n<a href=\"https://github.com/nihaokkjj\">仓库链接</a>\n这里附上整个源码\n\n","tags":["pinia"],"categories":["前端开发"]},{"title":"node","url":"/posts/2025/06/Fronted/node/857fe845.html","content":"# Node定义\n`Node.js`是一个基于 `V8 JavaScript` 引擎的`JavaScript`运行时的环境\n\n`Node` 程序是使用 `c++/ c/ js` 语言编写的\n[[前端了解/Node/_resources/node/e49f63c48826b59143b4b3366c92cf75_MD5.jpeg|Open: Pasted image 20250522151116.png]]\n![[前端了解/Node/_resources/node/e49f63c48826b59143b4b3366c92cf75_MD5.jpeg]]\n\n# 应用场景\n\n一: *目前前端开发的库都是以node包的形式进行管理\n\n二: *npm、yarn、pnpm工具成为前端开发使用最多的工具；\n\n三: 越来越多的公司使用Node.js作为web服务器开发、中间件、代理服务器；\n\n四, 大量项目需要借助Node.js完成前后端渲染的同构应用\n\n五, 资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用JavaScript,而不是Python或者shel)\n\n六, 很多企业在使用Electron来开发桌面应用程序； \n\n\n### 管理node的工具\n\n# Node 程序传递参数\n\n- 正常情况下执行一个node程序，直接跟上我们对应的文件即可：\n`node index.js`\n\n- 在某些情况下执行node程序的过程中，我们可能希望给node传递一些参数：\n`node index.js env=development coderwhy`\n\n- *在程序中获取到传递的参数：\n    + 获取参数其实是在`process`*的内置对象*中的；\n    + 如果我们*直接打印这个内置对象*，它里面包含特别的信息：\n\t\t√其他的一些信息，比如版本、操作系统等可以自行查看\n\n### Node 的输出\n[[前端了解/Node/_resources/node/31f26b1a8f5f31430c83ade96744ad0b_MD5.jpeg|Open: Pasted image 20250528223104.png]]\n![[前端了解/Node/_resources/node/31f26b1a8f5f31430c83ade96744ad0b_MD5.jpeg]]\n\n## Node 的 REPL\n\nREPL是 `Read-Eval-Print Loop` 的简称，翻译为“`读取-求值-输出`”\n循环；\n\nREPL是一个 *简单的, 交互式的编程环境*\n\n**方法**\n- 在终端中直接输入node\n- 在控制台中直接使用\n\n[[前端了解/Node/_resources/node/9f0b8de46e04486b4b72bf793ce3f9ce_MD5.jpeg|Open: Pasted image 20250530103657.png]]\n![[前端了解/Node/_resources/node/9f0b8de46e04486b4b72bf793ce3f9ce_MD5.jpeg]]\n\n# Node 的全局对象\n\n## 常见的全局对象\n\n[[前端了解/Node/_resources/node/f96f2a2c114478a8e54fb92e91463952_MD5.jpeg|Open: Pasted image 20250530105737.png]]\n![[前端了解/Node/_resources/node/f96f2a2c114478a8e54fb92e91463952_MD5.jpeg]]\n\n[[前端了解/Node/_resources/node/2872b99e65ce425d36b0ff9342c0c39a_MD5.jpeg|Open: Pasted image 20250530121231.png]]\n![[前端了解/Node/_resources/node/2872b99e65ce425d36b0ff9342c0c39a_MD5.jpeg]]\n\n**global是一个全局对象** ，`process、.console、setTimeouts`等都有被放到globalr中;\n- 新的标准中还有一个globalThis,也是指向全局对象的；\n- 类似于浏览器中的window; \n## 特殊的全局对象\n\n- 这些全局对象是实际上是***模块中的变量***, 只是*每个模块都有*, 看起来*像是全局变量\n- 在命令行交互中式不可以使用的\n- 包括: `__dirname, __filename, export, module, require() `\n\n`__dirname` : 获取*当前文件所在的路径* ( 不包括后面的文件名)\n`__filename` : 获取*当前文件所在的路径和文件名* ( 包括后面的文件名)\n\n## global 和window 的区别\n\n- *在浏览器中，全局变量都是在window上的*，比如有`document、setInterval、setTimeout、alert、console`等等\n- 在Node中，我们也有一个`global`属性，并且看起来它里面有很多其他对象。\n- 在浏览器中执行的 `JavaScript` 代码，如果我们在顶级范围内通过`var`定义的一个属性，默认会被添加到`window`对象上;\n- 在node中，我们*通过var定义一个变量， 它只是在当前模块中有一个变量，不会放到全局中;*\n\n# 模块化\n\n**目的** : 模块化开发最终的目的是将程序划分成*一个个小的结构*；\n\n**用法** : \n- 这个结构中*编写属于自己的逻辑代码*，有*自己的作用域*，定义变量名词时不会影响到其他的结构；\n- 这个结构可以将自己希望暴露的`变量、函数、对象`等导出给其结构使用；\n- 也可以通过某种方式，*导入*另外结构中的`变量、函数、对象`等； \n\n***按照这种结构划分开发程序的过程, 就是模块化开发的过程***\n\n## CommonJS规范\n*Node中的每一个 js 文件都是一个单独的模块*\n\n模块中要导出的内容 : `exports`\n模块中要导入内容 : `require`\n\n[[前端了解/Node/_resources/node/aa2e22478987faaf12d5d70fd7bec0d4_MD5.jpeg|Open: Pasted image 20250530132649.png]]\n![[前端了解/Node/_resources/node/aa2e22478987faaf12d5d70fd7bec0d4_MD5.jpeg]]\n\n[[前端了解/Node/_resources/node/d68f7830be2871a364727e1ff645d1b6_MD5.jpeg|Open: Pasted image 20250530132724.png]]\n![[前端了解/Node/_resources/node/d68f7830be2871a364727e1ff645d1b6_MD5.jpeg]]\n\n`util`变量等于`exports` 对象\n\n### require的实现本质\n\n[[前端了解/Node/_resources/node/a07269c198ed7949679906a92589cbb0_MD5.jpeg|Open: Pasted image 20250530145951.png]]\n![[前端了解/Node/_resources/node/a07269c198ed7949679906a92589cbb0_MD5.jpeg]]\n\n[[前端了解/Node/_resources/node/3271cf9d64e405d16db2c3f0bb625090_MD5.jpeg|Open: Pasted image 20250530150003.png]]\n![[前端了解/Node/_resources/node/3271cf9d64e405d16db2c3f0bb625090_MD5.jpeg]]\n<!--修改后, exports.name 的值也会改变, require 相当于引用赋值-->\nbar变量就是exports对象\n\n### module的exports属性本质\n\n[[前端了解/Node/_resources/node/354b7e2f4ebe5454f0f1c9a492d46036_MD5.jpeg|Open: Pasted image 20250530154627.png]]\n![[前端了解/Node/_resources/node/354b7e2f4ebe5454f0f1c9a492d46036_MD5.jpeg]]\n\n[[前端了解/Node/_resources/node/af508f1943b037e013561029247060db_MD5.jpeg|Open: Pasted image 20250530155343.png]]\n![[前端了解/Node/_resources/node/af508f1943b037e013561029247060db_MD5.jpeg]]\nexports可以导出的原因\n- **module对象的exports属性是exports对象的一个引用\n- `module.exports = exports = main中的bar; \n\n### require 查找模块细节\n\n`require`是一个函数, 可以引入一个文件(模块)中导出的对象\n\n书写规则`require(X)`\n#### require 的查找规则\n在nodejs中我们通过require(X),可以引入一个模块中导出的对象。\n\n那么，require的查找规则是怎么样的呢？\n\n导入格式require(X)，下面总结几个常见的查找规则：\n\n##### 情况一：X是一个NodeJs核心模块，比如path、http等\n\n直接返回核心模块，并且停止查找。\n\n##### 情况二：X是以./ 或 ../ 或 (根目录) 开头的\n\n第一步：将X当做一个文件在对应的目录下查找；\n\n1. 如果有后缀名，直接按照后缀名的格式查找对应的文件\n    \n2. 如果没有后缀名，会按照如下的顺序：\n    \n    1. 直接查找文件X\n    2. 查找X.js文件\n    3. 查找X.json文件\n    4. 查找X.node文件\n\n第二步：没有对应的文件，将X看作一个目录\n\n1. 查找目录下面的index文件\n    \n    1. 查找X/index.js文件\n    2. 查找X/index.json文件\n    3. 查找X/index.node文件\n\n如果还没有找到，那么就报错：not found\n\n##### 情况三：X没有路径，也不是一个核心模块\n\n从node_modules目录查找\n\nNodeJs从当前模块的目录开始，并添加/node_modules，并尝试从该位置加载模块\n\n例如，如果在\"/home/ry/projects/foo.js\"中调用 require(X),则将以下顺序查找：\n\n- /home/ry/projects/node_mudules\n- /home/ry/node_modules\n- /home/node_modules\n- /node_modules\n\n以上目录找不到，那么就报错：not found\n\n### 模块的加载过程\n\n1. *模块在被第一次引入时, 模块中的 JS 代码会被运行一次*\n\n2. *模块被多次引入时, 回缓存, 最终只加载(运行)一次*\n- 每个模块对象`module` 都有一个属性 : `loaded`\n- 为`false` 表示还没有加载, 为`true` 表示已经加载\n\n#### 循环引入\n\n[[前端了解/Node/_resources/node/5379489ed74605db6eee3fdf4f43edd2_MD5.jpeg|Open: Pasted image 20250530212957.png]]\n![[前端了解/Node/_resources/node/5379489ed74605db6eee3fdf4f43edd2_MD5.jpeg]]\n采用深度优先算法 `main -> aaa -> ccc -> ddd -> eee -> bbb`\n\n### CommonJS会规范缺点\n\n**CommonJS加载模块是同步的**：\n- 同步 意味着*只有等到对应的模块加载完毕*，*当前模块中的内容才能被运行*\n- 这个在服务器不会有什么问题，因为*服务器加载的s文件都是本地文件*，加载速度非常快：\n\n应用于浏览器时: \n- 浏览器*加载 `js` 文件需要先从服务器将文件下载下来，之后再加载运行*；\n- 那么 *采用同步的就意味着后续的S代码都无法正常运行，即使是一些简单的DOM操作； \n\n### AMD, CMD\n\n[[前端了解/Node/_resources/node/3487517d1ebbbc0423bf235834f1a70a_MD5.jpeg|Open: Pasted image 20250530221305.png]]\n![[前端了解/Node/_resources/node/3487517d1ebbbc0423bf235834f1a70a_MD5.jpeg]]\n[[前端了解/Node/_resources/node/b54379def73193201d802b0313f7f5bd_MD5.jpeg|Open: Pasted image 20250530221657.png]]\n![[前端了解/Node/_resources/node/b54379def73193201d802b0313f7f5bd_MD5.jpeg]]\n## ES Module\n\n**采用 `ES Module ` 将自动采用严格模式** \n\n*不允许在逻辑代码中写 `import` 导入语法 , 只能写在 `js` 代码顶\n层*\n#### 导入和导出方式\n\n##### 一\n```\nconst name = \"why\"\nconst age = 18\n export {\n     name,\n     age\n } //不是一个对象, 只是一种特殊的语法\n \nimport {age, fname, sayHello} from\"./foo.js\" //导入\n```\n\n##### 二\n导出 /导出 时给标识符起一个别名\n\n```\nexport {\n    name as fname,\n    age,\n    sayHello\n}\nimport {age as fage, fname, sayHello} from \"./foo.js\" //导入\n```\n\n##### 三\n定义时导出\n\n```\nexport const name = \"why\"\nexport const age = 18\n  \nexport function sayHello() {\n    console.log(\"sayhello\")\n}\n```\n\n##### 导入时给整个模块起别名\n\n```js\nimport * as foo from \"./foo.js\"\n\nconst name = \"kk\"\n\nconsole.log(name)\nconsole.log(foo.name)\nfoo.sayHello()\n```\n\n#####  优化写法\n*规范* : 可以先把要用到的模块放在一个 `js` 文件里面, 其他`js`再从这个文件引入\n\n###### 一\n```\nexport { format, formatData } from \"./format.js\"\n```\n\n###### 二\n把所有的变量导入进来\n\n```\nexport * from \"./format.js\"\n```\n\n##### default用法\n\n- 默认导出 `export` 时可以不需要指定名字；\n- 在导入时不需要使用 `{ }`，并且可以自己来指定名字；\n- 它也方便我们和现有的 `CommonJS`  等规范相互操作；\n\n**导出**\n[[前端了解/Node/_resources/node/57fd5241907251dd268484ec9850f5cb_MD5.jpeg|Open: Pasted image 20250601201850.png]]\n![[前端了解/Node/_resources/node/57fd5241907251dd268484ec9850f5cb_MD5.jpeg]]\n或者\n[[前端了解/Node/_resources/node/937d0952c1f4cdc75bba4c0b510f1982_MD5.jpeg|Open: Pasted image 20250601201925.png]]\n![[前端了解/Node/_resources/node/937d0952c1f4cdc75bba4c0b510f1982_MD5.jpeg]]\n***注意*** : *一个模块里面只能有一个默认导出( `default export`)*\n\n**导入**\n[[前端了解/Node/_resources/node/bc35530ac76dd9fe66a85f0ab8da340c_MD5.jpeg|Open: Pasted image 20250601202009.png]]\n![[前端了解/Node/_resources/node/bc35530ac76dd9fe66a85f0ab8da340c_MD5.jpeg]]\n\n\n#### import函数的使用\n*不允许在逻辑代码中写 `import` 导入语法 , 只能写在 `js` 代码顶层*\n\n***原因*** : \n- 这是因为*`ES Module`在被S引擎解析*时，就必须知道它的依赖关系\n- 由于*这个时候`js` 代码没有任何的运行，所以无法在进行类似于f判断中根据代码的执行情况*\n- 甚至*拼接路径的写法也是错误的* : 因为我们必须到运行时能确定path的值；`错误写法 import from (\"./foo\" + \".js\")`\n\n**动态的加载某一个模坎**：\n- 使用`import()`函数来动态加载；\n√*importi函数返回一个Promise,可以通过then获取结果*；\n\n[[前端了解/Node/_resources/node/5790845b0be6cb9d7ecb7a760fc5631e_MD5.jpeg|Open: Pasted image 20250601205315.png]]\n![[前端了解/Node/_resources/node/5790845b0be6cb9d7ecb7a760fc5631e_MD5.jpeg]]\n\n##### import.meta\n\n`import.meta` 是一个给 `JavaScript` 模块暴露特定上下文的元数据属性的对象。\n\n`    console.log(import.meta)`\n[[前端了解/Node/_resources/node/cca6e731888b778c6f697e3b1d213964_MD5.jpeg|Open: Pasted image 20250601210256.png]]\n![[前端了解/Node/_resources/node/cca6e731888b778c6f697e3b1d213964_MD5.jpeg]]\n\n### ES Module的解析流程\n\n   ***执行流程***\n- 阶段一：构建(`Construction`),根据地址查找`js`文件，并且下载，将其解析成模块记录(`Module Record`);\n  `import * as foo from \"./foo.js\"`\n\n- 阶段二：实例化(`Instantiation`),对模块记录进行实例化，并且分配内存空间，解析模块的导入和导出语句，把模块指向对应的内存地址。\n  `export { name, age, sayHelo } ` //此时的变量还没有值\n\n- 阶段三：运行(`Evaluation`),运行代码，计算值，并且将值填充到内存地址中；\n   //赋上具体值\n\n\n# 包管理工具\n<a href=\"https://docs.npmjs.com/cli/v11/commands\">npm官方文档</a>\n\n### **npm 的重要文件**\n\n- **`package.json`**  \n<a href=\"https://www.cnblogs.com/tzyy/p/5193811.html\"> package.json属性详情</a>\n\n这是每个 Node.js 项目必备的配置文件，记录了项目的元数据和依赖信息。它包含：\n\n**package-lock.json**  \n    该文件记录了项目中每个依赖的具体版本，并锁定依赖树的结构。确保在不同机器上安装依赖时，所有的开发环境和生产环境都能一致地获取相同版本的依赖包\n    \n#### package.json 常见属性\n[[前端了解/Node/_resources/node/b92cff03fb298122f810093af113483b_MD5.jpeg|Open: Pasted image 20250602163215.png]]\n![[前端了解/Node/_resources/node/b92cff03fb298122f810093af113483b_MD5.jpeg]]\n[[前端了解/Node/_resources/node/02d8e40c2946b81a4e25df73f739762a_MD5.jpeg|Open: Pasted image 20250602163342.png]]\n![[前端了解/Node/_resources/node/02d8e40c2946b81a4e25df73f739762a_MD5.jpeg]]\n\n- `dependencies` 和 `devDependencies`：分别列出了项目的生产环境和开发环境依赖\n- 自定义脚本，如构建、测试、启动等命令\n- 配置信息、许可证和作者信息等\n\n##### main\n*main属性指定了程序的主入口文件*\n\n意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require(\"foo\")来使用这个模块，那么`require`*返回的内容就是main属性指定的文件中 module.exports指向的对象。*\n\n它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。\n\n##### scripts\n*scripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。*\nkey是生命周期中的事件，value是要执行的命令。  \n具体的内容有 install start stop 等，详见 [https://docs.npmjs.com/misc/scripts](https://docs.npmjs.com/misc/scripts)\n\n*scripts属性用于配置一些脚本命令，以键值对的形式存在*\n配置后我们可以通过`npm run`命令的`key`来执行这个命令：\n\n对于常用的`start、test、stop、restart`可以省略掉`run`直接通过`npm start`等方式运行\n\n##### dependencies\n- `dependencies`属性是指定无论开发环境还是生成环境都需要依赖的包；\n- 通常是我们项目实际开发用到的一些库模块`vue、vuex、vue-router、react、.react-dom、axios`等等\n##### devDependencies属性\n\n一些包在生成环境是不需要的，比如`webpack、babel`等\n这个时候我们会通过`npm install webpack-save-dev`,将它安装到`devDependencies`属性中\n\n##### peerDependencies属性\n- 还有一种项目依赖关系是对等依赖，也就是你依赖的一个包，它必须是以另外一个宿主包为前提的：\n- 比如`element-plus`是依赖于`vue3`的，`ant design`是依赖于`react、react-dom`;\n\n\n## 依赖的版本管理\n\n*semver版本规范是 `X.Y.Z` :*\n- X主版本号(major): 当你做了***不兼容***的API修改（*可能不兼容之前的版本*）\n- Y次版本号(minor): 当你做了***向下兼容***的功能性新增（*新功能增加，但是兼容之前的版本*）；\n- Z修订号(patch) :当你做了*向下兼容*的问题修正（*没有新功能，修复了之前版本的bug*);\n\n`^`和`~`的区别：\n- `x.y.z` : 表示一个明确的版本号；\n- `^x.y.z` : 表示x是保持不变的，y和z永远安装最新的版本；\n- `~x.y.z` : 表示x和y保持不变的，z永远安装最新的版本；\n\n### **npm 的常见命令**\n\n1. **安装依赖**  \n    安装项目中列出的所有依赖：\n\t`npm install`\n\n该命令会根据 `package.json` 安装所有依赖，并生成或更新 `node_modules` 文件夹。如果你希望***全局安装***某个工具，可以使用 `-g` 参数\n```\nnpm install -g <package-name>\n```\n\n- 通常使用npm全局安装的包都是一些工具包：`yarn、webpack`等；\n- 并不是类似于`axios、express、koa`等库文件；\n- 所以全局安装了之后并不能让我们在所有的项目中使用axios等库；\n**原理图**\n[[前端了解/Node/_resources/node/de93ee2b9acc3969b0b70e785cc75ea3_MD5.jpeg|Open: Pasted image 20250602205758.png]]\n![[前端了解/Node/_resources/node/de93ee2b9acc3969b0b70e785cc75ea3_MD5.jpeg]]\n[[前端了解/Node/_resources/node/53fd01f2d3cbf94655e82f9dbb5edafe_MD5.jpeg|Open: Pasted image 20250602210240.png]]\n![[前端了解/Node/_resources/node/53fd01f2d3cbf94655e82f9dbb5edafe_MD5.jpeg]]\n\n2. **添加依赖**  \n用于安装一个新的包，并将其添加到 `dependencies` 或 `devDependencies` 中：\n```\nnpm install <package-name> --save  # 默认会添加到dependencies\nnpm install <package-name> --save-dev  # 添加到devDependencies\n```\n3. **卸载依赖**  \n删除一个依赖包，并更新 `package.json` 和 `node_modules`：\n```\nnpm uninstall <package-name>\n```\n4. **更新依赖**  \n更新项目中的所有依赖到符合版本范围的最新版本：\n`npm update`\n\n5.**查看包信息**  \n查看已安装包的版本和详细信息：****\n`npm list`\n\n6. **执行脚本**  \n在 `package.json` 文件中定义了脚本后，可以使用 `npm run <script-name>` 命令来执行它。例如：\n```\nnpm run build\n```\n\n### npm发布自己的包\n[[前端了解/Node/_resources/node/e52f14a0ae89ac415e7bb49a89352f71_MD5.jpeg|Open: Pasted image 20250603102555.png]]\n![[前端了解/Node/_resources/node/e52f14a0ae89ac415e7bb49a89352f71_MD5.jpeg]]\n## yarn\n\n`yarn` 是由 Facebook 发起的包管理工具，目的是解决 `npm` 的一些性能和依赖管理问题。`yarn` 在安装速度、离线安装和一致性方面做了显著优化。\n\n- `yarn` 提供了更高效的依赖安装方式，采用并行安装并且支持缓存，能显著提升安装速度。\n- `yarn.lock` 文件确保所有团队成员安装的依赖版本一致，避免版本冲突。\n- 支持离线安装，在没有网络的情况下仍然能够安装已经缓存的依赖。\n\n下载 `npm install yarn`\n### **npm 与 Yarn 的比较**\n\n| 特性         | npm                          | Yarn                 |\n| ---------- | ---------------------------- | -------------------- |\n| **安装速度**   | npm 7+ 引入了一些性能优化，但通常速度较慢     | 更快，支持并行安装和缓存机制       |\n| **依赖一致性**  | 使用 `package-lock.json` 来锁定版本 | 使用 `yarn.lock` 锁定版本  |\n| **离线安装**   | 支持缓存，允许在没有网络的情况下安装依赖         | 支持离线模式，依赖会被缓存        |\n| **工作空间支持** | 从 npm 7 开始支持工作空间             | 原生支持工作空间，适合 monorepo |\n| **CLI**    | 功能全面，易用性不断提升                 | 更简洁，但有些命令不兼容 npm     |\n| **社区支持**   | 全球最大的 JavaScript 包生态         | 非常活跃，尤其是在 React 社区   |\n\n[[前端了解/Node/_resources/node/b079442e73df481b3518d0fd71f00ea8_MD5.jpeg|Open: Pasted image 20250602213810.png]]\n![[前端了解/Node/_resources/node/b079442e73df481b3518d0fd71f00ea8_MD5.jpeg]]\n\n\n## cnpm\n\n查看npm镜像\n`npm config get registry`\n\n设置npm镜像\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n将cnpm设置为淘宝的镜像\n```\nnpm install -g cnpm -registry=https://registry.npm.taobao.org\ncnpm config get registry \n```\n\n\n## npx\n\n npx 是 npm5.2.0版本新增的一个工具包，它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包。\n\n`npx` 是一个由 `npm` 提供的工具，用于直接运行 `node_modules/.bin` 中的可执行文件，而不必在全局安装依赖。`npx` 实际上是 `npm` 5.2+ 版本中新增的命令行工具，允许开发者运行任何命令而无需显式安装。\n\n- `npx` 可以临时运行安装在项目中的命令（即便这些命令没有全局安装），也可以运行 GitHub 上的命令或者从 npm 注册表中直接运行包。\n- `npx` 可以用来快速执行脚本，如运行项目中的构建工具、脚本命令等。\n\n### 局部命令的执行\n\n[[前端了解/Node/_resources/node/b5ed850b7ea893e19c30211f5ccb4c69_MD5.jpeg|Open: Pasted image 20250603091039.png]]\n![[前端了解/Node/_resources/node/b5ed850b7ea893e19c30211f5ccb4c69_MD5.jpeg]]\n## `npm`、`yarn`、`pnpm` 和 `npx` 对比总结\n\n<a href=\"https://juejin.cn/post/7439320353464565800?searchId=2025060308455229ED5BF7AED3BB066612\">`npm`、`yarn`、`pnpm` 和 `npx` 对比总结 </a>\n\n| 特性         | npm                         | yarn                      | pnpm                               | npx                       |\n| ---------- | --------------------------- | ------------------------- | ---------------------------------- | ------------------------- |\n| **安装方式**   | 使用 `npm install` 安装依赖       | 使用 `yarn install` 安装依赖    | 使用 `pnpm install` 安装依赖             | 临时执行包中的命令，不需要安装全局依赖       |\n| **安装速度**   | 较慢，依赖树较深时效率较低               | 快，支持并行安装和缓存               | 非常快，使用硬链接和共享依赖                     | 运行时自动下载依赖，不需要安装           |\n| **磁盘空间**   | 使用重复依赖，占用较多磁盘空间             | 缓存依赖，但依赖安装较多时仍会占用一定磁盘空间   | 通过硬链接减少重复安装，节省磁盘空间                 | 不占用磁盘空间，仅临时运行命令           |\n| **锁定依赖版本** | 使用 `package-lock.json` 锁定版本 | 使用 `yarn.lock` 锁定版本       | 使用 `pnpm-lock.yaml` 锁定版本           | 不锁定版本，运行时临时安装和执行命令        |\n| **依赖管理**   | 默认安装多份重复依赖（有冗余）             | 安装时尽量避免冗余依赖               | 强制封闭依赖，避免隐式依赖                      | 无依赖管理，直接执行命令              |\n| **兼容性**    | 与大部分工具和社区兼容                 | 与 `npm` 兼容，但存在部分差异        | 与 `npm` 和 `yarn` 不完全兼容，特别是在依赖管理方式上 | 依赖于 `npm`，通过 `npx` 直接执行命令 |\n| **离线支持**   | 不完全支持离线安装                   | 支持离线安装，缓存安装过的包            | 完全支持离线安装，依赖缓存共享                    | 不需要离线安装，运行时自动下载依赖         |\n| **适用场景**   | 适用于大部分 Node.js 项目           | 适合需要高性能和一致性保证的项目          | 适合需要优化磁盘空间和性能的大型项目                 | 快速执行单次命令，无需全局安装依赖         |\n| **社区和支持**  | 最大的社区支持，生态最广泛               | 被许多大公司采用，尤其适合 Monorepo 管理 | 生态较小，但专注于性能和空间优化                   | `npm` 的一部分，功能简单实用         |\n|            |                             |                           |                                    |                           |\n\n---\n\n**主要差异总结：**\n\n- **npm**：广泛使用且成熟，适合大部分项目，但安装速度和磁盘空间管理较差。\n- **yarn**：性能优于 `npm`，尤其在并行安装和离线支持方面，适合需要版本一致性的团队协作项目。\n- **pnpm**：通过硬链接节省磁盘空间，优化了安装速度，特别适合大型项目或多个项目共享依赖的情况。\n- **npx**：用于临时执行命令或包，不需要全局安装，适用于单次执行而不需要管理依赖的场景。\n\n  \n\n## 硬链接和软连接\n\n硬链接(hard link):\n- ***硬链接***（英语：hard link) 是*电脑文件系统中的多个文件平等地共享同一个文件存储单元；\n-  删除一个文件名字后，还可以用其它名字继续访问该文件；\n\n符号链接（软链接soft link、Symbolic link):\n- ***符号链接***（软链接、Symbolic link)是一类*特殊的文件；\n- 其*包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用\n\n[[前端了解/Node/_resources/node/54cca17c4865feceebea1a9e017895f1_MD5.jpeg|Open: Pasted image 20250603130622.png]]\n![[前端了解/Node/_resources/node/54cca17c4865feceebea1a9e017895f1_MD5.jpeg]]\n\n\n### 文件拷贝\n\n会在硬盘中复制一份新的文件数据(*改变其中一份, 不会影响另一份*)\n`copy foo.js foo_copy.js`\n[[前端了解/Node/_resources/node/9d19ae1fbdbcd9a762e142c5cf1ce2e2_MD5.jpeg|Open: Pasted image 20250603132426.png]]\n![[前端了解/Node/_resources/node/9d19ae1fbdbcd9a762e142c5cf1ce2e2_MD5.jpeg]]\n\n### 文件的硬链接\n\n多个文件平等地共享同一个文件存储单元(*改变其中一份, 其他文件的内容也会变*)\n`mklink /H foo.js foo_hard.js`\n[[前端了解/Node/_resources/node/3b67fc58b7a2c415f3432e30712e6715_MD5.jpeg|Open: Pasted image 20250603132740.png]]\n![[前端了解/Node/_resources/node/3b67fc58b7a2c415f3432e30712e6715_MD5.jpeg]]\n\n### 文件的软链接\n\n`mklink foo.js foo_hard.js `\n\n[[前端了解/Node/_resources/node/eab8bb7351e7d0e0516366e9b9b1867e_MD5.jpeg|Open: Pasted image 20250603133709.png]]\n![[前端了解/Node/_resources/node/eab8bb7351e7d0e0516366e9b9b1867e_MD5.jpeg]]\n\n## `pnpm`\n\n\n- **磁盘空间优化**：通过硬链接共享依赖，显著节省了磁盘空间。\n- **高效的依赖管理**：依赖安装速度快，尤其是在多个项目共享依赖时表现优秀。\n- **强制封闭依赖**：避免隐式依赖，提高了依 赖管理的可靠性。\n\n### pnpm的原理\n\n使用pnpm, **依赖包将被存放在一个统一的位置**，因此：\n- 如果*对同一依赖包使用相同的版本*，那么*磁盘上只有这个依赖包的一份文件*；\n- 如果*对同一依赖包需要使用不同的版本*，则*仅有版本之间不同的文件会被存储起来*\n- 所有文件都保存在硬盘上的统一的位置：\n - 当安装软件包时，其包含的所有文件都会***硬链接***到此位置，而*不会占用额外的硬盘空间*；\n - 可以在项目之间方便地*共享相同版本的依赖包*；\n\n\n#### 非扁平化的 `node_modules` 目录\n\n所有文件都会存储在硬盘上的某一位置. 当软件包被安装时, 包里的文件会*硬链接*到这一位置, 而不会占用额外的磁盘空间 . 允许跨项目地享用同一版本的依赖\n\n[[前端了解/Node/_resources/node/216694d140e0e8643ae60a379b195f29_MD5.jpeg|Open: Pasted image 20250603152432.png]]\n![[前端了解/Node/_resources/node/216694d140e0e8643ae60a379b195f29_MD5.jpeg]]\n\n##### pnpm的store存储\n[[前端了解/Node/_resources/node/5992ee0d4fdaca3825d820a342aeb0f5_MD5.jpeg|Open: Pasted image 20250603155958.png]]\n![[前端了解/Node/_resources/node/5992ee0d4fdaca3825d820a342aeb0f5_MD5.jpeg]]\n\n## webpack\n\n<a href=\"https://webpack.js.org/concepts/\">webpack官方文档</a>\n\n`webpack` 的核心是一个用于现代 `JavaScript` 应用的静态模块打包器\n\n- 打包bundler:  webpack可以将帮助我们进行打包，所以它是一个打包工具\n- 静态的static :  这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）；\n- 模块化module:  webpack默认支持各种模块化开发ES Module、CommonJS、AMD等；\n- 现代的modern:  现代前端开发面临各种各样的问题，催生了webpack的出现和发展；\n\n前端开发的流程\n[[前端了解/Node/_resources/node/a42138b7fc8da6b36cab5fc1353e9011_MD5.jpeg|Open: Pasted image 20250604105132.png]]\n![[前端了解/Node/_resources/node/a42138b7fc8da6b36cab5fc1353e9011_MD5.jpeg]]\n### path\n\n[[前端了解/Node/_resources/node/f588dfec8ef80c8883c609d36dab60ec_MD5.jpeg|Open: Pasted image 20250604131317.png]]\n![[前端了解/Node/_resources/node/f588dfec8ef80c8883c609d36dab60ec_MD5.jpeg]]\n[[前端了解/Node/_resources/node/1fe253f3c088785cef56223ff7286e52_MD5.jpeg|Open: Pasted image 20250604131328.png]]\n![[前端了解/Node/_resources/node/1fe253f3c088785cef56223ff7286e52_MD5.jpeg]]\n\n[[前端了解/Node/_resources/node/4d7bbf25139209bf647f3e62c551541d_MD5.jpeg|Open: Pasted image 20250604131334.png]]\n![[前端了解/Node/_resources/node/4d7bbf25139209bf647f3e62c551541d_MD5.jpeg]]\n```\nconst path = require(\"path\")\n\nconst filepath = \"C:/abc/cba/nba.txt\"\n\nconsole.log(path.extname(filepath)) // \".txt\"\n\nconsole.log(path.basename(filepath))  //\"nba.txt\"\n\nconsole.log(path.dirname(filepath))  //  \"C:/abc/cba\"\n\nconst path1 = \"/a/d/s\"\nconst path2 = \"../why/ksj/mae.txt\"\n\nconsole.log(path.join(path1, path2))  //\"\\a\\d\\why\\ksj\\mae.txt\"\n\nconsole.log(path.resolve(\"./acd/s\", \"./ehdy/sd\", \"../sda.txt\"))\n//   \"C:\\Users\\sai_8\\Desktop\\1\\code\\path\\acd\\s\\ehdy\\sda.txt\"\n\nconsole.log(path.resolve(\"as/sd\", \"./dsf\", \"/df.txt\"))\n//  \"C:\\df.txt\"\n\nconsole.log(path.resolve(\"./sd/ads\", \"/dsf/sad\", \"./as.txt\"))\n//  \"C:\\dsf\\sad\\as.txt\"\n```\n\n### webpack的安装\n\n```\nnpm install webpack webpack-cli-g #全局安装\nnpm instal1 webpack webpack-cli-D #局部安装\n```\n**webpack 和 webpack-cli的关系**\n\n- 执行`webpack`命令，会执行`node modules`下的 `.bin` 目录下的`webpack`;\n- ` webpack` 在执行时是依赖`webpack-cli`的，如果没有安装就会报错：\n- 而 `webpack-cli`中代码执行时，才是真正利用`webpack`进行编译和打包的过程；\n- 所以在安装 `webpack`时，我们需要同时安装 `webpack-cli`(第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的 `vue-service-cli` 的东西)\n\n### webpack的默认打包\n- 在目录下直接执行webpack命令\n  - 生成一个`dist` 文件夹, 里面存放一个`main.js` 的文件, 就是打包之后的文件\n\n-运行`webpack` 时, `webpack` 会查找当前目录下的 `src/index.js` 作为入口\n如果当前项目中没有存在 `src/index.js`文件, 就会报错\n\n*通过配置指定出入口* \n```\nnpx webpack --entry ./src/main.js --output-path ./build\n```\n\n#### 配置文件\n\n在根目录下创建一个 `webpack.config.js`  文件，来作为`webpack` 的配置文件\n\n[[前端了解/Node/_resources/node/097f3c1fd505f887c84cb2bbdabc1eb6_MD5.jpeg|Open: Pasted image 20250604155437.png]]\n![[前端了解/Node/_resources/node/097f3c1fd505f887c84cb2bbdabc1eb6_MD5.jpeg]]\n\n*如果配置文件名不是 `webpack.config.js`的名字 *\n\n- 可以通过 `--config` 来指定对应的配置文件\n```\nwebpack --config 修改名称后的配置文件\n```\n\n\n### loader的使用\n\n- `loader` 可以用于对`模块的源代码`进行转换\n \n#### loader配置方式\n\n在`webpack.config.js` 文件中写明配置信息 \n\n`module.rules` 允许配置多个 loader\n**module.rules的配置** 如下：\n\n- `rules` 属性对应的值是一个数组：[Rule]\n- 数组中存放的是一个个的`Rule`  , `Rule` 是一个对象，对象中可以设置多个属性：\n   - *test属性*：用于对`resource` (资源)进行匹配的，通常会设置成*正表达式*\n   - *use属性* ：对应的值时一个数组：[UseEntry]\n\t- `UseEntry`是一个对像，可以通过对象的属性来设置一些其他属性\n>\t\tloader:必须有一个loader属性，对应的值是一个字符串：\n>\t\toptions : 可选的属性，值是一个字符串或者对象，值会被传入到 loader中；\n >\t\tquery: 目前已经使用options来替代；\n\n  传递字符串（如：use:['style-loader'])是loader属性的简写方式（如：use:[{loader:'style-loader'}]);\n- loader属性：Rule.use:[{loader}]的简写。\n\n***因为`loader`的执行顺序事从右向左的(从下到上, 从后到前), 所以需要将 `style-loader` 写道`css-loader` 的前面***\n\n**下载**\n```\nnpm install css-loader -D\nnpm install style-loader -D\n```\n[[前端了解/Node/_resources/node/48318a757d2ecc7795830fb554028204_MD5.jpeg|Open: Pasted image 20250604215809.png]]\n![[前端了解/Node/_resources/node/48318a757d2ecc7795830fb554028204_MD5.jpeg]]\n\n简写\n```\n loader: \"css-loader\",\n ```\n```\nuse: [\"style-loader\", \"css-loader\"]\n```\n\n\n","tags":["node"],"categories":["前端开发"]},{"title":"MinVue","url":"/posts/2025/04/Fronted/MinVue/4a7e677b.html","content":"# Mini Vue\n\n## 前言\n\n在尝试读懂这篇文章之前，请保证已经学习过面向对象基本知识、HTML基础、JS基础，并且有过一定的实践开发基础，不然可能会有非常多的小问号。\n\n**如果不满足上述条件，也可以试着读一读**，不必为其中不懂的内容感到焦虑，后面都能学会的。\n\n本文旨在教会读者实现一个精简版的Vue，很多Vue的功能会被简化，但是核心思想是相通的。\n\n本文会尽可能通俗易懂、避开JS的各种生僻特性。\n\n我们先不说Vue的事情，让我们先通过一些场景了解一点前置知识和概念——只需要知道大概是什么，没必要咬文嚼字：\n\n## 一个场景里的概念：响应式数据、依赖、数据劫持、MVVM 和双向绑定\n\n看看这段代码：\n\n```javascript\n// 我们希望这个关系恒成立： y = 2 * x + 1 \nlet x = 10 \nlet y = 2 * x + 1 \nx = 20 \n// x变了，但是y却不会发生变化\n```\n\n我们希望，x变化时y能自动地变化，而不是我们还需要手动赋值多此一举。\n\n那么怎么实现呢？这里有一种思路是，设置一个角色专门监听x的变化，在察觉x变化时能够通知y发生变化。\n\n这很容易做到，JS为我们提供了一个API，`Object.defineProperty`：\n\n```javascript\nconst data = { \n  x: 10, \n  y: 21 \n}; \n\n// 监听 data.x 的 修改 \nObject.defineProperty(data, 'x', { \n  set(value) { \n    data.y = value * 2 + 1; // 当 x 修改时，通知 y 发生相应变化 \n  } \n}); \n\nconsole.log('一开始:', data.y); // 21 \ndata.x = 100; \nconsole.log('x变化后:', data.y); // 201\n```\n\n在Vue中，将普通数据变成响应式数据的过程，就叫**数据劫持。**\n\n而`Object.defineProperty`扮演的这个角色，在下文中被称为 **数据劫持者（hijacker）**。\n\n回到web中，JS的DOM操作是如何去修改视图的呢？\n\n让我们再看看一个DOM操作修改`<input />`内容的例子：\n\n```javascript\nlet value = document.querySelector('input').value; // 1.获取input当前内容 \n\nvalue = Number(value) + 1; // 2. 修改内容 \n\ndocument.querySelector('input').value = value; // 3.重新赋值\n```\n\n我们能不能将第3步干掉？重新赋值看上去太多此一举了！\n\n结合上文x和y的关系，相信大家应该是灵光一闪。\n\n我们这里先抛出问题，暂时不考虑其中具体的实现细节。\n\n**响应式数据**指的是，依赖变化时，该数据会自动变化。如上文的y就是响应式数据，x则是其依赖，响应式数据和其依赖总是能表达为`y=F(x)`。\n\n**M-V-VM**是一种技术架构，**M**代表数据层(Model)，**V**代表视图层(View)，**VM**(ViewModel)在这里则是Vue代表的层次。\n\nVM层会监听另外两层的变化，在其中一个变化时，使另外一个发生相应的变化，即VM层将V层和M层进行了**双向绑定——V=F1(M)且M=F2(V),V与M互为依赖。**\n\n具体一点：\n\n1.  用户在输入框输入了123（V层），内存里与之关联的数据自动变为123（M层）\n2.  通过代码修改内存的数据为123（M层），界面上与之关联的部分自动变为123（V层）\n\nVue通过建立MVVM架构实现了双向的响应式，即**双向绑定**。\n\n-----\n\n## 又一个场景里的概念：观察者模式、依赖收集\n\n```html\n<script>\n  let v = 1;\n</script>\n\n<div>\n  <input value={v} />\n  <input value={v} />\n</div>\n```\n\n上述HTML片段中，两个`<input />`内使用了一个JS变量v。\n\n我们实现一下对v变化的监听，察觉到它发生变化的时机，然后及时通知到两个`<input />`的value改变：\n\n```javascript\n// 监听v，一旦v变化，就改变两个input的值\nObject.defineProperty(window, 'v', () => {\n  set(value) {\n    const inputDoms = document.querySelectorAll('input')\n    inputDoms[0].value = value\n    inputDoms[1].value = value\n  }       \n})\n```\n\n注意，这里我们能进行通知，是因为这个片段很简单，我们能直接看到v被使用的位置，所以可以写像创建上文x与y的关系那样的代码。\n\n但是，如果我们的项目有无穷多处都依赖了v, 那我们还能一个一个手动去实现每一个响应式数据吗？\n\n**所以我们面临一个问题：怎么快速修改所有v？**\n\n这里我们需要先学习业界大佬们总结的23种设计模式之一，**观察者模式**。\n\n什么是观察者模式？\n\n这个模式中一共有2个角色，**发布者**与**观察者**。\n\n发布者好比一个UP主，观察者就是ta的粉丝，当UP发视频的时候，粉丝就会第一时间收到通知。\n\n让我们用代码表述一下：\n\n我们的问题解决了——**怎么快速修改所有v:**\n\n**通过发布者通知所有观察者执行`update`方法修改数据**，**就实现了修改所有v。**\n\n我们可以手动创建一个发布者，但是新的问题是，**我们该怎么创建观察者？**\n\n让我们分析一下该怎么做，就像是把大象放进冰箱一样，凡事都只需要三步：\n\n1.  观察局势，发现很多地方都使用了变量v，比如`<input value={v}>`\n2.  **特殊标记**这些v的位置\n3.  让被标记的变量成为观察者\n\n怎么标记呢？那就是创造一种语法，比如`<input value={v}>`中的`{v}`。\n\n然后通过一些\\~\\~暴力\\~\\~巧妙的操作，遍历所有HTML，找到其中格式满足`{xxx}`的内容，将其变成观察者即可。\n\n同时，我们会用巧妙的操作实现一种逻辑，**在观察者产生的时候，它会主动关注发布者**。\n\n具体怎么操作，我们后面再谈。\n\n**寻找被特殊标记的变量**的过程，就是**依赖收集**；**将标记变量转化为响应式**的过程，就是**数据劫持**；\n\n至此，我们实现了单向的响应式，在publisher的内容被修改时触发publish方法通知所有存在于HTML片段里面的observer一起修改——也就是完成了`V=F1(M)`。\n\n**那双向绑定，`M=F2(V)`怎么实现呢？**\n\n有了上述的铺垫之后就非常简单了！视图层(V层)的变动主要是来自于用户的**输入**（键盘输入、鼠标点击等），所以我们只需要监听一些用户操作事件就好，比如当用户输入时，让publisher进行通知就行了。\n\n代码示意如下：\n\n```javascript\n<div>\n  <input value={v} /> // 用户在这里标签上进行输入\n  <input value={v} />\n</div>\n\n<script>\n  // ... 省略一堆代码\n  const inputDom1 = document.querySelector('input')\n  // 监听键盘输入\n  inputDom1.oninput = (e) => {\n    // 一旦用户进行输入，就让UP主（publisher）把新的值告诉其他所有粉丝（观察者）\n    publisher.publish(e.target.value)\n  }\n</script>\n```\n\n-----\n\n## 再一个场景里的概念：虚拟DOM和Diff算法\n\n让我们先来讲个故事：\n\n某个疯狂星期四，乐程的xxl点外卖。打开某团先点了一份黄金鸡块，五分钟后，觉得不够吃又点了一份吮指原味鸡，再过了五分钟，觉得有点渴于是又点了一杯肥宅快乐水...\n\n这个故事给我们什么启发？\n\n很明显，这样多次操作下来，需要支付多次配送费用，显然不如一次性点完所有来得划算。\n\n**在web中也是类似的**：\n\nJS引擎和处理HTML的渲染引擎不在同一个进程下，每当用JS去操作HTML（DOM操作），都需要开辟一个跨进程的通道，这种操作开销不小。\n\n看不懂没关系，我们通俗一点说，\n\n相当于，JS和HTML是不在同一个国家的，JS要去处理HTML相关的事情，就得花大价钱买机票出国去做，做完了又得买机票回来继续做自己的事情，如果下次又有HTML的事情要处理，那么就又得买机票出国...\n\n这种开销是昂贵的。\n\n所以，如果JS能先把要处理的DOM统一记录下来，之后一次性处理完，就能节省许多不必要的开销。\n\n而这种记录，就是**虚拟DOM。**\n\n众所周知，HTML会被解析为DOM树，下图左侧HTML对应就是右侧的DOM树：\n\nDOM这个词严格来说指的是DOM树，其中每个节点就叫DOM节点，而DOM元素专指标签。\n\n但是口头上，DOM、DOM树、DOM节点这几个词经常混用，并不做严格的区分...\n\n|  |  |\n|---|---|\n\n我们为了更明确地表示区分，在提到**虚拟DOM**的语境下，会把DOM称为**真实DOM。**\n\n虚拟DOM就是用JS代码表示上图右侧结构(主要看a标签那一块的表示就好了)：\n\n```javascript\nconst visualDom = { \n    tag: 'html',  // 标签名 \n    props: {},    // 标签的属性 \n    content: [    // 标签的内容 \n        { \n            tag: 'head', \n            props: {}, \n            content: [] \n        }, \n        { \n            tag: 'body', \n            props: '', \n            content: [ \n                { \n                    tag: 'a', \n                    props: { \n                        href: 'xxx' \n                    }, \n                    content: [ \n                        'a的内容' // 内容可以直接就是一个字符串,所以后面需要区分,是字符串还是标签 \n                    ] \n                }, \n                '123' \n            ] \n        } \n    ] \n}\n```\n\n之后，每次JS先在自己家里把要做的改变记录好，后面出国就能一次性把所有事情办完，节省开销。\n\n那么如何构建虚拟DOM呢？让我们一步一步考虑：\n\n1.  起初，遍历所有真实DOM，产生上述结构。\n2.  当发送改变时，比如新增/删除了一些标签，我们得先在虚拟DOM记录这种改变——**这时候问题出现了**！\n\n我们怎么知道这种**改变发生在虚拟DOM的哪个位置**？又重新遍历所有真实DOM节点产生新的结构吗？这听上去开销也太大了，甚至比我们使用虚拟DOM前的情况还要大，那这简直是得不偿失。\n\n所以我们需要一些算法来优化一下，也就是**Diff算法。**\n\nDiff算法不是具体某个算法，而是像DP一样，是一类算法，解决的问题是如何尽快找出两份内容中不同的部分。\n\n-----\n\n## 准备开始\n\n在了解了上面所有概念之后，我们最后来进行一点总结。\n\n我们要做的是**My-Vue**，所以简称为**MUE**吧。\n\n在正式开始之前，希望大家能先去体验一下真正的Vue。\n\n由于Mue的语法模仿的是Vue2, 所以推荐大家选择Vue2进行体验。\n\n因为Vue3语法发生了一些变化，可能会给大家带来一些困扰。\n\n**但无论什么版本，底层原理还是基本一致的。**\n\n\\*\\*体验到什么程度？\\*\\*只需要看看大概长啥样，自己再写一点响应式数据试一下就行了。\n\n让我们梳理一下上面三个场景中提到的内容，整体流程大概是这样的：\n\n其中需要注意的是，我们之前提到的观察者模式中，没有实现反向通知的能力，这点会在下文提及。\n\n让我们准备一下文件结构：\n\n其中`index.html`和`main.js`中的内容分别是：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Mue</title>\n</head>\n<body>\n  <div id=\"app\">\n    <div>{msg}</div>\n    <input type=\"text\" value=\"{msg}\">\n  </div>\n</body>\n<script type=\"module\" src=\"./main.js\"></script>\n</html>\n```\n\n如果一切顺利，html中出现的`{msg}`将被替换成`Hello Mue`。\n\n```javascript\nimport Mue from '../mue-core/mue.js';\n\nwindow.mue = new Mue({\n  el: '#app',\n  data: {\n    msg: 'Hello MUE!'\n  },\n});\n```\n\n和上文一样，接下来涉及到面向对象的部分，我们都用**Class**进行实现。\n\nJS中，Class本质是Function，这意味着可以用Function实现——并且这是更推荐的做法。\n\n但是考虑到大家的面向对象基础更多来自于Java，用Class实现应该更容易上手。\n\n-----\n\n## 实现核心能力\n\n### 实现：ViewModel层核心 Mue\n\n非常简单，主要是记录一下`el`和`data`。\n\n`el`即对应的真实DOM节点，后续我们将把整个项目挂载到`el`上。\n\n然后创建**数据劫持者Hijacker**和**模板编译者Compiler**即可。\n\n```javascript\nimport Hijacker from '../mue-core/hijacker.js';\nimport Compiler from './compiler.js';\n\nclass Mue {\n  constructor(options) {\n    // element的简写。作为项目挂载的根节点。\n    this.el = document.querySelector(options.el);\n    this.data = options.data;\n    new Hijacker(this, 'data');\n    new Compiler(this); // 把整个mue都传给Compiler\n  }\n}\n\nexport default Mue;\n```\n\n### 实现：发布者 Publisher\n\n比较简单，基本和之前提到的部分一致，不再过多赘述：\n\n```javascript\n// 发布者\nclass Publisher {\n  constructor(data) {\n    this.viewers = [];\n  }\n\n  addViewer(viewer) {\n    this.viewers.push(viewer);\n  }\n\n  publish() {\n    this.viewers.forEach((viewer) => {\n      viewer.update();\n    });\n  }\n}\n\nexport default Publisher;\n```\n\n### 实现：数据劫持者 Hijacker\n\n考虑到大家的JS基础，我们这里先简单说明一个JS的知识点，`this`指向。\n\n本文的目的不是学习`this`，所以只做**不严谨且粗略的介绍**。（如果你已经弄懂了`this`，请跳过这个部分）\n\n上文已经用到过不少了，看到这里相信也也应该知道Class中的`this`大部分时候的意思就是\"我自己\"。\n\n我们上文也提到了，Class本质是Function，而且Function内部也有`this`。\n\n大部分情况下，\\*\\*一个函数的`this`指向这个函数的调用者。\\*\\*来看看下面这个例子：\n\n```javascript\n// case 1：类的方法\nclass A {\n  testThis() {\n    console.log(this);\n  }\n}\nnew A().testThis(); // **A**\n\n// case 2: 全局函数\nfunction B() {\n  console.log(this);\n}\nB(); // (浏览器环境下)**window**。 因为这是window.B()的缩写\n\n// case 3: 类的方法中使用全局函数\nclass C {\n  testThis() {\n    B();\n  }\n}\nnew C().testThis(); // (浏览器环境下)**window**, 因为还是 window.B()\n\n// case 4: 为了让 类的方法中使用的全局函数 访问到 类的this, 我们需要这么改：\nfunction Dfunction(that) {\n  console.log(that);\n}\nclass Dclass {\n  testThis() {\n    const that = this; // 这里多开一个变量的确是不必要的，这里这么做是为了**强调这种处理方式**\n    Dfunction(that);\n  }\n}\nnew Dclass().testThis(); // Dclass\n```\n\n另外，数据劫持还需要注意一个事情就是，可能出现下面这样树形的数据，所以我们需要进行一个遍历处理，这里我们采用递归实现。\n\n```javascript\nconst data = {\n    a: {\n        aa:123,\n        ab: {\n            aba: 'hhh'\n        }\n    },\n    b: 'aaaaaaa'\n}\n```\n\n好了，现在让我们来实现**Hijacker:**\n\n```javascript\nimport Publisher from \"./publisher.js\";\n\n// 数据劫持者\nclass Hijacker {\n  constructor(mue, data) {\n    this.hijack(mue, data);\n  }\n\n  // Object.defineProperty劫持数据需要拿到 该数据节点 及 其父级对象\n  hijack(object, key) {\n    // **创建发布者**\n    const publisher = new Publisher();\n    let value = object[key];\n\n    if (!value) {\n      return;\n    } else if (typeof value === 'object') { // 当前节点是树，递归;\n      Object.keys(value).forEach((key) => {\n        this.hijack(value, key);\n      });\n    } else { // 当前节点是叶子节点；object则是其父级节点\n      // **上文提到的知识点：JS的this指向**\n      const that = this;    \n      // **开始劫持数据**\n      Object.defineProperties(object, value, {\n        // **记住这个get, 这个很重要**\n        get() {  // **实现反向通知的核心步骤**，具体怎么回事在**实现Viewer时进一步说明**\n          if (Publisher.target) {\n            publisher.addViewer(Publisher.target);\n          }\n          return value;\n        },\n        set(newValue) {\n          if (value === newValue) { // 防止死循环: 更新->触发publish->更新->...\n            return\n          }\n          value = newValue;\n          that.hijack(object, newValue); // 提防一首新的数据是树形结构，递归一下\n          publisher.publish();\n        }\n      });\n\n    }\n  }\n}\n\nexport default Hijacker;\n```\n\n### 实现：观察者 Viewer\n\n观察者也非常容易实现，只需要在之前提到过的代码上加一点点内容实现反向通知即可：\n\n```javascript\nimport Publisher from \"./publisher.js\";\n\n// 观察者\nclass Viewer {\n  constructor(mue, dataKey, updateHandler) {\n    this.mue = mue; // 传说中的vm层，即mue实例\n    this.dataKey = dataKey; // 数据的键\n    this.updateHandler = updateHandler; // 用来更新视图层(V层)的方法\n\n    // 这里是反向通知的关键操作：\n    // 绑定一个静态属性。相当于在Publisher内部创建一个“全局”变量，记录是哪个观察者触发的反向通知\n    Publisher.target = this;\n    // 这里使用了 mue.data[dataKey]，**将触发劫持者设置的 get方法**：\n    // **反向通知 publisher邀请当前这个viewer成为观察者（也可以理解为viewer主动成为观察者）**\n    this.oldValue = mue.data[dataKey];\n    // 结束，标记为空，释放内存\n    Publisher.target = null;\n  }\n\n  update() {\n    const newValue = this.mue.data[dataKey];\n    if (this.oldValue === newValue) { // 同样地，没有更新就啥也不干\n      return;\n    }\n    // 更新视图，实现 V = F1(M)\n    this.updateHandler(newValue);\n  }\n}\n\nexport default Viewer;\n```\n\n让我们分析一下其中`Publisher.target`是一个什么操作：\n\n在创建Viewer的时候，会给Publisher添加一个**静态属性**`target`，记录一下当前是在创建哪个观察者。\n\n静态属性可以理解为，在`Publisher`上创建的一个全局变量。\n\n然后使用这个观察者对应的值时，会触发`get`方法，让观察者实例`publisher`将刚刚记录的观察者添加进观察者队列——看上去就像是**观察者一创建就主动关注了发布者**一样。\n\n这里其实有个有意思的小知识点，就顺口提一句：\n`import`的内容是原数据的引用而不是拷贝，所以我们可以在`viewer.js`引入的`Publisher`上绑定新的值，然后在`hijacker.js`中访问到这些值。\n\n### 实现：模板编译者 Compiler\n\n这个是五个角色中最难的一个部分了。\n\n在开始写代码前我们仍然需要介绍一堆前置概念。\n\n1.  首先我们要复习一下JS的DOM类型——**请记住DOM也是有类型的**，常见的类型如下表所示：\n\n| **类型** | **说明** | **编号** | **图示参考** |\n|---|---|---|---|\n| **元素** | **每一个标签都是一个元素节点，如 `<div>` 、 `<span>`** | **1** |  |\n| 属性 | `id` 、`class` 、`style`等 | 2 | |\n| **文本** | **元素节点或属性节点中的文本内容** | **3** | |\n| 注释 | 注释，比如\\`\\` | 8 | |\n| 文档 | 也叫根节点，即`document` | 9 | |\n\n2.  然后再让我们了解一下 **伪数组**。\n\n<!-- end list -->\n\n```javascript\n// 伪数组也叫类数组，本质是对象，只不过键是0-N, 就像是下面这样\nconst objectArray = {\n    0: 'aaa',\n    1: 'bbb',\n    2: 'ccc'\n}\n\nconsole.log(objectArray[0]) // aaa\n```\n\n什么场景下会出现伪数组？\n\n比如`document.querySelectorAll`的返回值、函数的`arguments`参数列表等都是伪数组。\n\n3.  如果要把伪数组变为数组，可以使用**Array.from**方法:\n\n<!-- end list -->\n\n```javascript\n<div id=\"app\">\n  <span>Hello</span>\n  World\n</div>\n<script>\n  const dom = document.querySelector('#app')\n  const children = dom.childNodes // **获取当前节点的所有子节点。可以以此进行前序遍历**\n  console.log('伪数组', children)\n  console.log('真数组', Array.from(children))\n</script>\n```\n\n那为什么要把伪数组转为真数组呢？\n\n因为伪数组是对象，不具有数组的某些方法，比如`push`和`pop`，许多场景下使用起来不方便。\n\n那JS设计者为什么要搞出伪数组这种东西？\n\n据JS之父自己坦白——\"当初只用了十天就搞完了...现在看起来确实设计得太糙了...\"\n\n4.  最后，我们需要简单认识一下**正则表达式（regular expression）。**\n\n实现Compiler只会简单用到一点正则，所以这里只给出3种case给大家了解一下概念，不做过多深入:\n\n```javascript\nconst reg = /\\{(.+?)\\}/; // 正则表达式。这个能够匹配形如 {xxx} 的字符串, ()表示要获取的部分\nconst str = '这是{msg}';\n\n// case 1: 用正则表达式去匹配字符串\nconsole.log(reg.test(str)); // true\n\n// case 2: 用字符串去匹配正则表达式\nconsole.log(str.match(reg)); // [ '{msg}', 'msg', index: 2, input: '这是{msg}', ...]\n\n// case 3: 替换匹配内容\nconst data = 'swpu-lec, yyds';\nconsole.log(str.replace(reg, data));  // 这是swpu-lec, yyds\n```\n\n由于主题是Vue，而且正则又博大精深，所以限于篇幅此处不做更多介绍了。如果对此感兴趣，可以学习：\n**[该类型的内容暂不支持下载]**\n\n熟悉了以上内容后，先来大体看看我们要做的东西。\n\n内容比较多，我们拆成了几个层次分开看，首先我们需要一个大体的框架如下：\n\n```javascript\nimport Viewer from \"./viewer.js\";\n\n// 模板编译者\nclass Compiler {\n  constructor(mue) {\n    this.mue = mue;\n    this.el = mue.el;\n    this.compile(this.el);\n  }\n\n  // 开始编译\n  compile(el) {\n    const childNodes = el.childNodes; // 真实DOM伪数组\n    const childNodesList = Array.from(childNodes); // 转为真数组，进而可以用数组的api\n\n    // 前序遍历整个DOM树\n    childNodesList.forEach((node,) => {\n      // 判断是什么类型的DOM, 扔给不同的处理方法\n      if (node.nodeType === 1) { // 元素类型\n        this.compileForElement(node);\n      } else if (node.nodeType === 3) { // 文本类型\n        this.compileForText(node);\n      }\n      // 如果还有子节点，递归获取下一层\n      if (node.childNodes.length) {\n        this.compile(node);\n      }\n    });\n  }\n  // TODO: 主要就是实现这俩函数：\n  // 处理元素类型DOM\n  compileForElement(node) {}\n  // 处理文本类型DOM\n  compileForText(node) {}\n}\n\nexport default Compiler;\n```\n\n怎么实现函数呢？既然我们都说过正则匹配了，那么也会用上吧：\n\n```javascript\n// 处理元素类型DOM\ncompileForElement(node) {\n  const reg = /\\{(.+?)\\}/; // 正则表达式，匹配形如 {xxx} 的字符串\n  const allAttributes = Array.from(node.attributes); // 将节点的所有属性，处理为数组\n\n  // 遍历数组，处理每个属性\n  allAttributes.forEach((attribute) => {\n    // 比如 data=\"{msg}\", attribute.name就是\"data\", attribute.value就是\"{msg}\"\n    const text = attribute.value;\n    const matchRes = text.match(reg);\n    if (matchRes) { // 如果包含形如 {xxx} 的部分\n      const dataKey = matchRes[1];    // 比如匹配的是\"{msg}\", matchRes[1]就是\"msg\"\n\n      // 创建观察者，触发相关逻辑\n      new Viewer(this.mue, dataKey, (newValue) => {\n        node.textContent = newValue;\n      });\n\n      const newValue = this.mue.data[dataKey];\n      node.value = text.replace(reg, newValue); // 将 {xxx} 替换为具体的值\n      // 监听键盘输入，完成双向绑定，M=F2(V)\n      node.addEventListener('input', () => {\n        this.mue.data[dataKey] = node.value;\n      });\n    }\n  });\n\n}\n\n// 处理文本类型DOM\ncompileForText(node) {\n  const reg = /\\{(.+?)\\}/;\n  const text = node.textContent;\n  const matchRes = text.match(reg);\n\n  if (matchRes) {  // 与上面的方法基本上一样的逻辑\n    const dataKey = matchRes[1];\n    const newText = this.mue.data[dataKey];\n    node.textContent = text.replace(reg, newText);\n\n    new Viewer(this.mue, dataKey, (newText) => {\n      node.textContent = newText;\n    });\n  }\n}\n```\n\n至此，MUE已经基本完成了。可以打开HTML页面体验一下成果了！\n\n但也再额外给一点开放性挑战，感兴趣可以做一做：\n\n```javascript\n// challenge 1：if、else-if、else，当值为布尔或可以类型转换为布尔时，进行相应的渲染控制\n<div>\n  <div if=\"{false}\">A</div>\n  <div else-if=\"{0}\">B</div>\n  <div else=\"{true}\">C</div>\n</div>\n// challenge 2：循环渲染, 其中arr是一个数组，element是其元素，index是其下标\n<div for=\"i:arr\">\n  <span>{i}</span>\n</div>\n```\n\n-----\n\n## \\~\\~【废弃】实现性能优化\\~\\~\n\n我们不需要下述的性能优化方案——因为我们有了超越虚拟DOM性能的方案。\n\n### \\~\\~实现：虚拟DOM\\~\\~\n\n\\~\\~经过一番体验后就发现，如果非常快速地输入中文的话，可能会导致双向绑定出错...\\~\\~\n\n\\~\\~这是因为，目前我们是每输入一个字符都会触发一次真实DOM的更改，高频且大量的操作就可能超出浏览器处理数据的极限（输入频率超过浏览器最大渲染频率），出现数据和视图不一致的情况...\\~\\~\n\n\\~\\~总结就是，太卡了，需要优化一下，那么就像是我们上文提到的，实现一下虚拟DOM。\\~\\~\n\n### \\~\\~实现：Diff算法\\~\\~\n\n如果我们没有虚拟DOM，那么我们或许可以不使用Diff算法？\n\n-----\n\n## 实现更多场景\n\n我突然意识到这不仅是一次尝试，更是一个开发真实可用的框架的好机会！\n\n由于Mue名字寓意太明显了抄袭痕迹太重，所以正式版改名叫**Mud**吧，寓意非常丰富：\n\n1.  实现思路借鉴了Vue，React(JSX)，Svelte等多个框架，是各种东西糊成的一坨\n2.  实现并不精致，但是容易被塑造成各种形状，朴素实用\n3.  泥巴里面可以催生出很多东西，以此为基础可以产生更多技术框架\n4.  出淤泥而不染\n\n（我的确是在自吹自擂）\n\n### 1\\. 在多种模块化规范下使用Mud.js\n\n先简单介绍一下JS的模块化规范：\n\n| 规范名称 | 说明 | 示例 |\n|---|---|---|\n| umd | 几乎是前端诞生以来，就有了雏形，但是一直到2009年左右才终于形成正式的规范 | `<script src=\"xxx\" />` \\<br\\>像这样引入的就是umd包 |\n| cjs | NodeJS的伴生产物，也是2009年左右形成的规范 | `const a = require('a')` \\<br\\>`module.exports = {}` \\<br\\>像这样的导入、导出的则是cjs包 |\n| esm | ECMAScript官方2015年推出的规范，JS正统 | `import a from 'a'` \\<br\\>`export default b` \\<br\\>像这样导入、导出的则是esm包 |\n| cmd和amd | 2009年前后出现，现如今使用频率较低，不在本次兼容的范围内。 | ?（不详） |\n\n我们将借助**rollup**的能力实现一套代码转变为多种规范的包。\n\n在这之前你一定听说过webpack或者vite——不使用这些是因为它们太重了，我们这里只是需要简单地转变规范，所以轻量小巧的rollup就成了首选。\n\n相信配置一套满足上述要求的rollup文件不会困扰大家，所以交由大家自行实现。\n\n在打包完成后，引入不同规范的包：\n\n**umd**\n\n非常容易实现，但是需要输入完整路径（形如`../node_modules/mud/umd/index.js`）\n\n**cjs**\n\n由于node和node\\_modules的关系不一般，所以只需要`require`直接导入包名即可(`require('mud')`)\n\n**esm**\n\n这是最难的一个部分，需要有webpack等打包构建工具（这就埋下了一个伏笔——我们需要构建一个脚手架；还有，我个人更倾向用`vite`）\n\n这里为了更好地验证包发布的效果，这里可以使用工具**yalc**来模拟验证。\n\n### 2\\. 比虚拟DOM更直接的内容更新办法\n\n相比虚拟DOM，其实有个更简单且还算高效的办法——`innerHTML`。\n\n一键替换内容。\n\n这样的实现将会减小代码体积，并且在常规情况下的效率会高于虚拟DOM。\n\n### 3\\. 模块化\n\n受到腾讯的微前端框架**无界**的启发，我们想到了一种不一样的模块化方案：\n\n先到根目录下`src/index.html`中写入（根组件）\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Mud.js</title>\n  <link rel=\"stylesheet\" href=\"./index.css\">\n</head>\n<body>\n  <div id=\"app\">\n    <div>{msg}</div>\n    <input type=\"text\" value=\"{msg}\">\n    <component1 />\n  </div>\n</body>\n<script type=\"module\" src=\"./xxx/Mud.js\"></script>\n<script>\nnew Mud({\n  el: '#app',\n  data: {\n    msg: 'Hello Mud!',\n    arr: ['Someday', 'I', 'Will', 'Be', 'Like', 'You'],\n    cnt: 1,\n  },\n\n  components: {\n    component1: 'src/components/component1/index.html'\n  }\n});\nconst plus = () => {\n  mud.data.cnt ++\n}\n</script>\n</html>\n```\n\n然后这里是模块`src/components/component1/index.html`：\n\n```html\n<div>这是组件</div>\n\n<script>\n new Mud({\n  el: '#component1',\n  data: {},\n});       \n</script>\n```\n\n怎么引入模块呢？\n\n1.  从根组件开始解析（模板编译的过程），访问每个DOM节点时，通过字符串比较发现了非原生标签，那么我们就推断这是一个Mud组件。\n2.  要求用户手写组件注册（`id: path`），据此便能够通过组件名称（即`id`），找到对应的文件路径，用ajax等方式请求下来（异步解析非常高效，也为ssr提供了能力），直接替换原来的组件标签的`innerHTML`即可。\n3.  注意，替换之后，该组件内部可能还有组件，也遵循上述规则进行解析——这样的设计，我们便以一种非常简单的方式实现了单页面应用、组件化设计，它的特点是渲染顺序是先序，更新粒度是一个组件——所以我们不需要Diff，并且...\n4.  **更好的数据劫持**\n\n### 初步实现\n\n将`Object.defineProperty`换为**Proxy**，这样我们就能够在不重写方法的前提下监听到数组的`push`、`pop`等操作了。这是一个改动量非常大的工作，但是很显然，它的收益是相当可观的。\n\n### 多级调用\n\n还需要支持对象多级调用，思路就是通过点来分割即可。\n\n### 性能优化\n\n对于已经被劫持过的数据，我们要防止其被再次劫持以避免不必要的性能开销。\n\n### 5\\. 【TODO】更好的观察者模式\n\n现在的观察者都是不具名的，存在很多性能问题：\n\n1.  一处变量a改变时，除了通知其他变量a更新之外，还会通知变量b更新。\n2.  比如`handleIf`中，反复改变状态时，会创建大量重复的观察者。\n\n优化的方案也比较简单，将Publisher的数组改为一个**Set**，通过键名指定更新某一个变量。\n\n### 6\\. 丰富语法\n\n现在已经实现了插值语法、`for`循环等，目前还打算实现以下语法。\n\n**if系列**\n\n`If else-if else`，这是vue中非常优秀的一个设计，抄了。\n\n**for**\n\n**组件参数传递**\n\n父级组件中：\n\n```html\n<component1 a={xxx} />\n\n<script>\nnew Mud({\n    data: {\n        xxx:1\n    }\n})\n</script>\n```\n\n子级组件中：\n\n会把这个组件标签上所有的属性搜刮下来，然后自动放到`props.data`中（之后，`props`将作为一个关键字，不允许用户自定义`data`叫`props`）：\n\n```html\n<div>\n    {{props.data.xxx}}\n</div>\n\n<script>\nnew Mud({\n    data: {},\n})\n</script>\n```\n\n另外还有`props.child`的操作，这个则是react中非常符合直觉的设计：\n\n父组件中：\n\n```javascript\n<component1 a={xxx}>\n    <div>这是嵌入的内容</div>\n</component1>\n\n<script>\nnew Mud({\n    data: {\n        xxx:1\n    }\n})\n</script>\n```\n\n子组件中：\n\n结合`if`等语法可以实现非常多骚操作，而且这部分由于是用`innerHTML`直接插入的，所以还可以使用子组件中的变量。\n\n```javascript\n<div>\n    {{props.child}}\n</div>\n\n<script>\nnew Mud({\n    data: {},\n})\n</script>\n```\n\n**Watch监听**\n\n即让用户手动监听数据，这个比较简单，将观察者的内部方法暴露出去即可。\n\n### 7\\. 实现生命周期\n\n对此，我们还得仔细思考一下，到底是实现Hook还是生命周期。\n\n**onMounted**\n\n直接在挂载的时候加个函数就行了。\n\n### 8\\. 更多生态\n\n**实现Mud-Doc：Mud官方文档**\n\n**【TODO】实现Root：Mud框架的路由**\n\n**实现Mud-Cli：快速搭建Mud项目**\n\n**【TODO】产出Mud-Demo：利用Mud快速构建优秀的作品**\n\n**组件样式库**\n\n\\~\\~暂时使用开源的xy-ui:[https://github.com/xboxyan\\~\\~](https://github.com/xboxyan~~)\n\n可以先考虑 semi-ui\n\n**发布上线**\n\n-----\n\n## 测试点\n\n### 1\\. 内容插值语法\n\n  * ☑ 常规的基础数据插值，如`{a}`\n\n  * ☑ 特殊的基础数据插值，如`NaN`，`undefined`，`null`，空字符串，`symbol`，基本数学运算表达式，三元表达式\n\n    > 对于`undefined`和`symbol`，插值语法不解析，其余均正常。\n\n  * ☑ 常规的引用数据类型插值，如`{b}`，其中`b={name: 1}`\n\n    > 支持n级连续调用，但是Proxy的setter并没有生效（已修复）。\n\n  * ☑ 特殊的引用数据类型插值，如空对象, 函数表达式，函数运算结果，`new`新建对象\n\n    > 对于函数表达式，竟然会直接获取到运算结果，出乎意料。\n\n  * ☑ 更多插值方式，如直接插入表达式，插入函数调用，插入连续调用\n\n    > 暂不打算支持插入表达式和函数调用。\n\n  * ☑ 非常极端的插值方式，如不填写任何变量，填写不存在的变量，填写特殊符号，填写标签\n\n    > 很好，填写标签也是能够如预期的一样进行。\n\n  * ☑ 两个对象内有相同的属性名字\n\n  * ☑ 在插值语法的括号两侧写入其他内容，如`aaaa{a}aa`\n\n    > 会把两侧的其他内容覆盖掉（已修复）。\n\n### 2\\. 属性插值语法\n\n  * ☑ 常规的属性插值，如`input=\"{a}\"`，其中`a=1`\n\n  * ☑ 不恰当的插值，如input属性需要`number`或`string`等类型的数据，但是插入函数、对象等\n\n  * ☑ 更多插值方式，如插入表达式，插入函数调用，连续调用\n\n    > 同上，暂不打算支持直接插入表达式和函数调用。\n\n  * ☑ 错误的插值，如填写不存在的变量，特殊符号，标签\n\n### 3\\. if系列\n\n（由于`if-else`和`else`暂未上线，所以暂时满足**2.属性插值语法**的标准即可判定为通过）\n\n  * ☑ 满足**2.属性插值语法**中的要求\n\n### 4\\. for循环\n\n  * ☑ 满足**2.属性插值语法**中的要求\n\n  * ☑ 插入非数组元素\n\n    > 对于形如`() => [1]`的值，会无法解析！\n\n    > 但是之前在`data`中直接写函数表达式的话，是能够解析返回值的，所以这里后续最好统一一下。\n\n    > 另外，最好再支持一下下标。\n\n### 5\\. 组件化\n\n  * ☑ 参数传递满足**2.属性插值语法**中的要求\n\n  * ☐ 远程组件\n\n    > 只是试试能不能，不作为必要的测试标准。\n\n  * ☑ 传递多个参数\n\n  * ☑ 组件多级嵌套\n\n  * ☑ 一个父组件多个子组件\n\n  * ☑ 传递连续调用的对象\n\n  * ☑ 传递函数\n\n    > 是比较符合预期的，能够实现组件通信。\n\n    > 不过有个问题是，直接在`script`宏任务中访问`window.mud`是`undefined`，大概是还没有加载上。\n\n    > 只能够异步地调用函数。\n\n  * ☑ 传递同一个变量，以及改个名字之后重复传递\n\n  * ☑ 特殊的组件调用，如父子相互引用，兄弟引用，自己调用自己\n\n    > 自己调用自己：只会进行一次，递归会被阻止。\n\n    > 父子相互引用：被浏览器阻止，子组件引用父组件失败。\n\n### 6\\. 兼容性\n\n  * ☑ 移动端设备\n  * ☑ Chrome/Edge(其他浏览器暂时不用管)","tags":["minvue"],"categories":["进一步学习vue"]},{"title":"前端学习日记","url":"/posts/2025/04/Fronted/学习日记/c4f4b3de.html","content":"\n# 祖传三件套\n\n## html\n我是看的黑马程序员的课, 这个B站上面有很多资源\n建议时间: 三天\n\n## css\n黑马 + 📶学长发的三件套资料\n黑马通俗易懂,;\ncoderwhy讲的更深入, 会涉及许多其他的知识, 听完后可以跟着做一个项目, 巩固css知识,;\n框框css学的比较差, ┭┮﹏┭┮\n\n## JavaScript\nJavaScript就全看的coderwhy发的资料了, 讲的非常的细致, 从es6之前到后面的新版本es.\n个人建议可以把coderwhy的js视频全部看一遍, 重点学习他标注重点的视频\n\n中间如果有看不懂的, 不要急. 掘金上面有很多前端大佬分享的笔记, 可以在上面淘淘. 或者直接问ai. 还能直接在官方文档里面找答案\n学js的时候一定不要急啊, 越急学的越慢, 还学不好\n\n框框学js的时候心态感觉就不好. 现在想来完全没必要啊. 只要每天按部就班的在学, js在暑假之前是能学的差不多的, 心再急也没必要. 希望大家能有一个良好的心态学习, 因为让人崩溃的知识后面还有很多\n\n## 工具篇\n看完js, 恭喜你, 马上就要进入框架的学习了\n后面还有node和工具的学习, 不要急, 你已经离成功不远了\n\n按照我们这届的进度来看, 你们会在期末周的时候学到这(另有卷王我不说)(学的慢一点的贝贝也不用着急, 每个人有自己学习的节奏, 踏踏实实的学号每一步就是最棒的). \n\n这时候的心态就非常的浮躁啊, 本来要放假了, 心就静不下来. 再加上刚学完三件套, 心中成就感满满, 马上要学的这些短时间内又用不上, 学的时候跟三件套扯不上太多关系. buff叠满了\n\n既然学不好了, 那就干脆别学了吧(不是, 我乱说的)\n\n个人推荐一下学习的重点 (yi):\n  - node (全看完)\n  - Es module (全看完)\n  - npm (重点掌握)\n  - webpack(可以只看一半, 后面做项目遇到了再来学习也不迟)\n  - git(重中之重, git远不止这些运用, 还需要在B站上继续进修)\n\n学完这些, 希望前端仔仔们都能拥有一个光明的未来![alt text](image.png)\n\n## 学 vue 前\n\n搭建小兔鲜项目时发现什么都不懂, 个人推荐可以只跟着打完前三天的, 了解项目的基本构造, 之后就可以开始vue的学习啦!\n![[前端了解/小兔鲜/vue项目结构.canvas]]\n\n# 学 vue\n\n学习vue前可以先找一个速通typescript (一二十分钟)来看一看, 后面学vue的时候遇到不会的语法了再去网上找\n\n我当时是看的这个视频<a href=\"https://www.bilibili.com/video/BV1Za4y1r7KE?p=67&vd_source=26eb5025743189cb77f15d6e356b6da3\">【尚硅谷Vue3入门到实战，最新版vue3+TypeScript前端开发教程】https://www.bilibili.com/video/BV1Za4y1r7KE?p=67&vd_source=26eb5025743189cb77f15d6e356b6da3</a>\n暑假的时候学的, 学了十天(内容不多, 但是自己玩玩耍耍, 白天的时候打游戏去了, 只有晚上的时候学了点)\n\n不知道大家学这个的手是什么时候, 按照正常上学时候的速度, 应该能在`5-10`天学完, 拖太长了也不好\n\n# 练习vue\n\n不知道这个时候你们有自己的博客没有\n\n看着学长学姐们自己写的博客, 我是真心动啊, 于是马上安排\n\n在网上找的教程, 用 `hexo` 框架搭了一个博客, 中间出了一些小故障, 请问了学长, 最后也是顺利完成喽. \n\n(可以租一个域名, 在网上看看, 找个便宜点的, 把博客挂在上面)\n\n在就是装饰 + 整理以前的笔记\n\n# 第二次项目\n\n2025-7-10\n学完vue, 第二次搭小兔鲜啦\n\n搭之前在网上找了一圈, 发现现阶段还是这个更合适一些\n\n这个项目不需要多难, 越简单越好, 毕竟是学完vue的第一个项目, 主要目的是过一遍vue的知识点.\n等熟悉完vue在学习新的技术也不迟\n\n## 练习\n2025-8-30\n手写pinia, 在<a href=\"【【面试必备】从零手写Pinia】https://www.bilibili.com/video/BV1PF4m1u78T?vd_source=26eb5025743189cb77f15d6e356b6da3\">B站上找的资源</a>\n","tags":["前端三件套"],"categories":["前端开发"]},{"title":"HTML","url":"/posts/2025/04/Fronted/三件套/01- HTML/2eec1551.html","content":"\n# HTML\n## 标签\n### 语法规范\n#### 基本语法概述\n1.所有标签都包括在<>里面\n2.并且一般情况下<>都成对出现，例如：< html >(开始标签) 和< /html >(结束标签)，称为双标签\n3.有极少数标签必须是单个标签，例如：< br />\n### 标签关系\n包含关系和并列关系\n![[Pasted image 20240415204232.png]]\n![[Pasted image 20240415204710.png]]\n### 基本结构标签\n< html> 和 < /html> 内包含所有内容\n< head> 和< /head> 内包含头部\n即![[Pasted image 20240415215459.png]]\n< title>和< /title> 内包含标题\n即![[Pasted image 20240415215620.png]]\n< body> 和< /body>内包含主要内容\n即![[Pasted image 20240415215711.png]]\n### HTML常用标签\n#### 标题标签\n分为6个等级的网页标题，< h1>-< h6>\n双标签\n如：< h1> < /h1>\n特点：\n1.加了标题的文字会被加粗，字号也会依次变大\n2.一个标题独占一行\n效果：\n![[Pasted image 20240416171114.png]]\n#### 段落和换行标签\n##### 段落标签\n可以将网页分为若干个段落。如：< p> 我是一个段落< /p>\n不加段落标签的效果：\n![[Pasted image 20240416172237.png]]\n![[Pasted image 20240416172253.png]]\n加了段落标签的效果：\n![[Pasted image 20240416172531.png]]\n![[Pasted image 20240416172541.png]]\n特点：\n1、文本在一个段落中会根据浏览器窗口大小自动换行\n如：![[Pasted image 20240416172734.png]]\n\n![[Pasted image 20240416172745.png]]\n\n2、段落和段落之间保有空隙\n##### 换行标签\n让某段文本强制换行显示。 <br />(单标签)\n![[Pasted image 20240416175007.png]]\n![[Pasted image 20240416175016.png]]\n特点：\n1、<br />是单个标签\n2、<br />标签只是简单开始新的一行，与段落不同，段落之间会插入一些间距\n\n#### 文本格式化标签\n把文字 设置粗体、斜体、下划线等效果，突出重要性\n加粗：< strong>< /strong> 或者< b>< /b>\n倾斜：< em>< /em>或者< i>< /i>\n删除线：< del>< /del>或者< s>< /s>\n下划线：< ins>< /ins>或者< u>< /u>\n#### `<div>`和`<span>`标签\n他俩没有语义，它们就是一个盒子，用来装内容\n特点：\n1、`<div>`标签用来布局，但是一行只能放一个`<div>`.是大盒子\n2、`<span>`标签用来布局，一行上可以放多个`<span>`.是小盒子\n![[Pasted image 20240416195917.png]]\n![[Pasted image 20240416195931.png]]\n\n#### 图像标签和路径\n##### 图像标签\n`<img />` 用于定义HTML页面中的图像，是单个标签\n`<img src=\"图像URL\" />`\nsrc是`<img>`标签的必须属性，用于指定图像文件的路径和文件名\n要使用图片在网页中，必须把图片和网页放在同一个文件夹中\n![[Pasted image 20240416201001.png]]\n注意点：\n1、图像标签可以有多个属性，必须写在标签名的后面\n2、属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开\n3、属性的格式：属性=“属性值”\n##### 路径\n1、目录文件夹和根目录\n目录文件夹：普通文件夹，里面存放做页面的相关素材，如html文件、图片等\n根目录：打开目录文件夹的第一层就是根目录\n\n2、路径\n通常建立一个文件夹来储存图像文件，这时查找图像，需要采取“路径”的方式来指定图像文件的位置\n相对路径：\n相对路径是从代码所在的这个文件出发，去寻找目标文件\n![[Pasted image 20240416203015.png]]\n\n绝对路径：\n![[Pasted image 20240416203639.png]]\n#### 超链接标签\n`<a>`标签用于定义超链接，作用是从一个页面链接到另一个页面\n##### 链接的语法格式\n![[Pasted image 20240416204158.png]]\n\n![[Pasted image 20240416204242.png]]\n##### 链接分类\n1、外部链接：例如`<a herf=\"http://www.baidu.com\">百度< /a>`\n2、内部链接：网站内部页面之间的相互链接，直接连接内部页面名称即可，例如：\n`<a herf=\"index.html\">首页< /a>`\n3、空链接：没有确定链接目标，`<a herf=\"#\">首页< /a>`\n4、下载链接：如果herf里面地址是一个文件或者压缩包，会下载这个文件\n5、网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接\n6、锚点链接：当我们点击链接，可以快速定位到页面中的某个位置\n\n\t![[Pasted image 20240416210054.png]]\n### HTML中的注释和特殊字符\n#### 注释\n注释以“<!--\"开头，以“-->\"结束\n![[Pasted image 20240416210352.png]]\n#### 特殊字符\n![[Pasted image 20240416210706.png]]\n\n### 表格标签\n#### 表格的主要作用\n用于显示、展示数据，可以让数据显示的非常规整，可读性非常好。\n#### 表格的基本语法\n1、`<table> </table>`是用于定义表格的标签\n2、`<tr> </tr>`标签用于定义表格中的*行*，必须嵌套在`<table> </table>`标签中\n3、`<td> </td>`用于定义表格中的*单元格*，必须嵌套在`<tr> </tr>`标签中\n4、字母td指表格数据，即数据单元格的内容\n#### 表头单元格标签\n一般表头单元格位于表格的第一列或第一行，表头单元格里面的文本内容*加粗居中*显示\n`<th> </th>`标签表示HTML表格的表头部分\n#### 表格属性\n实际开发不常用，后面通过CSS来设置\n ![[Pasted image 20240416214210.png]]\n 注意：属性写在table里面\n \n#### 表格结构标签\n使用场景：表格可能很长，为了更好表示表格的语义，可以将表格分为表格头部和表格主体两部分\n`<thead>`标签表示表格的头部区域，`<tbody>`标签表示表格的主体区域\n1、`<thead> </thead>`用于定义表格的头部。`<thead>`内部必须拥有`<tr>`标签，一般位于第一行\n2、`<tbody> </tbody>`用于定义表格的主体，主要用于放数据本体\n3、以上标签都是放在`<table> </table>`标签中\n#### 合并单元格\n1、合并单元格的方式\n*跨行合并：rowspan=“合并单元格的个数”\n![[Pasted image 20240416220516.png]]\n\n*跨列合并：colspan=“合并单元格的个数”\n![[Pasted image 20240416220545.png]]\n\n2、目标单元格（写合并代码）\n![[Pasted image 20240416220705.png]]、\n\n3、合并单元格三部曲\n*先确定是跨行还是跨列合并\n找到目标单元格，写上合并方式=合并的单元格数量。如：`<td colspan=\"2\"> </td>\n删除多余单元格*\n### 列表标签\n用来布局\n特点：整齐、整洁、有序\n#### 无序列表\n`<ul> </ul>` 标签表示HTML项目中的无序列表\n`<li> </li>`标签表示列表项\n语法基本格式如下：\n`<ul>\n\t`<li> 列表项1 </li>`\n\t`<li> 列表项2 </li>`\n\t`<li> 列表项3 </li>`\n`</ul>`\n*注意：*\n1、`<ul> </ul>`中只能嵌套`<li> </li>`，直接在`<ul> </ul>`标签中输入其他标签或者文字的做法是不被允许的\n2、`<li> </li>`之间相当于一个容器，可以容纳所有元素\n3、无序列表带有自己的样式属性，但在实际使用时，我们使用CSS来设置\n#### 有序列表\n`<ol> </ol>`标签表示HTML项目中的有序列表\n`<li> </li>`标签表示列表项\n语法基本格式如下：\n`<ol>\n\t`<li> 列表项1 </li>`\n\t`<li> 列表项2 </li>`\n\t`<li> 列表项3 </li>`\n`</ol>`\n*注意：*\n1、`<ol> </ol>`中只能嵌套`<li> </li>`，直接在`<ol> </ol>`标签中输入其他标签或者文字的做法是不被允许的\n2、`<li> </li>`之间相当于一个容器，可以容纳所有元素\n3、有序列表带有自己的样式属性，但在实际使用时，我们使用CSS来设置\n#### 自定义列表\n常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号\n`<dl> </dl>`标签表示HTML项目中的自定义列表\n`<dt> </dt>`标签表示定义项目的名字\n`<dd> </dd>`标签表示描述每一个项目\n语法基本格式如下：\n`<dl>\n\t`<dt> 名词1 </dt>`\n\t`<dd> 名词1解释1 </dd>`\n\t`<dd> 名词1解释2 </dd>`\n`</dl>`\n*注意：*\n1、`<dl> </dl>`里面只能包含`<dt> </dt>`和`<dd> </dd>\n2、`<dt> </dt>`和`<dd> </dd>`个数没有限制，通常是一个`<dt>`对应多个`<dd>`\n### 表单标签\n#### 为什么需要表单\n目的：收集用户信息\n#### 表单的组成\n由*表单域、表单控件（即表单元素）、提示信息*3部分构成\n![[Pasted image 20240417153314.png]]\n\n##### 表单域\n包含表单元素的区域\n`<form> </form>`标签表示定义表单域，以实现用户信息的收集和传递\n*`<form>`会把它范围内的表单元素信息提交给服务器*\n语法基本格式如下：\n`<form action=\"url地址\" method=\"提交方式\" name=\"表单域名称\"`\n\t`各种表单元素控件`\n`</form>`\n![[Pasted image 20240417171730.png]]\n##### 表单控件（表单元素）\n###### `<input>`表单元素\n`<input>`标签用于收集用户信息，是单个标签\n*在`<input>`标签中，包含一个type属性，根据不同的type属性值，输入字段拥有很多种形式（可以是文本、字段、复选框、掩码后的文本控件、单选按钮、按钮等）。*\n语法基本格式如下：\n`<input type = \"属性值\" />`\n\n![[Pasted image 20240417172528.png]]\n\n*除type属性外，`<input>`*标签还有其他很多属性：*\n![[Pasted image 20240417173755.png]]\n*注意：*\n1、name和value是每个表单元素都有的属性值，主要给后台人员使用\n2、name表单元素的名字，要求*单选按钮和复选框要有相同的name值*\n3、checked属性主要针对于单选按钮和复选框，作用是一打开界面就默认选中某个表单元素\n4、maxlength是用户可以在表单元素输入的最大字符数，一般较少使用\n\n![[Pasted image 20240417193415.png]]\n\n![[Pasted image 20240417193426.png]]\n###### `<lable>`标签\n`<label> </label>`标签为input元素定义标签\n`<label>`标签用于绑定一个表单元素，当点击`<label>`标签内的文本时，浏览器会自动将焦点（光标）转到对应的表单元素上，用来增加用户体验\n语法基本格式如下：\n\n`<label for=\"性别\">男</label>`\n`<input type=\"radio\" name=\"sex\" id=\"性别\" />`\n\n*核心：*`<label>`标签的for属性应当与相关元素的id属性相同\n![[Pasted image 20240417194812.png]]\n\n###### `<select>`表单元素\n使用场景：在页面中，如果有多个选择让用户选择，并且想要节约页面空间，我们可以使用`<select>`标签控件定义*下拉列表*\n![[Pasted image 20240417195224.png]]\n\n语法基本格式如下：\n`<select>`\n\t`<option>选项1</option>`\n\t`<option>选项2</option>`\n\t`<option>选项3</option>`\n\t`...`\n`</select>`\n*注意：*\n1、`<select>`中至少包含一对`<option>`\n2、在`<option>`中定义selected=“selected”时，当前项即为默认选中项\n\n![[Pasted image 20240417200003.png]]\n\n![[Pasted image 20240417200023.png]]\n\n###### `<textarea>`表单元素\n使用场景：当用户输入内容较多的情况下，我们使用`<textarea>`标签\n`<textarea>`标签是用于定义多行文本输入的控件\n语法基本格式如下：\n`<textarea rows=\"3\" cols=\"20\">`\n\t`文本内容`\n`</textarea>`\n\n![[Pasted image 20240417201708.png]]\n\n![[Pasted image 20240417201721.png]]\n\n*注意：*\n1、通过`<textarea>`标签可以轻松地创建多行文本输入框\n2、cols=\"每行中的字符数“ ，rows=\"显示的行数”，*我们在实际开发中不会使用，都是用CSS来改变大小*\n\n## HTML5的新特性\n*注意：* 这些新特性都有兼容问题，基本上是IE9+以上版本的浏览器才支持\n### HTML新增的语义化标签\n1、`<header>`头部标签\n2、`<nav>`导航标签\n3、`<article>`内容标签\n4、`section>`定义文档某个区域\n5、`<aside>`侧边栏标签\n6、`<footer>`尾部标签\n\n![[Pasted image 20240417203348.png]]\n\n![[Pasted image 20240417204528.png]]\n\n![[Pasted image 20240417204547.png]]\n\n### HTML5新增的多媒体标签\n#### 视频`<video>`\n当前`<video>`元素支持三种视频格式：MP4，WebM，Ogg。但尽量使用MP4格式，因为几乎所有浏览器都支持\n语法基本格式如下：\n`<video src=\"文件地址\" controls=\"contorls\"> </video>`\n*注意：如果害怕浏览器不支持当前格式，可以参照以下写法*\n\n![[Pasted image 20240417205241.png]]\n\n![[Pasted image 20240417205638.png]]\n\n#### 音频`<audio>`\n当前`<audio>`支持3中音频格式：MP3、Wav、Ogg。但尽量使用MP3格式，因为几乎所有浏览器都支持\n语法基本格式如下：\n`<audio src=\"文件地址\" controls=\"contorls\"> </audio>`\n*注意：如果害怕浏览器不支持当前格式，可以参照以下写法*\n\n![[Pasted image 20240417205926.png]]\n\n![[Pasted image 20240417210200.png]]\n\n### HTML5新增的input标签\n\n![[Pasted image 20240417210434.png]]\n\n\n![[Pasted image 20240417211039.png]]\n、\n![[Pasted image 20240417211048.png]]\n### HTML5新增的表单属性\n![[Pasted image 20240417211533.png]]\n### HTML5新增的全局属性 data-*\n- data-* ，用于自定义数据属性\n\t- data设置的属性可以在JavaScript的DOM操作中 通过**dataset**轻松获取\n\t- 通常用于**HTML和JavaScript数据之间的传递**\n```\n<div class=\"box\" title=\"abc\" data-name=\"why\" data-age=\"18\">\n\tbox\n</div>\n\n<script>\n\tconst boxE1 = document.querySelector(\".box\")\n\tconsole.log(boxE1.dataset)\n</script>\n```\n- *在小程序中，通过data-来传递数据*","tags":["前端三件套"],"categories":["前端开发"]},{"title":"CSS","url":"/posts/2025/04/Fronted/三件套/02- CSS/ee69e452.html","content":"\n# CSS1\n## 简介\n使用场景：美化网页，布局页面\nCSS是一种标记语言\nCSS可以美化HTML，让HTML更漂亮，让页面布局更简单\nCSS最大价值：由HTML专注去做结构呈现，样式交给CSS，即结构与样式相分离\n### 语法规范\n*CSS规则由两个主要的部分构成：选择器以及一条或多条声明*\n基本语法格式如下：\n`选择器 { 属性：值；  属性：值;}`\n*注意：*\n1、选择器是用与指定CSS样式的HTML标签，花括号内是对该对象设置的具体样式\n2、属性和属性值以“键值对”的形式出现\n3、属性是对指定的对象设置的样式属性，例如字体大小，文本颜色等\n4、属性和属性值之间用英文 “:\" 分开\n### CSS代码风格\n#### 样式格式\n1、紧凑格式\n`h3{color:deeppink;font-size:20px;}`\n2、展开格式\n`h3{`\n\t`color:pink;`\n\t`font-size:20px;`\n`}`\n*推荐使用第二种格式*，更直观\n#### 样式大小写\n1、小写\n`h3{`\n\t`color:pink;`\n`}`\n2、大写\n`H3{`\n\t`COLOR:PINK;`\n`}`\n*强烈推荐样式选择器，属性名，属性值关键字全部使用小写字母*，特殊情况除外\n#### 空格规范\n`h3 {`\n\t`color: pink;`\n`}`\n1、属性值前面，冒号后面，保留一个空格\n2、选择器（标签）和大括号之间保留空格\n\n## CSS基础选择器\n\n**CSS选择器的作用**\n选择器（选择符）就是根据不同需求把不同的标签选出来。简单来说，就是*选择标签用的*\n\n**选择器的分类**\n选择器可以分为基础选择器和复合选择器两大类\n### 基础选择器\n基础选择器是由*单个选择器组成*的\n基础选择器又包括：*标签选择器、类选择器、id选择器、通配选择器*\n#### 标签选择器\n标签选择器是指用*HTML标签名称*作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>体验CSS语法规范</title>\n    <style>\n        p {\n            color: skyblue;\n        }\n        div {\n            color: pink;\n        }\n    </style>\n</head>\n<body>\n    <p>有点意思</p>\n    <p>男生</p>\n    <p>男生</p>\n    <div>女生</div>\n    <div>女生</div>\n    <div>女生</div>\n</body>\n</html>\n```\n\n![[Pasted image 20240418211124.png]]\n\n*作用*\n标签选择器可以把某一类标签全部选择出来，比如所有的`<div>`标签\n*优点*\n能快速为页面中同类型的标签统一设置样式\n*缺点*\n不能设计差异化样式，只能选择全部的当前标签\n### 类选择器\n如果想要差异化选择不同的标签，单独选一个或几个标签，可以使用*类选择器*\n语法基本格式如下：\n`.类名 {`\n\t`属性1: 属性值1;`\n\t`...`\n`}`\n结构需要用class属性来调用class类的意思\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>体验CSS语法规范</title>\n    <style>\n        .red {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n    <p class=\"red\">有点意思</p>\n    <p>男生</p>\n    <p>男生</p>\n    <div>女生</div>\n    <div>女生</div>\n    <div class=\"red\">女生</div>\n</body>\n</html>\n```\n\n![[Pasted image 20240418212404.png]]\n\n*注意：*\n1、类选择器使用“.\"（英文点号）进行标识，后面紧跟类名（自定义）\n2、不要使用纯数字、中文等命名\n3、命名要有意义，尽量让别人一眼就知道这个类名的目的\n4、命名规范：\n![[Pasted image 20240418213307.png]]\n\n![[Pasted image 20240418213332.png]]\n![[Pasted image 20240418213405.png]]\n\n*类选择器口诀：* 样式点定义，结构类（class）调用，一个或多个，开发最常用\n#### 类选择器——多类名\n给一个标签指定多个类名，从而达到更多的选择目的。\n1、多类名使用方式\n语法基本格式：\n`<div class=\"red font20\">亚瑟</div>`\n*在标签class属性中写多个类名\n在多个类名中间必须用**空格分开**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>体验CSS语法规范</title>\n    <style>\n        .red {\n            color: red;\n        }\n        .font {\n            font-size: 35px;\n        }\n        .backcolor {\n            background-color: pink ;\n        }\n    </style>\n</head>\n<body>\n    <p class=\"red font backcolor\">有点意思</p>\n</body>\n</html>\n```\n\n![[Pasted image 20240419195421.png]]\n\n2、多类名开发中的使用场景\n*可以把一些标签元素相同的样式（共同的部分）放到一个类里面\n这些标签都可以调用这个公共的类，然后再调用自己独有的类\n从而节省CSS代码，统一修改也非常方便*\n#### id选择器\nid选择器可以为标有特定id的HTML元素指定特定的样式\n*注意：* HTML元素以id属性来设置id选择器，CSS中id属性以 *“#”* 来定义\n语法基本格式：\n`#id名 {`\n\t`属性1：属性值1；`\n\t`...`\n`}`\n例如，将id为nav元素中的内容设置为红色\n`#nav {`\n\t`color: red;`\n`}`\n*口诀：样式#定义，结构id调用，只能调用1次，别人切勿使用*\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>体验CSS语法规范</title>\n    <style>\n        #pink {\n            color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"pink\">小羊计算器</div>\n</body>\n</html>\n```\n\n![[Pasted image 20240419200737.png]]\n\n#### 通配符选择器\nCSS中，通配符选择器使用 *“#”* 定义，*它表示选取页面中的所有元素（标签）*\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>体验CSS语法规范</title>\n    <style>\n        * {\n            color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"pink\">小羊计算器</div>\n    <span>欢迎使用小羊计算器</span>\n    <ul>\n        <li>开始使用</li>\n    </ul>\n</body>\n</html>\n```\n\n![[Pasted image 20240419201910.png]]\n\n*注意：*\n1、通配符选择器不需要调用，自动就给所有的元素使用样式\n2、特殊情况才使用，如清楚所有的元素标签内外边距\n`* {`\n\t`margin: 0;`\n\t`padding: 0;`\n`}`\n### 基础选择器总结\n\n![[Pasted image 20240419202504.png]]\n### 复合选择器\n* 复合选择器可以更准确、更高效的选择目标元素（标签）\n* 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成\n* 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等\n#### 后代选择器（重要）\n*后代选择器*又称*包含选择器*，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代\n语法基本格式：\n`元素1 元素2 {样式声明}`\n上述语法表示*选择元素1里面的所有元素2*（后代元素）\n例如：\n`ul li {样式声明} /* 选择元素1里面的所有元素2 */`\n* 元素1和元素2中间用**空格隔开\n* 元素1是父级，元素2是子级，最终选择的是**元素2**\n* 元素2可以是儿子，也可以是孙子等，只要是元素1的后代即可\n* 元素1和元素2可以是任意基础选择器\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta\n\t\t\tname=\"viewport\"\n\t\t\tcontent=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>体验CSS语法规范</title>\n\t\t<style>\n            ol li {\n                color: pink;\n            }\n            ol li a {\n                color: red;\n            }\n            .nav li a {\n                color: red;\n            }\n        </style>\n\t</head>\n\t<body>\n\t\t<ol>\n            <li>我是ol的孩子</li>\n            <li>我也是</li>\n            <li><a href=\"#\">我是孙子</a></li>\n        </ol>\n        <ul class=\"nav\">\n            <li>我是ul的孩子</li>\n            <li>我是ul的孩子</li>\n            <li>我是ul的孩子</li>\n            <li><a href=\"#\">我是ul的孩子</a></li>\n        </ul>\n\t</body>\n</html>\n\n```\n\n![[Pasted image 20240423165951.png]]\n#### 子选择器（重要）\n\n**子选择器**只能选择作为某元素的最近一级子元素。简单理解就是选亲儿子元素\n语法基本格式：\n`元素1>元素2 {样式声明}`\n上述语法表示**选择元素1里面的所有直接后代（子元素）元素2**\n例如：\n`div > p {样式声明} /* 选择div里面所有最近一级p标签元素 */`\n* 元素1和元素2中间用**大于号**隔开\n* 元素1是父级，元素2是子级。最终选择的是**元素2**\n* 元素2必须是**亲儿子**，其孙子之类都不归他管\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta\n\t\t\tname=\"viewport\"\n\t\t\tcontent=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>体验CSS语法规范</title>\n\t\t<style>\n            .nav > a {\n                color: pink;\n            }\n        </style>\n\t</head>\n\t<body>\n\t\t<div class=\"nav\">\n            <a href=\"#\">我是儿子</a>\n            <p>\n                <a href=\"#\">我是孙子</a>\n            </p>\n        </div>\n\t</body>\n</html>\n\n```\n\n![[Pasted image 20240423170941.png]]\n\n#### 并集选择器\n\n*并集选择器可以选择多组标签，同时为他们定义相同的样式。* 通常用于集体声明\n**并集选择器**是各选择器*通过英文逗号(,)连接而成*，任何形式的选择器都可以作为并集选择器的一部分\n语法基本格式：\n`元素1，元素2 {样式声明}`\n上述语法表示*选择元素1和元素2*\n例如：\n`ul, \n`div {样式声明} /* 选择ul和div标签 */`\n* 元素1和元素2中间用*逗号隔开*\n* 逗号可以理解为*和*的意思\n* 并集选择器通常用于集体声明\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta\n\t\t\tname=\"viewport\"\n\t\t\tcontent=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>体验CSS语法规范</title>\n\t\t<style>\n\t\t\t/* 把熊大熊二改为粉色 */\n\t\t\t/* div,\n\t\t\tp {\n\t\t\t\tcolor: pink;\n\t\t\t} */\n\t\t\t/* 把熊大熊二还有小猪一家改为粉色 */\n\t\t\tdiv,\n\t\t\tp,\n\t\t\t.pig li {\n\t\t\t\tcolor: pink;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div>熊大</div>\n\t\t<p>熊二</p>\n\t\t<span>光头强</span>\n\t\t<ul class=\"pig\">\n\t\t\t<li>小猪佩奇</li>\n\t\t\t<li>猪爸爸</li>\n\t\t\t<li>猪妈妈</li>\n\t\t</ul>\n\t</body>\n</html>\n\n```\n\n![[Pasted image 20240423172936.png]]\n\n#### 伪类选择器\n*伪类选择器*用[[1.图像与计算机视觉类]]于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素\n伪类选择器书写最大的特点是*用冒号(:)表示*，比如 :hover、:first-child\n伪类选择器很多，如链接伪类、结构伪类等\n##### 链接伪类访问器\n\n`a: link /*  选择所有未被访问的链接 */`\n`a: visited /*  选择所有已被访问的链接 ，即已经被访问过的链接的样式*/`\n`a: hover /*  选择鼠标指针位于其上的链接，即鼠标放在链接上样式的改变 */`\n`a: active /*  选择活动链接（鼠标按下未弹起的链接），即按下鼠标时样式的改变 */`\n\n **链接伪类选择器注意事项**\n 1、为了确保生效，请按照**LVHA**的循顺序声明：:link - :visited - :hover - :active\n 2、因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式\n\n**链接伪类选择器实际工作开发中的写法**\n`/* a是标签选择器 所有的链接  */`\n`a {`\n\t`color: gray:`\n`}`\n`/* :hover是链接伪类选择器 鼠标经过 */`\n`a:hover {`\n\t`color: red; /* 鼠标经过的时候，由原来的灰色变成了红色 */`\n`}`\n##### :focus 伪类选择器\n**:focus 伪类选择器**用于选取获得焦点（光标）的表单元素，一般情况`<input>`类表单元素才能获得\n语法基本格式：\n`input:focus {`\n\t`background-color: yellow;`\n`}`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta\n\t\t\tname=\"viewport\"\n\t\t\tcontent=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>体验CSS语法规范</title>\n\t\t<style>\n\t\t\tinput:focus {\n                background: pink;\n                color: red;\n            }\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<input type=\"text\">\n        <input type=\"text\">\n        <input type=\"text\">\n\t</body>\n</html>\n\n```\n\n![[Pasted image 20240423200908.png]]\n\n##### 结构伪类\n###### :nth-child()\n**:nth-child(x)**\n是父元素的第x个子元素\n语法基本格式：\n`元素1 元素2:nth-child(x)`\n上述语法表示选取元素1里面的第x个元素2\n*元素1是元素2的父亲*\n\n**:nth-child(2n)**\n是父元素的第偶数个子元素\n语法基本格式：\n`元素1 元素2:nth-child(2n)`\n上述语法表示选取元素1里面的第偶数个元素2\n*注意：*\n* n代表任意*正整数和0*\n* 是父元素中的第偶数个子元素（第2、4、6、8......个）\n* 跟 :nth-child(even)同义\n\n**:nth-child(2n+1)**\n是父元素的第奇数个子元素\n语法基本格式：\n`元素1 元素2:nth-child(2n+1)`\n*注意：*\n* n代表任意*正整数和0*\n* 是父元素中的第奇数个子元素（第1、3、5、7......个）\n* 跟 :nth-child(odd)同义\n\n**:nth-child(-n+x)**\n是父元素的前x个子元素\n语法基本格式：\n`元素1 元素2:nth-child(-n+x)`\n*表示前x个子元素*\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta\n\t\t\tname=\"viewport\"\n\t\t\tcontent=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>体验CSS语法规范</title>\n\t\t<style>\n\t\t\tul li:nth-child(2n) {\n\t\t\t\tcolor: red;\n\t\t\t}\n\t\t\tul li:nth-child(2n+1){\n\t\t\t\tcolor: pink;\n\t\t\t}\n\t\t\tdiv div:nth-child(6){\n\t\t\t\tcolor: skyblue;\n\t\t\t}\n\t\t\tdiv div:nth-child(-n+3){\n\t\t\t\tcolor: green;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<ul>\n\t\t\t<li>列表元素1</li>\n\t\t\t<li>列表元素2</li>\n\t\t\t<li>列表元素3</li>\n\t\t\t<li>列表元素4</li>\n\t\t\t<li>列表元素5</li>\n\t\t\t<li>列表元素6</li>\n\t\t</ul>\n\t\t<div>\n\t\t\t<div>列表元素1</div>\n\t\t\t<div>列表元素2</div>\n\t\t\t<div>列表元素3</div>\n\t\t\t<div>列表元素4</div>\n\t\t\t<div>列表元素5</div>\n\t\t\t<div>列表元素6</div>\n\t\t\t<div>列表元素7</div>\n\t\t\t<div>列表元素8</div>\n\t\t\t<div>列表元素9</div>\n\t\t\t<div>列表元素10</div>\n\t\t</div>\n\t</body>\n</html>\n\n```\n\n![[Pasted image 20240424164515.png]]\n\n###### :nth-last-child()\n\n:nth-last-child()的语法跟 :nth-child()类似，不同点是 :nth-last-child()从最后一个子元素开始往前计数\n**:nth-last-child(1)** 代表倒数第一个子元素\n**:nth-last-child(-n+2)** 代表最后2个子元素\n###### :nth-of-type()\n\n用法跟 :nth-of-type()类似\n* 不同点是：*:nth-of-type()* 计数时只计算同种类型的元素\n![[Pasted image 20240425182154.png]]\n\n**:nth-last-of-type()** 用法跟 **:nth-of-type()** 类似，只是 **:nth-last-of-type()** 是从最后一个这种类型的子元素开始往前计数\n###### 其他结构伪类\n* **:first-child**，等同于 :nth-child(1)\n* **:last-child**，等同于 :nth-last-child(1)\n* **:first-of-type**，等同于 :nth-of-type(1)\n* **:last-of-type**，等同于 :nth-last-of-type(1)\n* **:only-child**，是父元素中唯一的子元素\n* **:only-of-type**，是父元素中唯一的这种类型的子元素\n* **:root**，根元素，就是html元素\n* **:empty**，代表里面完全空白的元素\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta\n\t\t\tname=\"viewport\"\n\t\t\tcontent=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>体验CSS语法规范</title>\n\t\t<style>\n\t\t\t/* 找寻父级下的子级的第三个，再看第三个是不是div */\n\t\t\tdiv > div:nth-child(3) {\n\t\t\t\tcolor: red;\n\t\t\t}\n\t\t\t/* 找寻父级下的div子级的第三个 */\n\t\t\tdiv > div:nth-of-type(3) {\n\t\t\t\tcolor: red;\n\t\t\t}\n\t\t\t:root {\n\t\t\t\tfont-size: 30px;\n\t\t\t}\n\t\t\t:empty {\n\t\t\t\tbackground-color: pink;\n\t\t\t\twidth: 200px;\n\t\t\t\theight: 300px;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div>\n\t\t\t<div>列表元素1</div>\n\t\t\t<div>列表元素2</div>\n\t\t\t<div>列表元素3</div>\n\t\t\t<div>列表元素4</div>\n\t\t\t<div>列表元素5</div>\n\t\t\t<div>列表元素6</div>\n\t\t\t<div>列表元素7</div>\n\t\t\t<div>列表元素8</div>\n\t\t\t<div>列表元素9</div>\n\t\t\t<div>列表元素10</div>\n\t\t</div>\n\t\t<div></div>\n\t</body>\n</html>\n\n```\n\n![[Pasted image 20240425184246.png]]\n##### 否定伪类\n**:not()** 的格式是 **:not(x)**\n* x是一个简单选择器\n* 元素选择器、通用选择器、属性选择器、类选择器、id选择器、伪类（除否定伪类）\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta\n\t\t\tname=\"viewport\"\n\t\t\tcontent=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>体验CSS语法规范</title>\n\t\t<style>\n\t\t\t/* 除item外的其他元素 */\n\t\t\tdiv :not(.item) {\n\t\t\t\tcolor: skyblue;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div>\n\t\t\t<div class=\"item\">元素列表1</div>\n\t\t\t<div class=\"item\">元素列表2</div>\n\t\t\t<div class=\"item\">元素列表3</div>\n\t\t\t<div class=\"yjy\">元素列表1</div>\n\t\t\t<div class=\"yjy\">元素列表2</div>\n\t\t\t<div class=\"yjy\">元素列表3</div>\n\t\t\t<div class=\"qxy\">元素列表1</div>\n\t\t\t<div class=\"qxy\">元素列表2</div>\n\t\t\t<div class=\"qxy\">元素列表3</div>\n\t\t</div>\n\t\t<div></div>\n\t</body>\n</html>\n```\n\n![[Pasted image 20240425185747.png]]\n#### 复合选择器总结\n\n![[Pasted image 20240423201023.png]]\n\n## CSS字体属性\nCSS Fonts（字体）属性用于定义*字体系列、大小、粗细、文字样式*\n### 字体系列\nCSS使用*font-family*属性定义文本的字体系列\n语法基本格式：\n`p {`\n\t`font-family: \"微软雅黑\";`\n`}`\n`div {`\n\t`font-family: Arial, \"Microsoft Yahei\", \"微软雅黑\";`\n`}`\n*注意：*\n1、各种字体之间必须使用英文状态下的逗号搁开(前一个字体不能显示，自动看下一个字体)\n2、一般情况下，如果有空格隔开的多个单词组成的字体，加引号\n3、尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\n4、最常见的几个字体：body{font-family: 'Microsoft Yahei', tahoma, arial, 'Hiragino Sans GB'; }\n### 字体大小\nCSS使用*font-size*属性定义字体大小\n语法基本格式如下：\n`p {`\n\t`font-size: 20px;`\n`}`\n*注意：*\n1、px（像素）大小是我们网页的最常用的单位\n2、谷歌浏览器默认的文字大小为16px\n3、不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小\n4、可以给body指定整个界面文字大小（但标题比较特殊，需要单独指定）\n### 字体粗细\nCSS使用font-weight属性设置文本字体的粗细\n语法基本格式：\n`p {`\n\t`font-weight: bold;`\n`}`\n\n![[Pasted image 20240419210053.png]]\n*注意：*\n1、学会让加粗标签（比如h和strong等）不加粗，或者其他标签加粗\n2、实际开发时，我们更喜欢用数字表示粗细\n### 文字样式\nCSS使用*font-style*属性设置文本的风格\n语法基本格式：\n`p {`\n\t`font-style: normal;`\n`}`\n\n![[Pasted image 20240419212958.png]]\n*注意：* 平时我们很少给文字加斜体，反而要给斜体标签（em, i）改为不倾斜字体\n### 字体复合属性\n语法基本格式：\n`body {`\n\t`font: font-style font-weight font-size/line-height font-family;`\n`}`\n*注意：* \n1、使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开\n2、不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性不起作用\n\n### 总结\n![[Pasted image 20240419215118.png]]\n## CSS文本属性\nCSS Text（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等\n### 文本颜色\n`color`属性用于定义文本颜色\n\n语法基本格式：\n`div {`\n\t`color: red;`\n`}`\n\n![[Pasted image 20240421155234.png]]\n*开发中最常用的是16进制*\n\n### 对齐文本\n`text-align`属性用于设置元素内文本内容的*水平*对齐方式\n语法基本格式：\n`div {`\n\t`text-align: center;`\n`}`\n\n![[Pasted image 20240421174347.png]]\n\n*注意：* 想要图片居中对齐，需要把图片放在一个p标签内，再给p标签添加水平居中对齐\n### 装饰文本\n`text-decoration`属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等\n\n![[Pasted image 20240421175228.png]]\n*最常用于取消a链接自带的下划线*\n### 文本缩进\n`text-indent`属性用来指定文本的第一行的缩进，通常是将*段落的首行缩进*\n语法基本格式：\n1、\n所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值\n`div {`\n\t`text-indent: 10px;`\n`}`\n2、\nem是一个相对单位，就是当前元素（font-size）1个文字的大小，如果当前元素没有设置大小，则会按照父元素的一个文字大小\n`p {`\n\t`text-indent: 2em;`\n`}`\n### 行间距\n`line-height`属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。\n语法基本格式：\n`p {`\n\t`line-height: 26px;`\n`}`\n\n![[Pasted image 20240421210855.png]]\n\n### 总结\n\n![[Pasted image 20240421211545.png]]\n## CSS引入方式\n### CSS的三种样式表\n1、行内样式表（行内式）\n2、内部样式表（嵌入式）\n3、外部样式表（链接式）\n#### 内部样式表\n内部样式表（内嵌样式表）是写在HTML页面内部，是将所有的CSS代码抽取出来，单独放在一个 `<style>`标签中。\n语法基本格式：\n`<style>`\n\t`div {`\n\t\t`color: red;`\n\t\t`font-size: 12px;`\n\t`}`\n`<style>`\n特点：\n* `<style>`标签理论上可以放在HTML文档的任何地方，*但一般会放在文档的`<head>`标签中 *\n* 通过此方式，可以方便控制当前整个页面中的元素样式设置\n* 代码结构清晰，但是并没有实现结构与样式完全分离\n* 使用内部样式设定CSS，通常也被称为*嵌入式引入*，这种方式是我们练习时常用的方式\n#### 行内样式表\n行内样式表（内联样式表）是在*元素内部的style属性中设定CSS样式*，适用于修改简单样式\n语法基本格式：\n`<div style=\"color: red; font-size: 12px;\">欢迎使用小羊计算器</div>`\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>体验CSS语法规范</title>\n</head>\n<body>\n    <h1 style= \"color: pink;\">小羊计算器</h1>\n    <span>欢迎使用小羊计算器</span>\n    <ul>\n        <li>开始使用</li>\n    </ul>\n</body>\n</html>\n```\n\n![[Pasted image 20240422195751.png]]\n注意：\n* style其实就是标签的属性\n* 在双引号之间，写法要符合CSS规范\n* 可以控制当前的标签设置样式\n* 不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用\n* 使用行内样式表设定CSS，通常也被称为*行内式引入*\n#### 外部样式表\n实际开发都是外部样式表，适用于样式比较多的情况，核心是：*样式单独写在CSS文件中，之后把CSS文件引入到HTML页面中使用*\n引入外部样式表的步骤：\n1、新建一个后缀名为 .css 的样式文件，把所有的CSS代码都放入此文件中\n2、在HTML页面中，使用`<link>`标签引入这个文件\n\t语法基本格式：`<link rel=\"stylesheet\" href=\"css文件路径\">`\n\n![[Pasted image 20240422201307.png]]\n\n* 使用外部样式表设定CSS，通常也被称为*外链式或外链式引入*，是开发中最常用的方式\n#### 总结\n\n![[Pasted image 20240422201605.png]]\n## Chrome调试工具使用\n### 1. 打开调试工具\n打开Chrome浏览器，按下F12键或者点击页面空白处->检查\n### 2、使用调试工具\n1. Ctrl+滚轮可以放大开发者代码大小\n2. 左边是HTML结构，右边是CSS样式\n3. 右边CSS样式可以改动数值和查看颜色\n4. Ctrl+0复原浏览器大小\n5. 如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误\n6. 如果有样式，但是样式前面有黄色感叹号提示，则是样式属性书写错误\n# CSS2\n## Emmet语法\nEmmet语法前身是Zen coding, 它使用缩写来提高HTML/CSS的编写速度，Vscode内部已经集成该语法。\n### 快速生成HTM结构语法\n1、生成标签，直接输入标签名，按tab键即可 比如 div 然后tab键，就可以生成`<div> </div>`\n2、如果想要生成多个相同标签 加上 * 就可以了 比如 div * 3 就可以快速生成3个div\n3、如果有父子级关系的标签，可以用 > 比如 ul > li就可以了\n4、如果有兄弟关系的标签，用+就可以了 比如 div+p\n5、如果生成带有类名或者id名字的，直接写 .demo 或者 #two  tab键就可以了\n6、如果生成的div类名是有顺序的，可以用自增符号 ￥\n7、如果想要在生成的标签内部写内容可以用{ }表示\n### 快速生成CSS样式语法\nCSS基本采取简写模式形式即可。\n1、比如 w200 按tab键可以生成 width: 200px;\n2、比如lh26 按tab键可以生成 line-height: 26px;\n## CSS的元素显示模式\n### 什么是元素显示模式\n\n作用：网页的标签非常多，在不同的地方会用到不同类型的标签，了解他们的特点*可以更好的布局我们的网页*\n元素显示模式就是*元素（标签）以什么方式进行显示*，比如`<div>`自己占一行，比如一行可以放多个`<span>`\nHTML元素一般分为*块元素*和*行内元素*两种类型\n### 块元素\n\n常见的块元素有`<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>`等，其中`<div>`元素是最典型的块元素\n块级元素的特点：\n1. 自己独占一行\n2. 高度、宽度、外边距以及内边距都可以控制\n3. 宽度默认是容器（父级宽度）的100%\n4. 是一个容器及盒子，里面可以放行内或者块级元素\n**注意：**\n* 文字类的元素内不能使用块级元素\n* `<p>`标签主要用于存放文字，因此`<p>`里面不能放块级元素，特别是不能放`<div>`\n* 同理，`<h1>~<h6>`等都是文字类块级标签，里面也不能放其他块级元素\n### 行内元素\n\n常见的行内元素有`<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>`等，其中`<span>`标签是*最典型的行内元素*。\n行内元素的特点：\n1. 相邻行内元素在一行上，一行可以显示多个\n2. 高、宽直接设置是无效的\n3. 默认宽度就是它本身内容的宽度\n4. 行内元素只能容纳文本或其他行内元素\n**注意：**\n* 链接里面不能再放链接\n* 特殊情况链接`<a>`里面可以放块级元素，但是给`<a>`转换一下块级模式最安全\n### 行内块元素\n\n在行内元素中有几个特殊的标签——`<img />、<input />、<td>`，它们*同时具有块元素和行内元素的特点*。\n行内块元素的特点：\n1. 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）\n2. 默认宽度就是它本身内容的宽度（行内元素特点）\n3. 高度、行高、外边距以及内边距都可以控制（块级元素特点）\n### 如何指定元素的显示类型\n\n`display`属性用于指定元素的显示类型\n常见的display属性值及其含义：\n1. `block`：将元素呈现为块级元素。块级元素会独占一行，并且默认情况下会在前后添加换行符。常见的块级元素包括`<div>`、`<p>`、`<h1>`-`<h6>`等。\n\n2. `inline`：将元素呈现为内联元素。内联元素不会独占一行，而是与其他元素在同一行内显示，并根据内容自动收缩。常见的内联元素包括`<span>`、`<a>`、`<strong>`、`<em>`等。\n\n3. `inline-block`：将元素呈现为内联块级元素。内联块级元素与内联元素类似，可以与其他元素在同一行内显示，但可以设置宽度、高度和内外边距。常见的内联块级元素包括`<img>`、`<button>`等。\n\n4. `none`：将元素隐藏，不在页面中显示。隐藏后的元素不占据空间。\n\n5. `flex`：将元素呈现为弹性盒子。通过使用弹性盒子布局，可以方便地创建灵活的、自适应的布局。常见的弹性盒子属性包括`flex-direction`、`justify-content`、`align-items`等。\n\n6. `grid`：将元素呈现为网格容器。使用网格布局可以将页面划分为行和列，并使元素在网格中进行布局。常见的网格属性包括`grid-template-columns`、`grid-template-rows`、`grid-gap`等。\n\n### 总结\n\n![[Pasted image 20240423213701.png]]\n\n# CSS3（布局）\n## CSS元素定位\n### 标准流（Normal Flow）\n* 默认情况下，元素都是按照**normal flow** 进行排布\n\t* **从左到右、从上到下**按顺序摆放好\n\t* 默认情况下，**互相之间不存在层叠现象**\n#### margin-padding位置调整\n* 在标准流中，可以使用**margin、padding**对元素进行定位\n\t* 其中margin还可以设置负数\n* 缺点：\n\t* 设置一个元素的**margin或者padding**，通常会*影响标准流中其他元素*的定位效果\n\t* *不便于实现元素叠层效果*\n* 如果希望一个元素跳出标准流，单独的对某个元素进行定位\n\t* 可以通过**position属性**来进行设置\n### 相对定位\n#### 认识元素定位\n* 定位允许你从**正常的文档流布局中取出元素**，并使它们具有不同的行为\n\t* 例如*放在另一个元素上面*\n\t* 或者*始终保持在浏览器视窗内的同一位置*\n* 定位在开发中非常常见\n\n\t![[Pasted image 20240426210030.png]]![[Pasted image 20240426210100.png]]\n\t![[Pasted image 20240426210111.png]]\n#### 认识position属性\n* 利用position属性可以对元素进行定位，常用取值有5个：\n\tstatic、relative、absolute、sticky、fixed\n* 默认值：\n\t* **static**：默认值，静态定位\n* 使用下面的值，可以让元素变成定位元素：\n\t* **realtive**：相对定位\n\t* **absolute**：绝对定位\n\t* **fixed**：固定定位\n\t* **sticky**：粘性定位\n语法基本格式：\n`position: realtive;`\n\n**position值比对**\n![[Pasted image 20240427175031.png]]\n\n#### 静态定位- static\n* position属性的默认值\n\t* 元素按照**normal flow**布局\n\t* **left、right、top、bottom**没有任何作用\n#### 相对定位-relative\n* 元素按照*normal Flow*布局\n* 可以通过**left、right、top、bottom**进行定位\n\t* 定位*参照对象*是元素*自己原来的位置*\n* left、right、top、bottom用来设置元素的具体位置，对元素的作用如下图所示：\n\n\t![[Pasted image 20240426212721.png]]\n\t\n* 相对定位的应用场景\n\t* 在*不影响其他元素位置的前提*下，对*当前元素位置进行微调*\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .box {\n            /* 相对定位 */\n            position: relative;\n            left: 30px;\n            bottom: 50px;\n    }\n    </style>\n</head>\n<body>\n    <span>我是span元素</span>\n    <strong class=\"box\">我是strong元素</strong>\n    <img src=\"../pct/pic.jpeg\" alt=\"\">\n    <div>我是div元素</div>\n</body>\n</html>\n```\n\n![[Pasted image 20240426213008.png]]\n\n练习：写3的平方+2的三次方=17这个式子：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        span {\n            /* 把指数缩小一点 */\n            font-size: 12px;\n            /* 位置调整为相对定位 */\n            position: relative;\n            /* 向上移 */\n            bottom: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <!-- 3的平方+2的三次方=17 -->\n        3<span>2</span> + 2<span>3</span> = 17\n    </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240426213542.png]]\n\n\n### 固定定位-fixed\n* 元素*脱离normal flow*(脱离标准流、脱标)\n* 可以通过**left、right、top、bottom**进行定位\n* 定位参照对象是视口（viewport）\n* 当画布滚动时，固定不动\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        span {\n            position: fixed;\n            bottom: 20px;\n            right: 20px;\n        }\n    </style>\n</head>\n<body>\n    <div>我是div</div>\n    <span>我是span</span>\n    <img src=\"./photo/OIP.jpg\" alt=\"\">\n</body>\n</html>\n```\n\n![[Pasted image 20240427145731.png]]\n\n#### 画布和视口\n\n![[Pasted image 20240427150152.png]]\n\n* 视口：\n\t* 文档的可视区域\n\t* 如上图*红框*所示\n* 画布：\n\t* 用于渲染文档的区域\n\t* 文档内容超出视口范围，可以通过滚动查看\n\t* 如上图*黑框*所示\n* 宽高对比：\n\t* 画布 >= 视口\n练习：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .handel {\n            /* 固定位置 */\n            position: fixed;\n            right: 30px;\n            bottom: 30px;\n        }\n        .handel .item {\n            width: 80px;\n            height: 40px;\n            /* 文字居中 */\n            text-align: center;\n            /* 文字高度 */\n            line-height: 40px;\n            /* 背景颜色 */\n            background-color: rgb(89, 90, 91);\n            /* 字体颜色 */\n            color: #fff;\n            /* 角落的角圆半径 */\n            border-radius: 8px;\n            /* 鼠标放上去时，光标变成小手 */\n            cursor: pointer;\n        }\n        /* 鼠标放上去时改变背景颜色 */\n        .handel .item:hover {\n            background-color: pink;\n        }\n        /* 间隔 */\n        .top {\n            margin-bottom: 10px;\n        }\n\n    </style>\n</head>\n<body>\n    <div class=\"handel\">\n        <div class=\"item top\">顶部</div>\n        <div class=\"item bottom\">反馈</div>\n    </div>\n    <br><br><br><br><br><br>\n    <br><br><br><br><br><br>\n    <br><br><br><br><br><br>\n    <br><br><br><br><br><br>    \n    <br><br><br><br><br><br>   \n    <br><br><br><br><br><br>  \n    <br><br><br><br><br><br>  \n    <br><br><br><br><br><br>\n</body>\n</html>\n```\n\n![[Pasted image 20240427163004.png]]\n### 绝对定位-absolute\n\n* 元素脱离normal flow\n* 可以通过**left、right、top、bottom**进行定位\n\t* 定位参照对象是*最邻近的**定位**祖先元素*\n\t* 如果*找不到这样的祖先，参照对象是视口*（这时候跟固定定位类似）\n* 定位元素\n\t* position值不为*static*的元素\n\t* 也就是position值为relative、absolute、fixed的元素\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        strong {\n            /* 脱离标准流 */\n            position: absolute;\n            top: 0;\n            right: 0;\n        }\n        .box {\n            width: 700px;\n            height: 500px;\n            background-color: pink;\n            /* 给div设置定位 */\n            position: relative;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"box\">\n        <span>我是span元素</span>\n        <strong>我是strong元素</strong>\n        <img src=\"./photo/OIP.jpg\" alt=\"\">\n    </div>\n    <div>我是div元素</div>\n</body>\n</html>\n```\n\n![[Pasted image 20240427172357.png]]\n\n* 在绝大多数情况下，子元素的**绝对定位都是相对于父元素进行定位**\n* 如果希望子元素相对于父元素进行定位，又不希望父元素脱标，常用解决方案：\n\t* 父元素设置*position:relative*（让父元素成为定位元素，而且父元素不脱离标准流）\n\t* 子元素设置*position:absolute*\n\t* 简称：子绝父相\n#### 将position设置为absolute/fixed元素的特点（一）\n* 可以随意设置宽度、高度\n* 高度默认由内容决定\n* 不再受标准流的约束\n\t* 不再严格按照*从上到下、从左到右*排布\n\t* 不再*严格区分块级、行内级，行内块级的很多特性*都会消失\n* 不再给父元素汇报宽高数据\n#### 将position设置为absolute/fixed元素的特点（二）\n* 绝对定位元素\n\t* position值为*absolute/fixed*的元素\n* 对于绝对定位元素来说\n\t* 定位参照对象的宽度 = left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度\n\t* 定位参照对象的高度 = top + bottom + margin-top + margin-bottom + 绝对定位元素的实际占用高度\n* 如果希望绝对定位元素的宽高和定位参照对象一样，可以给绝对定位元素设置以下属性\n\t* left：0、right：0、top：0、bottom：0、margin：0\n* 如果希望绝对定位元素在定位参照对象中居中显示，可以给绝对定位元素设置以下属性\n\t* left：0、right：0、top：0、bottom：0、margin：auto\n\t* 另外，还得*设置具体的宽高值*（小于定位参照对象的宽高）\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .box {\n            height: 500px;\n            width: 800px;\n            background-color: pink;\n            position: relative;\n        }\n        /* 设置居中显示，且不存在兼容性问题*/\n        /* 上下偏移量相等，左右偏移量相等，margin设置为auto会使剩余空间平均分配到左右两侧和上下两侧 */\n        .containter {\n            height: 200px;\n            width: 200px;\n            background-color: #d8afaf;\n            position: absolute;\n            left: 0;\n            right: 0;\n            top: 0;\n            bottom: 0;\n            margin: auto;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"box\">\n        <div class=\"containter\"></div>\n    </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240428170130.png]]\n\n练习：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        /* 去除链接原有样式 */\n        a {\n            text-decoration: none;\n            color: black;\n        }\n\n        .item {\n            width: 140px;\n            margin: 0 auto;\n        }\n        /* 设置为定位元素 */\n        .item .top {\n            position: relative;\n        }\n\n        .item .top img{\n            /* 去除图片下面多出来的区域 */\n            display: block;\n        }\n        /* 添加背景覆盖图片 */\n        .item .top .cover {\n            position: absolute;\n            top: 0;\n            bottom: 0;\n            left: 0;\n            right: 0;\n            background-image: url(./photo/coverall.png);\n            background-position: 0 0;\n        }\n\n        .item .top .info {\n            position: absolute;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            height: 27px;\n            line-height: 27px;\n            padding-left: 10px;\n            font-size: 12px;\n            color: #ccc;\n            background-image: url(./photo/coverall.png);\n            background-position: 0 -537px;\n        }\n\n        .item .top .info .icon {\n            position: relative;\n            top: 1px;\n            display: inline-block;\n            width: 14px;\n            height: 11px;\n            /* 设置间距 */\n            margin-right: 4px;\n            background-image: url(./photo/iconall.png);\n            background-position: 0 -24px;\n        }\n\n        .item .bottom {\n            display: block;\n            margin-top: 8px;\n            font-size: 14px;\n        }\n\n        .item .bottom:hover {\n            text-decoration: underline;\n        }\n\n    </style>\n</head>\n<body>\n    <div class=\"item\">\n        <div class=\"top\">\n            <img src=\"./photo/wy.01.jpg\" alt=\"\">\n            <a class=\"cover\" href=\"#\"></a>\n            <div class=\"info\">\n                <i class=\"icon\"></i>\n                <span class=\"count\">4999万</span>\n            </div>\n        </div>\n        <a class=\"bottom\" href=\"#\">\n            无前奏 | 欧美女声 | 三秒爱上\n        </a>\n\n    </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240428190122.png]]\n#### left.......属性和margin-left......的区别\n1. 定位属性 vs 外边距属性：\n   - `left`、`right`、`top`、`bottom`是用于定位元素的属性，通常与`position`属性（如`relative`、`absolute`、`fixed`）一起使用。\n   - `margin-left`、`margin-right`、`margin-top`、`margin-bottom`是用于设置元素的外边距的属性。\n\n2. 控制位置 vs 控制间距：\n   - `left`、`right`、`top`、`bottom`属性用于控制元素相对于其包含块的位置，分别表示元素的左、右、上、下偏移量。\n   - `margin-left`、`margin-right`、`margin-top`、`margin-bottom`属性用于控制元素与其相邻元素之间的间距，分别表示元素的左、右、上、下外边距的大小。\n\n3. 值的类型：\n   - `left`、`right`、`top`、`bottom`属性可以使用具体的长度值（如像素、百分比）或关键字（如`auto`）来指定偏移量。\n   - `margin-left`、`margin-right`、`margin-top`、`margin-bottom`属性也可以使用具体的长度值或关键字。\n\n4. 应用方式：\n   - `left`、`right`、`top`、`bottom`属性通常用于定位元素的具体位置，例如将元素相对于包含块的左上角或右下角进行定位。\n   - `margin-left`、`margin-right`、`margin-top`、`margin-bottom`属性主要用于控制元素与其相邻元素之间的间距，例如设置元素与其相邻元素的水平或垂直间距。\n\n**需要注意的是:**`left`、`right`、`top`、`bottom`属性通常与`position`属性一起使用，而`margin-left`、`margin-right`、`margin-top`、`margin-bottom`属性可以在任何情况下使用。另外，定位属性（如`relative`、`absolute`、`fixed`）会影响`left`、`right`、`top`、`bottom`属性的行为，而外边距属性不受定位属性的影响。\n#### width：auto\nauto是什么：交由浏览器处理，自动调整\n- 行内非替换元素 -> width: 包裹内容\n- 块级元素 -> width: 包含块的宽度\n- 绝对定位元素 -> width: 包裹内容\n### 粘性定位-sticky\n- 可以看做是*相对定位和绝对定位的结合体*\n- 它允许被定位的元素*表现得像相对定位一样*，直到它滚动到某个阈值点\n- 当*达到阈值点*时，就会*变成绝对定位*\n- sticky是相对于最近的包含滚动视口的滚动祖先\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .box {\n            height: 300px;\n            width: 500px;\n            margin: 100px auto 0;\n            /* 元素内容溢出时，显示滚条 */\n            overflow: scroll;\n\n        }\n\n        .nav {\n            position: sticky;\n            background-color: pink;\n            /* 距离上方0的时候变成绝对定位 */\n            top: 0;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"box\">\n        <h1>我是标题</h1>\n        <div class=\"nav\">\n            <span>电脑</span>\n            <span>手机</span>\n            <span>衣服</span>\n            <span>鞋子</span>\n        </div>\n        <ul>\n            <li>电脑列表1</li>\n            <li>电脑列表2</li>\n            <li>电脑列表3</li>\n            <li>电脑列表4</li>\n            <li>电脑列表5</li>\n            <li>电脑列表6</li>\n            <li>电脑列表7</li>\n            <li>电脑列表8</li>\n            <li>电脑列表9</li>\n            <li>电脑列表10</li>\n            <li>电脑列表11</li>\n            <li>电脑列表12</li>\n            <li>电脑列表13</li>\n            <li>电脑列表14</li>\n            <li>电脑列表15</li>\n            <li>电脑列表16</li>\n            <li>电脑列表17</li>\n            <li>电脑列表18</li>\n            <li>电脑列表19</li>\n            <li>电脑列表20</li>\n        </ul>\n    </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240430171525.png]]\n## CSS属性 - z - index\n\n- `z-index`属性用来设置定位元素的**层叠顺序**（仅对定位元素有效）\n\t- 取值可以是*正整数、负整数、0*\n- 比较原则\n\t- 如果是*兄弟关系*\n\t\t-   *z-index越大，层叠在越上面*\n\t\t- *z-index相等，写在后面的那个元素层叠在上面*\n\t- 如果*不是兄弟关系*\n\t\t- 各自*从元素自己以及祖先元素中，找出最邻近的2个定位元素进行比较*\n\t\t- 而且*这2个定位元素必须设置z-index的具体数值*\n\t\t- 父元素的 `z-index` 值会影响其子元素的堆叠顺序。如果父元素的 `z-index` 值较低，那么子元素即使具有较高的 `z-index` 值，也无法覆盖其他父元素的内容。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .item {\n            height: 100px;\n            width: 100px;\n            position: fixed;\n        }\n        .box1 {\n            background-color: pink;\n            z-index: 1;\n        }\n\n        .box2 {\n            background-color: skyblue;\n            left: 20px;\n            top: 20px;\n        }\n\n        .box3 {\n            background-color: greenyellow;\n            left: 40px;\n            top: 40px;\n        }\n    </style>\n</head>\n<body>\n        <div class=\"item box1\">1</div>\n        <div class=\"item box2\">2</div>\n        <div class=\"item box3\">3</div>\n</body>\n</html>\n```\n\n![[Pasted image 20240430184648.png]]\n## CSS元素浮动\n### 认识浮动\n- `float`属性可以指定一个元素应*沿其容器的左侧或右侧放置*，允许*文本和内联元素环绕它*\n- 绝对定位、浮动都会让元素脱离标准流，以达到灵活布局的效果\n- 可以通过float属性让元素产生浮动效果，float的常用取值\n\t- **none**：不浮动，默认值\n\t- **left**：向左浮动\n\t- **right**：向右浮动\n### 浮动的规则\n\n- 规则一\n\t- 元素一旦浮动后，脱离标准流\n\t\t- 朝着*向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止*\n\t\t- *定位元素会层叠在浮动元素上面*\n\n![[Pasted image 20240430200108.png]]\n- 规则二\n\t- 如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出*包含块）* 的左（右i）边界\n- 规则三\n\t- 浮动元素之间不能层叠\n\t\t- 如果一个元素浮动，另一个元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素（左浮找左浮，右浮找右浮）\n\t\t- 如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止\n- 规则四\n\t- 浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出（如行内级元素、inline-block元素、块级元素的文字内容）\n![[Pasted image 20240430200705.png]]\n- 规则五\n\t- 行内级元素、inline-block元素浮动后，其顶部将与所在行的顶部对齐\n**可以利用将所有子元素向同一个方向浮动来解决子元素间的间隙问题**\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .containter {\n            width: 500px;\n            height: 300px;\n            background-color: pink;\n            margin: 100px auto;\n        }\n        .box1 {\n            background-color: skyblue;\n            float: left;\n        }\n        .box2 {\n            background-color: greenyellow;\n            float: right;\n        }\n        .box3 {\n            background-color: blanchedalmond;\n            float: left;\n        }\n        .info {\n            width: 300px;\n            height: 100px;\n            background-color: rgb(155, 202, 215);\n            margin: auto;\n        }\n        .ht {\n            width: 100px;\n            height: 50px;\n            background-color: brown;\n            float: left;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"containter\">\n        <div class=\"item box1\">1</div>\n        <div class=\"item box2\">2</div>\n        <div class=\"item box3\">3</div>\n        <div class=\"info\">\n            <div class=\"ht\"></div>\n            我是div我是div我是div我是div我是div我是div我是div我是div我是div我是div\n        </div>\n    </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240430201831.png]]\n\n### 浮动的问题-高度塌陷\n- 由于浮动元素脱离了标准流，变成了脱标元素，所以**不再向父元素汇报高度**\n\t- 父元素*计算总高度*时，就*不会计算浮动子元素的高度*，导致高度塌陷的问题\n- 解决父元素高度塌陷问题的过程，一般叫做**清浮动（清理浮动、清除浮动）\n- 清浮动的目的是让*父元素计算总高度时，把浮动子元素的高度算进去\n- 如何清除浮动？使用clear属性\n## CSS属性-clear\n\n- clear属性是做什么的？\n\t- clear属性可以指定一个元素*是否必须移动*（清除浮动后）*到在它之前的浮动元素*下面\n- clear的常用取值\n\t- **left**：要求元素的顶部低于之前生成的所有左浮动元素的底部\n\t- **right**：要求元素的顶部低于之前生成的所有右浮动元素的底部\n\t- **both**：要求元素的顶部低于之前生成的所有浮动元素的底部\n\t- **none**：默认值，无特殊要求\n\n**清理浮动的方法**：给父元素添加**after伪元素**：\n```html\n元素::after {\n\tcontent: \"\";\n\tclear: both;\n\tdisplay: block;\n\t/*提高浏览器兼容性*/\n\tvisibility: hidden;\n\theight: 0;\n}\n元素 {\n\t*zoom: 1;/*IE6/7兼容性*/\n}\n```\n\n## CSS flex布局\n[CSS Flexbox 布局指南 |CSS 技巧](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\n### 认识flex布局\n- flexbox翻译为弹性盒子\n\t- *弹性盒子*是一种用于*按行或按列布局元素的唯一布局方法*\n\t- 元素可以*膨胀以填充额外的空间，收缩以适应更小的空间*\n\t- 通常我们使用flexbox来进行布局的方案称之为*flex布局*\n- flex布局是目前web开发中使用最多的布局方案\n\t- 目前特别在*移动端*可以说已经完全普及\n\t- 在*pc*端也几乎完全普及和使用，只有*非常少数的网站依然在用浮动来布局*\n### felx布局的重要概念\n- 两个重要概念\n\t- 开启了flex布局的元素叫**flex containter**\n\t- flex containter里面的直接子元素叫做**flex item**\n![[Pasted image 20240501213649.png]]\n- 当flex containter中的子元素变成了flex item时，具备以下特点\n\t- flex item的布局将受*flex containter属性的设置来进行控制和布局*\n\t- flex item*不再严格区分块级元素和行内级元素*\n\t- flex item*默认情况下是包裹内容的，但是可以设置宽度和高度*\n- 设置display属性为flex或者inline-flex可以成为flex containter\n\t- **flex**：flex containter以**block-level**形式存在\n\t- **inline-flex**：flex containter以**inline-level**形式存在\n### flex布局的模型\n![[Pasted image 20240501214659.png]]\n### flex相关的属性\n- 应用在flex containter上的CSS属性\n\t- flex-flow\n\t- flex-direction\n\t- flex-wrap\n\t- justify-content\n\t- align-items\n\t- align-content\n- 应用在flex items上的CSS属性\n\t- flex-grow\n\t- flex-basis\n\t- flex-shrink\n\t- order\n\t- align-self\n\t- flex\n#### flex-containter\n##### flex-direction\n- flex items 默认都是沿着main axis（主轴）从main start开始往main end方向排布\n\t- **flex-direction**决定了**main axis** 的方向，有四个取值\n\t- **row(默认值)、row-reverse、column、column-reverse**\n![[Pasted image 20240501220522.png]]\n##### flex-wrap\n- flex-wrap决定了flex containter是单行还是多行\n\t- **nowrap**(默认)：单行\n\t- **wrap**：多行\n\t- **wrap-reverse**：多行（对比wrap，cross start与cross end相反）\n![[Pasted image 20240501221341.png]]\n##### flex-flow\n- flex-flow属性是flex-direction和flex-wrap的简写\n\t- 任何顺序，并且都可以省略\n`<'flex-direction'> || <'flex-wrap'>`\n##### justify-content\n- justify-content决定了flex items在main axis上的对齐方式\n\t- **flex-start**(默认值)：与main start对齐\n\t- ![[Pasted image 20240501223509.png]]\n\t- **flex-end**：与main end对齐\n\t- ![[Pasted image 20240501223533.png]]\n\t- **center**：居中对齐\n\t- ![[Pasted image 20240501223545.png]]\n\t- **space-between**：\n\t\t- flex items之间的距离相等\n\t\t- 与main start、main end两端对齐\n\t- ![[Pasted image 20240501223655.png]]\n\t- **space-around**：\n\t\t- flexitems之间的距离相等\n\t\t- flexitems与main start、main end之间的距离是flex items之间距离的一半\n\t- ![[Pasted image 20240501223951.png]]\n\t- **space-evenly**：\n\t\t- flex items之间的距离相等\n\t\t- flex items与main start、main end之间的距离等于是flex items之间距离\n\t- ![[Pasted image 20240501223923.png]]\n##### align-items\n- align-items决定了flex items在cross axis上的对齐方式\n\t- **normal**：在弹性布局中，效果和stretch一样\n\t- **stretch**：当flex items在cross axis方向的size为auto时，会自动拉伸至填充flex containter\n\t- ![[Pasted image 20240501225200.png]]\n\t- **flex-start**：与cross start对齐\n\t- ![[Pasted image 20240501225312.png]]\n\t- **flex-end**：与cross end对齐\n\t- ![[Pasted image 20240501225327.png]]\n\t- **center**：居中对齐\n\t- ![[Pasted image 20240501225337.png]]\n\t- **baseline**：与基准线对齐\n\t- ![[Pasted image 20240501225348.png]]\n##### align-content\n- align-content决定了多行flex items在cross axis上的对齐方式，用法与justify-content类似\n\t- **stretch**（默认值）：与align-items的stretch类似\n\t- **flex-start**：与cross start对齐\n\t- ![[Pasted image 20240501230258.png]]\n\t-  **flex-end**：与cross end对齐\n\t- ![[Pasted image 20240501230306.png]]\n\t-  **center**：居中对齐\n\t- ![[Pasted image 20240501230317.png]]\n\t- **space-between**：\n\t\t- flex items之间的距离相等\n\t\t- 与cross start、cross end两端对齐\n\t- ![[Pasted image 20240501230329.png]]\n\t- **space-around**：\n\t\t- flexitems之间的距离相等\n\t\t- flexitems与main start、main end之间的距离是flex items之间距离的一半\n\t- ![[Pasted image 20240501230341.png]]\n\t-  **space-evenly**：\n\t\t- flex items之间的距离相等\n\t\t- flex items与main start、main end之间的距离等于是flex items之间距离\n#### flex-items\n##### order\n- order决定了flex items的排布顺序\n\t- 可以设置*任意整数*（正整数、负整数、0），*值越小就越排在前面*\n\t- 默认值是0\n##### align-self\n- flex items可以通过align-self覆盖flex containter设置的align-items\n\t- **auto**（默认值）：遵从flex containter的align-items设置\n\t- **stretch、flex-start、flex-end、center、baseline**，效果跟align-items一致\n##### flex-grow\n- flex-grow决定了flex items如何扩展（拉伸、成长）\n\t- 可以设置*任意非负数字（正整数、正小数、0），默认值是0*\n\t- 当flex containter在main axis方向上*有剩余size*时，*flex-grow属性才会有效*\n- 如果所有flex items的flex-grow*总和sum超过1*，每个flex item扩展的size为\n\t- flex containter的剩余*size * flex-grow/sum*\n- flex items 扩展后的最终size不能超过max-width/max-height\n##### flex-shrink\n- flex-shrink决定了flex items如何收缩\n\t- 可以设置*任意非负数字（正整数、正小数、0），默认值是1*\n\t- 当flex items在main axis方向上*超过了flex containter的size*时，*flex-shrink属性才会有效*\n- 如果所以flex items的flex-grow*总和sum超过1*，每个flex item收缩的size为\n\t- flex items超出flex containter的size * 收缩比例 / 所有flex items的收缩比例之和\n- flex items 收缩后的最终size不能小于min-width/min-height\n##### flex-basis\n- flex-basis用来设置flex items在main axis方向上的basis size\n\t- **auto**（默认值）、**具体的宽度数值**\n- 决定flex items最终base size的因素，从优先级高低\n\t- max-width \\ max-height \\ min-width \\ min-height\n\t- flex-basis\n\t- width \\ height\n\t- 内容本身的size\n##### flex\n- flex是flex-grow || flex-shrink || flex-basis的简写，flex属性可以指定1个、2个或3个值\n\t`none || [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]`\n- **单值语法**：值必须是以下之一：\n    - 一个 [`<flex-grow>`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow) 的有效值：此时简写会扩展为 。`flex: <flex-grow> 1 0`\n    - 一个 [`<flex-basis>`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis) 的有效值：此时简写会扩展为 。`flex: 1 1 <flex-basis>`\n    - 关键字 或者全局关键字之一。`none`\n- **双值语法**：\n    - 第一个值必须是一个 [`flex-grow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow) 的有效值。\n    - 第二个值必须是以下之一：\n        - 一个 [`flex-shrink`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink) 的有效值：此时简写会扩展为 。`flex: <flex-grow> <flex-shrink> 0`\n        - 一个 [`flex-basis`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis) 的有效值：此时简写会扩展为 。`flex: <flex-grow> 1 <flex-basis>`\n- **三值语法**：值必须按照以下顺序指定：\n    1. 一个 [`flex-grow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow) 的有效值。\n    2. 一个 [`flex-shrink`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink) 的有效值。\n    3. 一个 [`flex-basis`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis) 的有效值。\n**注意**\n[`initial`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex#initial)\n元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器。相当于将属性设置为\"\"。`flex: 0 1 auto`\n\n[`auto`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex#auto)\n元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 \"\".`flex: 1 1 auto`\n\n[`none`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex#none)\n元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为\"\"。`flex: 0 0 auto`\n### flex布局的常见问题\n如何解决如下布局的对齐问题？\n![[Pasted image 20240503172805.png]]\n*解决办法*：在子元素的最后**添加几个空的span/i元素**，高度与其他子元素一致，添加的个数是**列数-2**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n\n    <style>\n        .containter {\n            width: 800px;\n            height: 600px;\n            background-color: pink;\n            margin: 0 auto;\n            display: flex;\n            flex-wrap: wrap;\n            justify-content: space-between;\n        }\n\n        .item {\n            width: 220px;\n            height: 150px;\n            background-color: rgb(79, 155, 200);\n        }\n\n        i {\n            width: 220px;\n        }\n    </style>\n\n</head>\n<body>\n    <div class=\"containter\">\n        <div class=\"item item1\">1</div>\n        <div class=\"item item2\">2</div>\n        <div class=\"item item3\">3</div>\n        <div class=\"item item4\">4</div>\n        <div class=\"item item5\">5</div>\n        <div class=\"item item6\">6</div>\n        <div class=\"item item7\">7</div>\n        <div class=\"item item8\">8</div>\n        <div class=\"item item9\">9</div>\n        <div class=\"item item10\">10</div>\n        <div class=\"item item11\">11</div>\n        <!-- 添加span/i的个数是列数-2，并且宽度要和前面的div一致 -->\n        <i></i>\n    </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240503174704.png]]\n\n## 布局方案总结\n![[Pasted image 20240501163839.png]]\n# 额外补充知识\n## 03\n### border图形\n\nborder主要用来给盒子增加边框，但是在开发中我们也可以利用边框的特性来实现一些形状 \n\n给一个盒子四周添加不同颜色的边框\n![[Pasted image 20240425192608.png]]\n\n![[Pasted image 20240425192628.png]]\n\n将border设置为盒子长宽的一半\n![[Pasted image 20240425192903.png]]\n\n![[Pasted image 20240425192918.png]]\n将另外三边的颜色去除\n![[Pasted image 20240425193311.png]]\n\n![[Pasted image 20240425193352.png]]\n\n将这个盒子旋转\n![[Pasted image 20240425193858.png]]\n\n![[Pasted image 20240425193914.png]]\n### Web网络字体\n#### Web fonts的工作原理\n* 首先，我们需要通过一些渠道**获取到希望使用的字体**：\n\n![[Pasted image 20240425194548.png]]\n* 其次，在我们CSS代码中**使用该字体**：\n* 最后，在**部署静态资源**时，将**HTML/CSS/JavaScript/Font一起部署在静态服务器**中\n* 用户角度：\n\t\t1. 浏览一个网页时，因为代码中有引入字体文件，*字体文件会被一起下载下来*\n\t\t2. 浏览器会根据使用的字体在*下载的字体文件中查找、解析、使用对应的字体*\n\t\t3. *在浏览器中使用对应的字体显示内容*\n#### 使用Web Fonts\n* **第一步：** 在字体天下网站下载一个字体（实际开发中由产品部提供）\n\t* [字体天下-提供各类字体的免费下载和在线预览服务 (fonts.net.cn)](https://www.fonts.net.cn/)\n\t* 默认下载下来的是ttf文件\n* **第二步：** 使用字体\n* 使用过程如下：\n\t* 1、将*字体放到对应的目录中*\n\t* 2、**通过@font-face***来引入字体*，并且*设置格式*\n\t* 3、使用字体\n* 注意：**@font-face** 用于加载一个自定义的字体\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        /* 将这个字体引入到网页中 */\n       @font-face {\n            font-family: \"why\"; /* 给这个字体起一个名字，方便接下来引用 */\n            src: url(\"./fonts/YeZiGongChangTangYingHei-2.ttf\");\n       }\n       .box {\n        font-family: \"why\";\n       }\n    </style>\n</head>\n<body>\n    <div class=\"box\">我是div元素</div>\n</body>\n</html>\n```\n\n![[Pasted image 20240425212330.png]]\n\n#### Web Fonts的兼容性\n\n* 我们刚才使用的字体文件是 .ttf, 他是True Type字体。\n\t* 在开发中某些浏览器可能不支持该字体，所以为了浏览器的兼容性问题，我们需要有对应其他格式的字体；\n* True Type字体：拓展名是 .ttf\n\t* *OpenType/TrueType字体*：拓展名是 .ttf、.otf, 建立在TrueType字体之上\n\t* *Embedded OpenType字体*：拓展名是 .eot, OpenType字体的压缩版\n\t* *SVG字体*：拓展名是 .svg、.svgz\n\t* *WOFF表示Web Open Font Format web开放字体*：拓展名是 .woff, 建立在True Type字体之上\n\n![[Pasted image 20240425213333.png]]\n\n* 如果我们要具备很强的兼容性，那么可以如下格式编写：\n```html\n@font-face {\n            font-family: \"why\"; /* 给这个字体起一个名字，方便接下来引用 */\n            src: url(\"./fonts/YeZiGongChangTangYingHei-2.eot\");\n            src: url(\"./fonts/YeZiGongChangTangYingHei-2.eot?#iefix\") format(\"embedded-opentype\"),\n            url(\"./fonts/YeZiGongChangTangYingHei-2.woff\") format(\"woff\"),\n            url(\"./fonts/YeZiGongChangTangYingHei-2.ttf\") format(\"truetype\"),\n            url(\"./fonts/YeZiGongChangTangYingHei-2.svg#uxfonteditor\") format(\"svg\");\n            font-style: normal;\n            font-weight: normal;\n       }\n```\n\n* 这被称为刀枪不入的 *@font-face*语法：是**Paul Irish**早期的一篇文章提及后开始流行起来\n* src用于指定字体资源\n\t* **url**指定资源的路径\n\t* **format**用于帮助浏览器快速识别字体的格式\n### Web 字体图标\n#### 认识字体图标\n\n* 什么是字体图标：把*字体直接设计成图标的样子*就叫做*字体图标*\n* 字体图标的好处：\n\t* 放大不会失真\n\t* 可以任意切换颜色\n\t* 用到很多个图标时，文件相对图片较小\n* 字体图标的使用：\n\t* 登录阿里icons（[iconfont-阿里巴巴矢量图标库](https://www.iconfont.cn/)）\n\t* 下载代码，并且拷贝到项目中\n* 将字体文件和默认的CSS文件导入到项目中\n#### 字体图标的使用\n* 字体图标的使用步骤：\n\t* 第一步：通过link引入iconfont.css文件\n\t* 第二步：使用字体图标\n* 使用字体图标常见的两种方式：\n\t* 方式一：通过对应字体图标的Unicode来显示代码\n\t* 方式二：利用已经编写好的class，直接使用\n![[Pasted image 20240426164410.png]]\n第一种方式：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        @font-face {\n            font-family: \"iconfont\";\n            src: url(./fonts01/iconfont.ttf);\n        }\n        .iconfont {\n            font-family: \"iconfont\";\n            font-size: 100px;\n        }\n        .music::before {\n            content: \"\\e617\";\n        }\n    </style>\n</head>\n<body>\n    <!-- 直接通过内容（字符实体）展示 -->\n    <span class=\"iconfont\">&#xe66a;</span>\n    <!-- 不使用字符实体的方式展示（伪元素）出来 -->\n    <span class=\"iconfont music\"></span>\n</body>\n</html>\n```\n\n![[Pasted image 20240426162331.png]]\n第二种方式：使用iconfont配置的CSS：*将 .ttf文件和 .css文件一起拖到项目里*\n\n![[Pasted image 20240426163726.png]]\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <link rel=\"stylesheet\" href=\"./fonts01/iconfont.css\">\n    <style>\n        .icon {\n            font-size: 30px;\n            color: pink;\n        }\n    </style>\n</head>\n<body>\n    <i class=\"iconfont icon-dashuju icon\"></i>\n</body>\n</html>\n```\n\n![[Pasted image 20240426163746.png]]\n\n### CSS精灵图标 CSS Sprite\n#### 认识精灵图\n\n* 什么是CSS Sprite\n\t* 是一种**CSS图像合成技术**，将**各种小图片合并到一张图上**，然后**利用CSS的背景定位来显示对应的图片部分**\n\t* 有人翻译为：CSS雪碧、CSS精灵\n* 使用CSS Sprite的好处\n\t* 减少网页的**http请求数量，加快网页响应速度，减轻服务器压力**\n\t* 减少**图片总大小**\n\t* 解决了**图片命名问题**，只需要针对一张集合的图片命名\n* Sprite图片制作\n\t* 方法一：Photoshop，设计人员提供\n\t* 方法二： https://www.toptal.com/developers/css/sprite-generator\n#### 精灵图的使用\n* 精灵图的原理：**通过只显示图片的很小的一部分来展示**\n* 通常使用背景：\n\t* 设置对应元素的宽度和高度\n\t* 设置精灵图作为背景图片\n\t* 调整背景图片的位置来展示\n* 如何获取精灵图的位置\n\t* http://www.spritecow.com/\n\n![[Pasted image 20240426172126.png]]\n\n![[Pasted image 20240426172243.png]]\n\n### cursor属性\n* cursor可以设置鼠标指针（光标）在元素上面时的显示样式\n* cursor常见的设值有：\n\t* **auto**：浏览器根据上下文决定指针的显示样式，比如根据文本和非文本切换指针样式\n\t* **default**：由操作系统决定，一般就是一个小箭头\n\t* **pointer**：一只小手，鼠标挪动到链接上面默认就是这个样式\n\t* **text**：一条竖线，鼠标指针挪动到文本输入框上面默认就是这个样式\n\t* **none**：没有任何指针显示在元素上面\n## 04\n### CSS属性-transform\n- CSS transform属性允许对某一个元素进行某些形变，包括**旋转，缩放，倾斜或平移等**\n- 通常行内级元素不能进行形变\n\t- 对于行内非替换元素是无效的，比如span、a元素等\n#### 用法\n- transform属性的语法如下：\n![[Pasted image 20240508141635.png]]\n- 常见的函数transform function有：\n\t- **平移**：translate(x, y)\n\t- **缩放**：scale(x, y)\n\t- **旋转**：rotate(deg)\n\t- **倾斜**：skew(deg, deg)\n##### 位移-translate\n- 平移： translate(x, y)：这个函数用于移动元素在平面上的位置\n- 值个数\n\t- 一个值时，设置x轴上的位移\n\t- 两个值时，设置x轴和y轴上的位移\n- 值类型\n\t- **数字**：100px\n\t- **百分比**：参照物本身\n- translate函数是translateX()和translateY()的缩写\n##### 缩放-scale\n- 缩放：scale(x, y)：这个函数可改变元素的大小\n- 值个数\n\t- 一个值时，设置x轴上的缩放\n\t- 两个值时，设置x轴和y轴上的缩放\n- 值类型\n\t- **数字**：\n\t\t- 1：保持不变\n\t\t- >1：放大\n\t\t- <1：缩小\n\t- **百分比**：不常用 \n- scale函数是scaleX()和scaleY()的缩写 \n##### 旋转-rotate\n- 旋转：rotate（angel)：这个函数可以让元素进行旋转\n- 值类型：\n\t- 常用单位deg：旋转的角度\n\t- 正数为顺时针\n\t- 负数为逆时针\n\t- `transform: rotate(90deg)`\n- rotate函数是rotateZ函数的简写写法\n- rotate的其他单位\n\t- 度（degrees)、百分度(gradians)、弧度(radians)、圈数(turns)\n##### 倾斜-skew\n- 倾斜：skew(x, y)：这个函数定义了一个元素在二维平面上的倾斜转换\n- 值个数\n\t- 一个值时，表示x轴上的倾斜\n\t- 两个值时，表示x轴和y轴上的倾斜\n- 值类型\n\t- deg: 旋转的角度\n\t- 正数为顺时针\n\t- 负数为逆时针\n#### transform设置多个值\n- 我们可以给transform设置*多个形变的函数*\n- ![[Pasted image 20240508203909.png]]\n- “+”代表可以设置一个或多个值，多个值之间以空格隔开\n- “#”代表可以设置一个或多个值，多个值之间以“,”隔开 \n### CSS属性：transform-origin\n- transform-origin：形变的原点\n- 一个值：\n\t- 设置x轴的原点\n- 两个值：\n\t- 设置x轴和y轴的原点\n- 必须是`<length>, <percentage>, 或left, right, top, bottom关键字中的一个`\n\t- left、center、right、top、bottom关键字\n\t- length：从左上角开始计算\n\t- 百分比：参考元素本身大小\n\n\n### 元素水平居中和垂直居中的方案\n#### 水平居中\n- 行内级元素：\n\t- 设置父元素的text-align：center\n- 块级元素：\n\t- 设置当前块级元素（需要有固定宽度）margin：0 auto\n- 绝对定位：\n\t- 元素有宽度情况下，left0+right0+margin: 0 auto\n- flex:\n\t- justify-content: center\n#### 垂直居中\n- 绝对定位\n\t- 元素有高度的情况下，top0+bottom0+margin: auto 0\n\t- 弊端：\n\t\t- 必须使用定位（脱离标准流）\n\t\t- 必须给元素设置高度\n- flex布局\n\t- align-items：center\n\t- 弊端：\n\t\t- 当前flex布局中所有元素都会垂直居中\n- top+translate\n\t- 先让元素向下移动父元素的50%\n\t\t- `position：relative\n\t\t- `top：50%`\n\t\t-**注意**：这里不能用margin-top：50%，margin-top的百分比是相对于父元素的宽度，而非高度\n\t- 再让元素向上移动自身的50%\n\t\t- `transform: translate(0, -50%)`\n### transition动画\n#### 认识transition动画\n- 什么是transition动画？\n\t- CSS transition提供了一种在更改*css属性时*控制*动画速度的方法*\n\t- 可以让css属性变化成为一个*持续一段时间的过程，而不是立即生效的*\n- 通常将两个状态之间的过渡称为隐式过渡\n- CSS transition可以决定\n\t- 哪些属性发生动画效果\n\t- 何时开始（设置delay）\n\t- 持续多久（设置duration）\n\t- 如何动画（定义timing function，如匀速地或先快后慢）\n#### 可以做动画的CSS属性\n- 方法一：在MDN可*执行动画的CSS属性*中查询\n- 方法二：阅读CSS属性的文档说明\n ![[Pasted image 20240508195925.png]]\n#### 过渡动画-transition\n- transition CSS属性是transition-property，transition-duration，transition-timing-function和transition-delay的一个简写属性\n- **transition-property**：指定应用过渡性的名称\n\t- **all**：所有属性都执行动画\n\t- **none**：所以属性都不执行动画\n\t- **CSS属性名称**：要执行动画的CSS属性名称，比如width、left、transform等\n- **transition-duration**：指定动画所需的时间\n\t- 单位可以是秒(s)或毫秒（ms)\n- **transition-timing-function**：指定动画的变化曲线\n\t- [transition-timing-function - CSS：层叠样式表 |MDN的 (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function)\n- **transition-delay**：指定过渡动画执行之前的等待时间\n- 缺点：\n\t- *只能定义开始状态和结束状态*，不能定义中间状态\n\t- *不能重复执行*，除非一再触发动画\n\t- 需要在*特定状态下触发才能执行*，比如某个属性被修改了\n### Animation动画\n#### 认识Animation动画\n- CSS Animation的使用分成两个步骤\n\t- **步骤一**：使用@keyframes定义动画序列（每一帧动画如何执行）\n\t- **步骤二**：配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等\n#### @Keyframes规则\n- 可以使用 @Keyframes来定义多个变化状态，并且使用animation-name来声名匹配\n\t- 关键帧使用*percentage*来指定动画发生的时间点\n\t- **0%** 表示动画的第一时刻，**100%** 表示动画的最终时刻\n\t- 第一时刻和最终时刻还有特殊的别名：**from和to**\n基本语法如下：\n`@Keyframes 名称 {`\n\t`0% {`\n\t\t`transform: translate(0, 0) scale(0.5, 0.5)`\n\t`}`\n\t`50% {`\n\t\t`transform: translate(0, 200px) scale(1.2, 1.2)`\n\t`}`\n\t`100% {`\n\t\t`transform: translate(400px, 0) scale(0.5, 0.5)`\n\t`}`\n`}`\n#### animation属性\n- CSS animation 属性是animation-name，animation-duration，animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode和animation-play-style属性的一个简写属性形式\n- **animation-name**：指定执行哪一个关键帧动画\n- **animation-duration**：指定动画的持续时间\n- **animation-timing-function**：指定动画的变化曲线\n- **animation-delay**：指定延迟执行的时间\n- **animation-iteration-count**：指定动画执行的次数，执行infinite表示无限动画\n- **animation-direction**：指定方向，常用值normal和reverse\n- **animation-fill-mode**：执行动画最后保留哪一个值\n\t- none：回到没有执行动画的位置\n\t- forwards：动画最后一帧的位置\n\t- backwards：动画第一帧的位置\n- **animation-play-state**：指定动画运行或者暂停（在JS中使用，用于暂停动画）\n### vertical-align\n#### 深入理解vertical-align-line box\n- vertical-align会影响*行内块级元素*在一个*行盒*中垂直方向的位置\n- 当一个div没有设置高度的时候：\n\t- 没有内容，没有高度\n\t- 有内容，内容撑起来高度\n- 内容撑起来高度的本质\n\t- 内容有行高（line-height），撑起来了div的高度\n- 行高为什么可以撑起来div的高度\n\t- 这是因为**line boxes**的存在，并且line-boxes有一个特性，包裹每行的inline level\n\t- 而其中的文字是有行高的，必须将整个行高包裹进去，才算包裹这个line-level\n**不同情况分析**\n- 只有文字时![[Pasted image 20240508220221.png]]\n- 有图片，有文字时![[Pasted image 20240508220246.png]]\n- 有图片，有文字，有inline-block（比图片要大）![[Pasted image 20240508220432.png]]\n- 有图片，有文字，有inline-block而且设置了margin-bottom![[Pasted image 20240508220529.png]]\n- 有图片，有文字，有inline-block而且设置了margin-bottom并且有文字（当一个inline-box中有文本时，它的基线不再是底部，基线变成最后一行文本的基线）![[Pasted image 20240508220608.png]]\n#### vertical-align的baseline\n- 结论：line-boxes一定会想办法包裹住当前行中所有的内容\n- vertical-align的默认值是baseline\n- baseline都是哪些\n\t- 文本的baseline是字母x的下方\n\t- line-block默认的baseline是margin-bottom的底部（如果没有，就是盒子的底部）\n\t- inline-block有文本时，baseline是最后一行文本的x的下方\n#### vertical-align的其他值\n- 不同的取值\n\t- **baseline（默认值）**：基线对齐\n\t- **top**： 把行内级盒子的顶部跟line boxes顶部对齐\n\t- **middle**：行内级盒子的中心点与父盒基线加上x-height一半的线对齐(不建议用来做图片的居中)\n\t- **bottom**：把行内级盒子的底部跟line boxes底部对齐\n\t- **percentage**：把行内级盒子提升或者下降一段距离（距离相对于line-height计算\\元素高度），0%意味着同baseline一样\n\t- **length**：把行内级盒子提升或者下降一段距离，0cm意味着同baseline一样\n- 解决图片下边缘的间隙方法\n\t- **方法一**：设置成top/middle/bottom\n\t- **方法二**：将图片设置为block元素\n## 05\n### CSS属性：white-space\n- white-space用于设置空白处理和换行规则\n\t- **normal**：合并所有连续的空白，**允许**单词超屏时自动换行\n\t- **nowrap**：合并所有连续的空白，**不允许**单词超屏时自动换行\n\t- **pre**：**阻止**合并所有连续的空白，**不允许**单词超屏时自动换行\n\t- **pre-wrap**：**阻止**合并所有连续的空白，**允许**单词超屏时自动换行\n\t- **pre-line**：合并所有连续的空白（但保留换行），**允许**单词超屏时自动换行\n### CSS属性：text-overflow\n- text-overflow通常用来设置文字溢出时的行为\n\t- **cilp**：溢出的内容直接裁剪掉（字符可能会显示不完整）\n\t- **ellipsis**：溢出那行的结尾处用省略号表示\n### CSS中的函数\n- CSS函数通常可以帮助我们*更加灵活*的来编写*样式的值*\n- 几个好用的CSS函数\n\t- **var**：使用CSS定义的变量\n\t- **calc**：计算CSS值，通常用于计算元素的大小或位置\n\t- **blur**：毛玻璃（高斯模糊）效果\n\t- **gradient**：颜色渐变函数\n#### CSS函数 - var\n- CSS中可以自定义属性\n\t- *属性名*需要以*两个减号（--）* 开始\n\t- *属性值*则可以是*任何有效的CSS值*\n```\ndiv {\n\t--why-color: red;\n}\n```\n- 我们可以通过var函数来使用\n```\nspan {\ncolor: var(--why-color);\n}\n```\n- 规则集定义的选择器，是自定义属性的可见作用域（只在选择器内部有效）\n\t- 推荐将*自定义属性定义在html*中，也可以使用 *:root选择器*\n#### CSS函数 - calc\n- cala()函数允许在声明CSS属性值时执行一些计算\n\t- 计算支持*加减乘除*的运算：+ 和 -运算符的*两边必须要有空白字符*\n\t- 通常用来*设置一些元素的尺寸或者位置*\n```\n.box.containter{\n\tdisplay: inline-block;\n\t/* width的百分比相对于包含块（通常是父元素） */\n\twidth: calc(100% - 60px);\n\theight: 100px;\n\tbackground-color: pink;\n}\n```\n#### CSS函数 - blur\n- blur()函数将*高斯模糊*应用于输出图片或者元素\n\t- **blur(radius)**\n\t- **radius**，模糊的半径，用于定义高斯函数的偏差值，偏差值越大，图片越模糊\n- 通常会和两个属性一起使用：\n\t- **filter**：将模糊或颜色偏移等图形效果应用于元素；\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n\n  <style>\n    img {\n      filter: blur(5px);\n    }\n  </style>\n\n</head>\n<body>\n  <div class=\"box\">\n    <img src=\"../pct/pic.jpeg\" alt=\"\">\n  </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240513151105.png]]\n\n - **backdrop-filter**：为元素后面的区域添加模糊或者其他效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n\n  <style>\n\n    .box {\n      display: inline-block;\n      position: relative;\n    }\n\n    .cover {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      left: 0;\n      background-color: rgba(0, 0, 0, .5);\n      backdrop-filter: blur(5px);\n    }\n\n  </style>\n\n</head>\n<body>\n  <div class=\"box\">\n    <img src=\"../pct/pic.jpeg\" alt=\"\">\n    <div class=\"cover\"></div>\n  </div>\n</body>\n</html>\n```\n\n![[Pasted image 20240513151848.png]]\n#### CSS函数 - gradient\n- `<gradient>`是一种 **`<image>`CSS数据类型的子类型**，用于表现 **两种或多种颜色的过渡转变**\n\t- CSS的 *`<image>`数据类型*描述的是2D图形\n\t- 比如background-image、list-style-image、border-image、content等\n\t- `<image>`常见的方式是 *通过url来引入一个图片资源*\n\t- 它也可以通过CSS的`<gradient>`函数来设置颜色的渐变\n- `<gradient>`常见的函数实现\n\t- **linear-gradient()**：创建一个表示两种或多种颜色线性渐变的图片\n\t- **radial-gradient()**：创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成\n\t- **repeating-linear-gradient()**：创建一个由重复线性渐变组成的`<image>`\n\t- **repeating-radial-gradient()**：创建一个重复的原点触发渐变组成的`<image>`\n##### linear-gradient的使用\n- linear-gradient：创建一个表示两种或多种颜色线性渐变的图片\n![[Pasted image 20240513154320.png]]\n- radial-gradient：创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成\n![[Pasted image 20240513154427.png]]\n### 浏览器前缀\n- 有时候会看到有些CSS属性名前面带有：**-o-、-xv-、-ms-、-mso-、-webkit-**\n![[Pasted image 20240513213207.png]]\n- 为什么需要浏览器前缀\n\t- CSS属性刚开始并没有成为标准，浏览器为了防止后续会修改名字给新的属性添加了浏览器前缀\n- 浏览器私有前缀，只有对应的浏览器才能解析使用\n\t- -o-、-xv-：Opera等\n\t- -ms-、-mso-：IE等\n\t- -moz-：Firefox等\n\t- -webkit-：Safari、Chrome等\n### FC-Formatting Context\n- 元素在标准流里面都是属于一个FC的\n- 块级元素的布局属于Block Formatting Context（BFC）\n- 行内级元素的布局属于Inline Formatting Context（IFC）\n#### BFC-Block Formatting Context \n\n![[Pasted image 20240513221209.png]]\n##### 作用\n概述如下：\n-  在BFC中，box会在*垂直方向上一个挨着一个*排布\n- *垂直方向的间距由margin属性决定*\n- 在同一个BFC中，*相邻两个box之间的margin会折叠*\n- 在BFC中，每个元素的*左边缘是紧挨着包含块的左边缘的*\n作用：\n- 解决margin的折叠问题\n- 解决浮动高度塌陷问题\n#### BFC的作用二：解决浮动高度塌陷\n- BFC解决高度塌陷需要满足两个条件\n\t- 浮动元素的父元素触发BFC，形成独立的块级格式化上下文\n\t- 浮动元素的父元素的高度是auto的\n- BFC的高度是auto的情况下，如下方法计算高度\n\t- 如果只有inline-level，是行高的顶部和底部的距离\n\t- 如果有block-level，是由最底层的块上边缘和最底层块盒子的下边缘之间的距离\n\t- 如果有绝对定位元素，将被忽略\n\t- 如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘\n### 媒体查询\n- 媒体查询是一种提供给开发者针对不同需求进行定制化开发的一个接口\n- 可以根据设备的类型（比如屏幕设备、打印机设备）或者特定的特性（如屏幕的宽度）来修改页面\n- 媒体查询的使用方式\n\t- 一：通过 *@media和@import*使用不同的CSS规则\n![[Pasted image 20240513225836.png]]\n\t- 二：使用 *media属性为`<style>、 <link>、 <source>`和其他html元素指定的媒体类型*\n![[Pasted image 20240513225905.png]]\n\t- 三：使用Windows.matchMedia()和MediaQuerylist.addListener()方法来测试和监控媒体状态\n- 比较常用的是通过@media来使用不同的CSS规则，目前掌握这个即可\n#### 媒体类型\n- 在使用媒体查询时，你必须指定要使用的媒体类型\n\t- 不选则是应用all类型\n- 常见的媒体类型值如下\n\t- **all**：适用于所有设备\n\t- **print**：适用于在打印预览模式下在屏幕上查看的分页材料和文档\n\t- **screen**：主要用于屏幕\n\t- **speech**：主要用于语音合成器\n#### 媒体特性\n- 媒体特性描述了浏览器、输出设备，或是预览环境的具体特征\n\t- 通常会将媒体特性描述为一个表达式\n\t- 每条媒体特性表达式都必须用括号括起来\n![[Pasted image 20240513231454.png]]\n#### 逻辑操作符\n- 媒体查询的表达式最终会获得一个Boolean值，真或者假\n\t- 结果为真，则生效\n\t- 结果为假，不会生效\n- 如果有多个条件，可以通过逻辑操作符联合复杂的媒体查询\n\t- **and**：and操作符用于将多个媒体查询规则组合成单条媒体查询\n\t- not：not运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false\n\t- only：only运算符仅在整个查询匹配时才用于应用样式\n\t- ，(逗号)：\n![[Pasted image 20240513232247.png]]","tags":["前端三件套"],"categories":["前端开发"]},{"title":"JavaScript上","url":"/posts/2025/04/Fronted/三件套/03- JavaScript基础/c041c21b.html","content":"## 认识JavaScript\n定义：\n- JavaScript是一种*高级的、解释型的*编程语言 \n- JavaScript是*一门基于原型、头等函数*的语言，是*一门多范式的语言*，它支持*面向对象程序设计，指令式编程，以及函数式编程*\n### JavaScript的组成\nJavaScript的组成包括**ECMAScript、DOM、BOM**\n- **ECMAScript**：定义语言规范\n- **DOM**：用于操作文档的API\n- **BOM**：用于操作浏览器的API\n### JavaScript的基本语法\n#### JavaScript编写方式\n- 第一种：HTML代码行内（不推荐）\n```html\n<!-- 第一种：HTML代码行内 -->\n  <a href=\"javascript:alert('百度一下')\">百度一下</a>\n  <a href=\"#\" onclick=\"alert('百度一下')\">百度一下</a>\n\n```\n- 第二种：script标签中\n```html\n<!-- 第二种：script标签中 -->\n  <a href=\"#\" class=\"google\">google一下</a>\n  <script>\n    const googleEl = document.querySelector(\".google\")\n    googleEl.onclick = function() {\n      alert(\"google一下\")\n    }\n  </script>\n```\n- 第三种：外部的文件\n\t- 需要通过script元素的**scr属性来引入JavaScript文件**\n```html\n<!-- 第三种：外部的script文件 -->\n\n  <a href=\"#\" class=\"bing\">bing一下</a>\n\n  <script src=\"./JS/01_编写.js\"></script>\n```\n\n```js\nconst bingEl = document.querySelector(\".bing\")\n    bingEl.onclick = function() {\n      alert(\"bing一下\")\n}\n```\n#### noscript元素\n如果运行的浏览器不支持JavaScript，我们使用`<noscript>`元素来给用户更好的提示\n- 浏览器显示包含在`<noscript>`中内容的情况：\n\t- 浏览器不支持脚本\n\t- 浏览器对脚本的支持被关闭\n```html\n<body>\n\t<noscript>\n\t\t<p>您的浏览器不支持JavaScript<p>\n\t<noscript>\n<body>\n```\n### Javscript 的编写注意事项\n- 注意一：script元素**是双标签元素，不能写成单标签**\n\t- 在外联式引用js文件时，script标签中不可以写JavaScript代码，而且script标签不能写成单标签\n- 注意二：省略type属性\n- 注意三：加载顺序\n\t- JavaScript默认遵循HTML文档的加载顺序，即*自上而下的加载顺序*\n\t- 推荐将JavaScript代码和*编写位置放在body子元素的最后一行*\n- JavaScript代码严格区分大小写\n### JavaScript语句和分号\n- 编写的每一行代码都是一个语句\n- 通常每条语句的后面会添加一个*分号*，表示语句的结束\n\t- 存在换行符时，大多数情况下可以省略分号，JavaScript将*换行符理解成“隐式”的分号*，也被称之为 *自动插入分号*\n### JavaScript的注释\n- JavaScript的注释主要分为三种\n\t- 单行注释\n\t- 多行注释\n\t- 文档注释（VScode中需要再单独的js文件中编写才有效）\n![[Pasted image 20240515133954.png]]![[Pasted image 20240515134002.png]]\n注意：不支持注释的嵌套\n## JavaScript变量和数据类型\n### 变量的命名格式\n- 在JavaScript中命名一个变量包含两部分\n\t- 变量的声明：使用**var关键字**在JavaScript中声明一个变量\n\t- 变量的赋值：使用 **=** 给变量进行赋值\n![[Pasted image 20240515143237.png]]\n![[Pasted image 20240515143305.png]]\n![[Pasted image 20240515143315.png]]\n### 变量的命名规范\n- 变量命名规则\n\t- 第一个字符必须是*一个字母、下划线(_)或一个美元符号($)\n\t- **不能使用关键字和保留字命名**\n\t- 变量**严格区分大小写**\n- 变量命名规范\n\t- 多个单词使用**驼峰标记**（小驼峰：userName,大驼峰：UserName）\n\t- 赋值 = 两边加上一个空格\n\t- 变量应该见名知意\n### 变量的注意事项\n- 一：如果一个变量未声明就直接使用，会报错\n- 二：如果一个变量有声明，但是没有赋值，那么默认值是undefined\n- 三：如果没有使用var声明变量也可以，但是不推荐（实际会被添加到Windows对象上）\n### JavaScript的数据类型\n- JavaScript中的**值**都有特定的类型\n\t- 可以将 *值赋值给一个变量，那么这个变量就具备了特定的类型*\n\t- 一个变量可以在前一刻是字符串，下一刻是数字\n- 8种基本数据类型\n\t- **Number\n\t- **String\n\t- **Boolean\n\t- **Undefined\n\t- **Null\n\t- **Object\n\t- Biglnt\n\t- Symbol\n#### Number类型\n- Number类型代表整数和浮点数\n- Number有很多操作符，如 乘法*、除法/、加法+、减法-等等\n- 特殊数值\n\t- **infinity**：代表无穷大\n\t- **NaN**：代表计算错误，如字符串和一个数字相乘\n- 其他进制表示方法：\n![[Pasted image 20240515194724.png]]\n- 数字表示的范围：\n\t- **最小数**：Number.MIN_VALUE，这个值为：5e-324，小于这个的数字会被转化为0\n\t- **最大数**：Number.MAX_VALUE，这个值为1.7976931348623157e+308\n\t- **最小整数**：Number.MIN_SAFE_INTEGER，这个值为 -(2^53 - 1)\n\t- **最大整数**：Number.MAX_SAFE_INTEGER，这个值为 (2^53 - 1)\n- isNaN\n\t- 用于判断是否是一个数字，是数字返回true，不是数字返回false\n- 实例方法：\n\t- **toString(base)**：将数字转成字符串，并且按照base进制进行转化\n\t\t- base的范围从2-36，默认情况是10\n\t\t- 注意：如果是直接对一个数字操作，需要使用 .. 运算符\n\t- **toFixed(digits)**：格式化一个数字（格式化后生成String类型），保留digits位的小数\n\t\t- digits的范围是0-20\n```js\nvar num = 123\nconsole.log(num.toString(2)) //1111011\nconsole.log(123..toString(2)) //1111011\n```\n- 类方法：\n\t- **Number.parseInt(string[,radix])**：将字符串解析成整数\n\t- **Number.parseFloat(string)**：将字符串解析成浮点数\n```js\nvar num = \"123.321\"\nconsole.log(Number.parseInt(num)) //123\nconsole.log(Number.parseFloat(num)) //123.321\n```\n#### String类型\n- JavaScript中的字符串必须被括在引号里\n\t- 双引号：\"hello\" \n\t- 单引号：'hello'\n\t- 反引号：`hello`(ES6之后学)\n![[Pasted image 20240515195916.png]]\n- 前后引号类型必须一致\n\t- 如果字符串里面本身包括单引号，可以使用双引号\n\t- 如果字符串里面本身包括双引号，可以使用单引号\n- 转义字符：\n\t- 有一些特殊功能的字符可以通过转义字符的形式放入字符串中\n![[Pasted image 20240515200147.png]]\n- 字符串的几个基本使用操作：\n\t- 字符串拼接，通过+运算符![[Pasted image 20240515200348.png]]\n\t- 获取字符串长度![[Pasted image 20240515200411.png]]\n- 访问字符串的字符\n\t- 方法一：通过字符串的索引 str[0]\n\t- 方法二：通过str.charAt(pos)\n\t- 区别：方法一没有找到会返回undefined，charAt没找到会返回空字符串\n- 字符串的遍历\n\t- 方法一：普通for循环\n\t- 方法二：for .. of遍历(只有字符串和数组能这样遍历)\n```js\nvar ms = \"Hello World\"\n\nfor (var i = 0; i < ms.length; i++) {\n\tconsole.log(ms[i])\n}\n\nfor (var char of ms) {\n\tconsole.log(char)\n}\n```\n- 修改字符串\n\t- **toLowerCase**：将所有的字符转成小写\n\t- **toUpperCase**：将所有的字符转成大写\n```js\nvar ms = \"Hello World\"\n\nvar ms1 = ms.toLowerCase() //hello world\nvar ms2 = ms.toUpperCase() // HELLO WORLD\n\nconsole.log(ms, ms1, ms2)\n```\n- 查找字符串\n\t- 方法一：**查找字符串的位置：str.indexOf(searchValue [, fromIndex])\n\t\t- 从fromIndex开始，查找searchValue的索引\n\t\t- 没有找到返回-1，找到返回单词第一个字母的索引\n\t\t- lastIndexOf，从最后开始查找\n\t- 方法二：**是否包含字符串：str.includes(searchString [, position])\n\t\t- 从position位置开始查找searchString，返回true或false\n\t\t- ES6新增的方法\n\t- 方法三：**以xxx开头：str.startWith(searchString [, position])\n\t\t- 从position位置开始，判断字符串是否以searchString开头\n\t\t- ES6新增\n\t- 方法四：**以xxx结尾：str.endWith(searchString [, length])\n\t\t- 在length长度内，判断字符串是否以searchString结尾\n\t- 方法五：**替换字符串：str.replace(regexp|substr, newSubStr|function)\n\t\t- 查找到对应的字符串，并且使用新的字符串进行替代\n\t\t- 也可以传入一个正则表达式来查找，也可以传入一个函数来替换\n- 获取子字符串![[Pasted image 20240520155559.png]]\n- 拼接字符串：**str.concat(str2, [, ...strN])\n- 删除首尾空格：**str.trim()\n- 字符串分割：**str.split([separator[, limit]])\n\t- separator：以什么字符串进行分割，也可以是一个正则表达式\n\t- limit：限制返回片段的数量\n查看文档： [String - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)\n#### Boolean类型\n- Boolean类型用于表示真假\n- 仅包含两个值：true和false\n#### Undefined类型\n- Undefined类型只有一个值，就是特殊值undefined\n\t- 如果声明一个变量没有对其进行初始化，则默认值就是Undefined\n- 两个注意事项\n\t- 最好在定义变量的时候进行初始化\n\t- 不要将一个变量赋值为undefined\n\t\t- 如果变量刚开始什么都没有，我们可以初始化为0、空字符串、null等值\n#### Object类型\n- Object往往可以表示*一组数据*，是其他数据的一个集合\n- 在JavaScript中可以使用花括号{}的方式来表示一个对象![[Pasted image 20240515203651.png]]\n#### Null类型\n- Null类型通常用来表示一个对象为空，常常在给一个对象进行初始化时，会赋值为null\n### 数据类型的转换\n#### 字符串string的转换\n- 方式一：隐式转换\n\t-  *一个字符串和其他类型进行+操作*\n\t\t- 如果+运算符左右两边有一个是字符串，那么另一边会自动转换成字符串类型进行拼接\n\t-  *某些函数的执行也会自动将参数转为字符串类型*，比如consloe.log函数\n- 方式二：显示转换\n\t- 调用String()函数\n\t- 调用toString()方法\n#### Number的转换\n- 方式一：隐式转换\n\t- 在算术运算中，通常会将其他类型转换成数字类型来进行运算\n\t\t- 比如 ”6“ / ”2“\n\t\t- 但是如果是+运算，并且其中一边是字符串，那么还是按照字符串来连接\n- 方式二：显示转换\n\t- 调用Number()函数\n- 其他类型转换数字规则![[Pasted image 20240515210345.png]]\n#### Boolean的转换\n- 发生在 *逻辑运算*中，也可以通过调用Boolean()显示地进行转换\n- 转换规则：\n\t- 直观上为空的值（0、空字符串、null、undefined和NaN）将变为false\n\t- 其他值变为true![[Pasted image 20240515210631.png]]\n\t- 注意：包含0的字符串“0”是true\n\n\n\n### typeof操作符\n- *typeof操作符*用来 *确定任意变量的数据类型*\n- 返回值：\n\t- undifined表示值未定义\n\t- bollean表示值为布尔值\n\t- string表示值为字符串\n\t- number表示值为数值\n\t- object表示值为对象或null\n\t- function表示值为函数\n\t- symbol表示值为符号\n- typeof():\n\t- *typeof(x)与 typeof x* 相同，*()* 只是将后续内容当做一个整体\n## JavaScript函数\n- 已经接触的函数\n\t- alert函数：浏览器弹出一个弹窗 \n\t- prompt函数：在浏览器弹窗中接收用户的输入\n\t- console.log函数：在控制台输入内容\n- 声明函数使用**function**关键字\n`function 函数名() {`\n\t`代码`\n`}`\n- arguments参数\n\t- 默认情况下， *arguments对象*是所有（非箭头）函数中都可以用的 *局部变量*\n\t- 该对象中存放着所有的 *调用者传入的参数，从0位置开始，依次存放*\n\t- arguments变量的类型是一个 *object类型，而非一个数组*\n\t- 如果调用者传入的参数多于函数接收的参数，可以通过arguments去获取所有的参数\n- 函数表达式\n```\nvar foo = function () {\n\tconsole.log(\"foo函数\")\n}\n```\n- 注意：function关键字后面没有函数名\n- 函数都是一个值（值的类型是一个对象）\n### JavaScript头等函数\n- 头等函数是指在程序设计语言中，函数被当作头等公民\n\t- 这意味着函数可以 *作为别的函数的参数、函数的返回值、赋值给变量或存储在数据结构中*\n- 例如：函数可以在变量和变量之间相互进行赋值\n```\nfunction foo() {\nconsole.log(\"foo函数执行\")\n}\n\nvar bar = foo\nbar()\n```\n### 回调函数\n- 函数可以传递给另一个函数\n```js\nfunction foo(fn) {\n\tfn()\n}\nfunction bar() {\n\tconsole.log(\"我是bar函数被调用\")\n}\nfoo(bar)\n```\n- 回调函数的案例\n```js\nfunction request(url, callback) {\n\tconsole.log(\"根据URL向服务器发送网络请求\")\n\tconsole.log(\"需要花费比较长的时间拿到对应的结果\")\n\tvar list = [\"javascript\", \"javascript学习\", \"javascript高级编程\"]\n\tcallback(list)\n}\n\nrequest(\"url\", function (res) {\n\tconsole.log(\"拿到结果:\", res)\n})\n```\n- 高阶函数：\n\t- 接受 *一个或多个函数*作为输入\n\t- *输出一个函数*\n- 匿名函数：\n\t- 在传入一个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量\n### 立即执行函数\n- *一个函数定义完后被立即执行*\n\t- 第一部分：定义一个匿名函数，这个函数有自己独立的作用域\n\t- 第二部分：后面的 **()** 表示这个函数被执行了\n```js\n//常用写法(只掌握这个写法)\n(function() {\n\tconsole.log(\"立即执行函数\")\n})()\n\n//匿名写法\n(function(fn) {\n\tconsole.log(\"立即执行函数\")\n}());\n```\n- 作用：会创建一个独立的执行上下文环境，避免外界访问或修改内部的变量\n- 应用场景一：避免变量命名重复造成内容被覆盖\n- 应用场景二：点击按钮显示点击的第几个按钮\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n\n  <button class=\"btn\">按钮1</button>\n  <button class=\"btn\">按钮2</button>\n  <button class=\"btn\">按钮3</button>\n  <button class=\"btn\">按钮4</button>\n  \n  <script>\n    \n    // 获取所有的按钮监听\n    var btnEls = document.querySelectorAll(\".btn\")\n\n    for (var i = 0; i < btnEls.length; i++) {\n      var btn = btnEls[i];\n      (function(m) {\n        btn.onclick = function() {\n          console.log(`按钮${m + 1}发生了点击`)\n        }\n      })(i)\n    }\n\n  </script>\n\n</body>\n</html>\n```\n## JavaScript的面向对象\n- 对象类型是一种 *存储键值对（key-value）* 的更加复杂的数据类型\n- 对象类型可以 *使用{...}* 来创建，里面包含的是键值对\n- *键值对* 可以是 *属性和方法*\n- 其中 *key是字符串*， *value可以是任意类型*， 包括基本数据类型、函数类型、对象类型等\n### 创建对象\n- 创建方式：\n\t- **对象字面量**：通过{}\n```js\nvar info = {\n\tname: \"jojo\",\n\tage: 20,\n\tgirfriend: {\n\t\tname: \"小羊\",\n\t\tage: 18,\n\t},\n\trunning function() {\n\tconsole.log(\"running~\")\n\t}\n}\n```\n    -  **new Object+动态添加属性**\n\t- **new 其他类**\n- 属性之间以 *逗号分割*\n- 使用过程的操作：\n\t- 访问对象的属性![[Pasted image 20240517224021.png]]\n\t- 修改对象的属性![[Pasted image 20240517224030.png]]\n\t- 添加对象的属性![[Pasted image 20240517224039.png]]\n\t- 删除对象的属性：delete![[Pasted image 20240517224050.png]]\n\n- 方括号\n\t- 出现JavaScript无法理解的属性时，我们需要使用方括号![[Pasted image 20240517224435.png]]\n### 对象的遍历\n- **Objectkey()** 方法会返回一个由一个给定对象的自身可枚举属性组成的数组\n- 遍历方式一：普通for循环![[Pasted image 20240517230541.png]]\n- 遍历方式二：for in循环![[Pasted image 20240517230606.png]]\n### 栈内存和堆内存\n- **原始类型**占据的空间是在**栈内存**中分配的\n- **对象类型**占据的空间是在**堆内存**中分配的\n- 原始类型在变量中保存的是值本身\n- 对象类型在变量中保存的是对象的”引用“![[Pasted image 20240518155438.png]]\n5个现象：\n- 现象一：两个对象的比较\n```js\nvar obj1 = {}\nvar obj2 = {}\nconsole.log(obj1 === obj2)\n//答案为false\n```\n- 现象二：引用的赋值\n```js\nvar info = {\n\tname: \"why\",\n\tfriend: {\n\t\tname: \"kobe\"\n\t}\n}\nvar friend = info.friend\nfriend.name = \"james\"\nconsole.log(info.friend.name)\n//答案为James\n```\n- 现象三：值传递\n```js\nfunction foo(a) {\n\ta = 200\n}\nvar num = 100\nfoo(num)\nconsole.log(num)\n//答案为100\n```\n- 现象四：引用传递，但是在函数中创建了一个新对象，没有对传入对象进行修改\n```js\nfunction foo(a) {\n\ta = {\n\t\tname: \"why\"\n\t}\n}\nvar obj = {\n\tname: \"obj\"\n}\nfoo(obj)\nconsole.log(obj)\n//答案为name: \"obj\"\n```\n- 现象五：引用传递，但是对传入的对象进行修改\n```js\nfunction foo(a) {\n\ta.name = \"why\"\n}\n\nvar obj = {\n\tname: \"obj\"\n}\nfoo(obj)\nconsole.log(obj)\n//答案为name: \"why\"\n```\n### this变量\n- this指向Windows\n```js\nfunction fn () {\n    console.log(this)   //Window\n}\nfn();\n```\n- this指向调用的对象\n```js\nlet obj = {\n    name:'zy',\n    sayHi:function() {\n        console.log(this)\n    }\n}\nobj.sayHi() //obj   {name: \"zy\", sayHi: ƒ}\n```\n### 创建一系列对象\n- 方法一：工厂函数\n\t- *封装一个函数*，在这个函数中创建一个对象，再重复调用这个函数\n\t- 对象是Object类型\n```js\nfunction createstudent(name, age, height, address) {\n\tvar stu = {}\n\tstu.name = name\n\tstu.age = age\n\tstu.height = height\n\tstu.address = address\n\n\tstu.eating = function() {\n\t\tconsole.log(stu.name + \"在吃东西\")\n\t}\n\treturn stu\n}\n\nvar stu1 = creat(\"张三\", 18, 1.66, \"四川省\")\nvar stu2 = creat(\"jojo\", 20, 1.80, \"四川省\")\n``` \n- 方法二：**构造函数**\n\t- 也称之为 *构造器*，通常是我们在*创建对象时会去调用的函数*\n\t- JavaScript中的 *构造函数扮演了其他语言中类的角色*\n\t- 也是一个 *普通函数，如果被new操作符来调用了，那么这个函数就是一个构造函数*\n\t- 如果一个函数被使用new操作符来调用了，会执行以下操作\n\t\t- 在内存中创建一个新的对象（空对象）\n\t\t- 这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性\n\t\t- 构造函数内部的this，会指向创建出来的新对象\n\t\t- 执行函数的内部代码\n\t\t- 如果构造函数没有返回非空对象，则返回创建出来的新对象\n\t- 对象是构造的函数类型\n\t- 名称：使用大驼峰\n```js\nfunction Student(name, age, height) {\n\tthis.name = name\n\tthis.age = age\n\tthis.height = height\n\tthis.eating = function() {\n\t\tconsole.log(this.name + \"在吃东西\")\n\t}\n\nvar stu1 = new Student(\"jojo\", 20, 1.80)\n}\n```\n### 全局对象-window\n作用：\n- 查找变量时，最终会找到window头上\n- 将一些浏览器全局提供给我们的变量/函数/对象，放在window对象上面\n- 使用var定义的变量会被默认添加到window上面\n## JavaScript常见内置类\n### 原始类型的包装类\n- JavaScript的原始类型 *并非对象类型*，JavaScript为了可以 *使其获得属性和调用方法，对其封装了对应的包装类型*\n- **常见的包装类型**：String、Number、Boolean、Symbol、Biglnt类型\n- 我们也可以自己创建一个包装类的对象（但没必要）\n```js\nvar name1 = \"why\"\nvar name2 = new String(\"why\")\nconsole.log(typeof name1) //string\nconsole.log(typeof name2) //object\nconsole.log(name1 === name2) //false\n```\n- 注意事项：null、undefined没有任何方法，也没有对应的“对象包装类”\n### Math对象的使用\n是一个 *内置对象*（不是一个构造函数）\n- Math常见的属性：\n\t- Math.PI：圆周率\n- Math常见的方法：\n\t- **Math.floor**：向下取整\n\t- **Math.ceil**：向上取整\n\t- **Math.round**：四舍五入取整\n\t- **Math.random**：生成[0, 1) 的随机数\n\t- **Math.pow**：返回x的y次幂\n- 查看文档： [数学 - JavaScript |MDN的 (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)\n```js\n    var num = 3.14\n    console.log(Math.floor(num)) //3\n    console.log(Math.ceil(num)) //4\n    console.log(Math.round(num)) //3\n    // 生成5~50随机数\n    console.log(Math.floor(Math.random() * 45) + 5)\n```\n### 数组 - Array\n- 一种有序的集合，可以通过索引来获取\n- 创建数组的方式\n\t- 方法一：![[Pasted image 20240520194120.png]]\n\t- 方法二：![[Pasted image 20240520194244.png]]\n\t- 在创建数组时，设置数组长度![[Pasted image 20240520194333.png]]\n\t- 数组元素从0开始编号\n#### 数组的基本操作\n- *访问*数组中的元素\n\t- 通过中括号[]访问\n\t- arr.at(i):\n\t\t- 如果i >= 0，则与arr[i]完全相同\n\t\t- 如果i为负数，则会从数组的尾部向前数\n```js\nvar num = [123, 234, 345, 456]\n    console.log(num[0]) //123\n    console.log(num.at(0)) //123\n\n    console.log(num[-1]) //undifined\n    console.log(num.at(-1)) //456\n\n    // 修改\n    num[0] = 132\n```\n- 添加、删除元素\n\t- 在数组的尾端添加或者删除元素\n\t\t- **push**在末端添加元素\n\t\t- **pop**在末端取出一个元素\n\t- 在数组的首段添加或者删除元素（运行速度比尾端的添加、删除操作慢）\n\t\t- **shift**取出首段的一个元素，整个数组向前移动\n\t\t- **unshift**在首段添加元素，整个数组向后移动\n\t- 在中间某个位置添加或者删除\n\t\t- **arr.splice方法**可以做所有事情（添加、删除和替换）\n\t\t- 语法结构：`array.splice(start[, deleteCount[, item1[, item2[, ...]]]])`\n\t\t\t- 从 *start*位置开始，处理数组中的元素\n\t\t\t- *deleteCount*：要删除的元素个数，如果为0或者负数表示不删除\n\t\t\t- *item1，item2，...*：在添加元素时，需要添加的元素\n\t\t- 注意：这个方法会修改原数组\n```js\nvar num = [123, 234, 345, 456]\n\n    // 尾插\n    num.push(567, 678)\n    console.log(num) // 123, 234, 345, 456, 567, 678\n\n    // 尾删\n    num.pop()\n    console.log(num) // 123, 234, 345, 456, 567\n\n    // 头插\n    num.unshift(980, 789)\n    console.log(num) // 980, 789, 123, 234, 345, 456, 567\n\n    // 头删\n    num.shift()\n    console.log(num) // 789, 123, 234, 345, 456, 567\n\n    // 中间删\n    num.splice(1, 2) // 从索引为1开始，删除2个元素\n    console.log(num) // 789, 345, 456, 567\n\n    // 中间添加\n    num.splice(1, 0, 205, 427) // 在索引为1的前面，添加元素\n    console.log(num) // 789, 205, 427, 345, 456, 567\n\n    // 中间即删除又添加（即替换元素）\n    num.splice(1, 2, 654) // 从引为1开始，删除2个元素, 再添加元素\n    console.log(num) // 789, 654, 345, 456, 567\n```\n-  length属性\n\t- *length属性*用于获取数组的长度\n\t\t- 当我们修改数组的时候，length属性会自动更新\n\t- length属性是可写的\n\t\t- *手动增加一个大于默认length的数值*，那么会增加数组的长度\n\t\t- 减少它，数组就会被截断\n\t\t- *清空数组最简单的方法*：arr.length = 0\n\n- 数组的遍历\n\t- 普通for循环遍历\n\t- for..in遍历，获取到索引值\n\t- for..of遍历，获取到每一个元素\n```js\nvar num = [123, 234, 345, 456]\n\n    for (var i = 0; i < num.length; i++) {\n      console.log(num[i])\n    }\n\n    for(var index in num) {\n      console.log(index, num[index])\n    }\n\n    for(var item of num) {\n      console.log(item)\n    }\n```\n\n- 数组方法 - slice、cancat、jojin\n\t- **arr.slice**：用于对数组进行截取 ，返回一个新的数组，不会对原数组进行操作\n\t\t- `arr.slice([begin[, end]])`\n\t\t- 包含begin元素不包含end元素\n\t- **arr.cancat**：创建一个新数组，其中包含来自其他数组和其他项的值\n\t\t- `var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])`\n\t- **arr.join**：将一个数组的所有元素链接成一个字符串并返回\n\t\t- `arr.join([separator])`\n```js\nvar num = [123, 234, 345, 456]\n\n    var num1 = num.slice(1, 3)\n    console.log(num1) // 234、345\n\n    var num2 = [12, 13, 14]\n\n    var num3 = num.concat(num2)\n    console.log(num3) // 123, 234, 345, 456, 12, 13, 14\n\n    console.log(num.join(\"\")) //123234345456(字符串)\n\n```\n\n- 查找元素\n\t- **arr.indexOf方法**：查找某个元素的索引\n\t\t- `arr.indexOf(searchElement[, fromIndex])`\n\t\t- 从fromIndex开始查找，如果找到返回对应的索引，没有找到返回-1\n\t\t- 还有对应的从最后位置开始查找的lastIndexOf\n\t- **arr.includes方法**：判断数组是否包含某个元素\n\t\t- `arr.includes(valueToFind[, fromIndex])`\n\t\t- 从索引from开始搜索item，如果找到返回true\n\t- **forEach**：遍历整个数组\n\t\t- `array.forEach(function(currentValue, index, arr), thisValue)`\n\t\t- function(currentValue, index, arr): 必需。对数组中每个元素要执行的函数。该函数有以下三个参数:\n\t\t\t- currentValue: 必需。当前元素的值。\n\t\t\t- index: 可选。当前元素的索引值。\n\t\t\t- arr: 可选。当前元素所属的数组对象。\n\t\t- thisValue: 可选。传递给函数的值，用于 this 关键词。\n\t\t- `forEach()` 方法*没有返回值*,它只是对数组中的每个元素执行指定的操作。\n\t- **find**：直接查找元素\n\t\t- `array.find(function(currentValue, index, arr), thisValue)`\n\t\t- `function`: 一个回调函数,用于测试数组的每个元素。\n\t\t- `currentValue`: 数组中正在处理的当前元素。\n\t\t- `index`(可选): 数组中正在处理的当前元素的索引。\n\t\t- `arr`(可选): 正在使用 `find()` 方法的数组本身。\n\t\t- `thisValue`(可选): 可以用来设置回调函数中的 `this` 值。\n\t\t-  如果在数组中找到满足条件的*第一个元素*,则返回该元素的值;否则返回 `undefined`\n\t- **findIndex**：直接查找索引（用法与find类似）\n\t\t- `array.findIndex(function(currentValue, index, arr), thisValue)`\n\t\t-  如果在数组中找到满足条件的第一个元素,则返回该元素的索引;否则返回 `-1`。\n- 排序\n\t- **sort**：对数组进行排序，并且生成一个排序后的新数组\n\t\t- `arr.sort([compareFunction])`\n\t\t- compareFunction(a, b)<0, a排在b前面\n\t\t- compareFunction(a, b)>0, a排在b后面\n\t- **reverse**：将数组中的元素进行倒置，并且返回该数组\n```js\nvar students = [3, 6, 1, 7]\nvar newStus = students.sort(function(items1, items2) {\n\treturn items1 - items2 //升序 1, 3, 6, 7\n\t// return items2 - items1 降序 7， 6， 3， 1\n})\nvar newStus = students.reverse() // 7, 1, 6, 3\n```\n### 时间\n- 创建Date对象\n\t- *Date的构造函数*\n\t\t-  new Date()\n\t\t- new Date(value) (传入时间戳)\n\t\t- new Data(dataString)\n\t\t- new Data(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])\n```js\n\tvar date1 = new Date() //当前时间\n    var date2 = new Date(1000) //传入毫秒数，表示从1970-01-01 00:00:00 UTC 经过的毫秒数\n    var date3 = new Date(\"2024-5-27\")\n    var date4 = new Date(2024, 05, 27, 21, 42, 00,000) //年月日时分秒毫秒\n    console.log(date4)\n```\n![[Pasted image 20240527214831.png]]\n- dateString时间的表达方式\n\t- 日期有两种表达方式：RFC 2822标准（默认打印时间格式）和 ISO 8601标准\n\t- 转成ISO 8601标准：`data.toISOString()`\n\t\t- YYYY：年份，0000~9999\n\t\t- MM：月份，01~12\n\t\t- DD：日，01~31\n\t\t- T：分隔时间和日期，无特殊含义\n\t\t- HH：小时，00~24\n\t\t- mm：分钟，00~59\n\t\t- ss：秒，00~59\n\t\t- .sss：毫秒\n\t\t- Z：时区\n- 从Data获取信息\n\t- **getFullYear()**：获取年份（4位数）\n\t- **getMonth()**：获取月份，从0~11\n\t- **getDate()**：获取当月的具体日期，从1~31\n\t- **getHours()**：获取小时\n\t- **getMinutes()**：获取分钟\n\t- **getSeconds()**：获取秒钟\n\t- **getMilliseconds()**：获取毫秒\n\t- **getDat()**：一周中的第几天（周日是0开始）\n- Data设置信息的方法\n\t- **setFullYear(year, [month], [date])\n\t- **setMonth(month, [date])\n\t- **setDate(date)\n\t- **setHours(hour, [min], [sec], [ms])\n\t- **setMinutes(min, [sec], [ms])\n\t- **setSeconds(sec, [ms])\n\t- **setMilliseconds(ms)\n\t- **setTime(milliseconds)**\n- Date获取Unix时间戳\n\t- **Unix时间戳**：是一个整数值，表示从1970年1月1日00:00:00 UTC以来的毫秒数\n\t- 获取时间戳：\n\t\t- new Date.getTime()\n\t\t- new Date.valueOf()\n\t\t- +new Date()\n\t\t- Date.now()\n\t- 可以用时间戳来测试代码的性能\n- Date.parse方法\n\t- Date.parse(str)方法可以从一个字符串中读取日期，并且输出对应的Unix时间戳\n\t- 作用等同于 new Date(dateString).getTime()操作\n\t- 需要符合RFC2822或ISO 8601日期格式的字符串\n\t- 如果输入的格式不能被解析，会返回NaN\n```js\n\tvar date = new Date() //当前时间\n    console.log(date)\n    console.log(date.toISOString())\n    // 获取时间信息\n    var year = date.getFullYear()\n    var month = date.getMonth() + 1\n    var day = date.getDate()\n    var hour = date.getHours()\n    var minute = date.getMinutes()\n    var second = date.getSeconds()\n    console.log(year, month, day, hour, minute, second)\n    console.log(`${year}/${month}/${day} ${hour}:${minute}:${second}`)\n\n    // 给date设置时间\n    date.setFullYear(2044)\n    //自动校验\n    date.setDate(32)\n    console.log(date)\n\n    var startTime = Date.now()\n    for(var i = 0 ; i < 10000; i++) {\n      console.log(i)\n    }\n    var endTime = Date.now()\n    console.log(endTime - startTime)\n```\n![[Pasted image 20240528205053.png]]\n![[Pasted image 20240528210927.png]]\n","tags":["前端三件套"],"categories":["前端开发"]},{"title":"JavaScript下","url":"/posts/2025/04/Fronted/三件套/04- JavaScript高级/b746f28d.html","content":"# this指向\n## this的绑定规则\n### this的指向\n- 在函数调用的时候，JavaScript会 *默认给this绑定一个值*\n- this的 *绑定和定义的位置（即编写的位置）* 没有关系\n- this的 *绑定和调用方式以及调用的位置有关系*\n- this *是在运行时才被绑定的*\n### 默认绑定\n- 独立的调用函数this指向window，但在严格模式下独立调用的函数中的this指向的是Undefined(\"use strict\")\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  \n  <script>\n\n      // 默认绑定\n      // 1.案例一\n      function foo() {\n        console.log(this)\n      } \n\n      foo()\n\n      // 2.案例二\n      function test1() {\n        console.log(this)\n        test2()\n      }\n\n      function test2() {\n        console.log(this)\n        test3()\n      }\n\n      function test3() {\n        console.log(this)\n      }\n      test1()\n\n      // 3.案例三\n      function project(func) {\n        func()\n      }\n\n      var obj = {\n        name: \"jojo\",\n        bar: function() {\n          console.log(this)\n        }\n      }\n\n      project(obj.bar)\n\n  </script>\n\n</body>\n</html>\n```\n### 隐式绑定\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <script>\n\n    function foo() {\n      console.log(this) //这里的this绑定到obj对象\n    }\n\n    var obj = {\n      bar: foo\n    }\n\n    obj.bar()\n\n  </script>\n</body>\n</html>\n```\n### new绑定\n- 执行的操作\n\t- 创建一个全新的对象\n\t- 这个新对象会被执行prototype连接\n\t- 这个新对象会绑定到函数调用的this上\n\t- 如果函数没有返回其他对象，表达式会返回这个新对象\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  \n  <script>\n\n    function foo() {\n      console.log(this); \n      this.name = \"why\"\n    }\n\n    new foo() //this绑定foo\n\n  </script>\n\n</body>\n</html>\n```\n### 显式绑定\ncall：`func.call(thisArg, arg1, arg2, ...)`\napply：`func.apply(thisArg, [arg1, arg2, ...]`\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <script>\n\n    var obj = {\n      name: \"why\"\n    }\n\n    function foo(name, age) {\n      console.log(this)\n      console.log(name, age)\n    }\n\n    foo.call(obj, \"jojo\", 20) //执行函数，并且强制this指向obj\n    foo.apply(obj, [\"小羊\", 19])\n\n\n  </script>\n</body>\n</html>\n```\n**bind**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <script>\n    function foo(name, age) {\n      console.log(this);\n      console.log(name);\n      console.log(age);\n    }\n    \n    var obj = {\n      name: 'Tom'\n    }\n\n    var bar = foo.bind(obj, \"jojo\", 20)\n    bar()\n\n  </script>\n</body>\n</html>\n```\n### 绑定优先级\n显式 > 隐式\nnew > 隐式\nnew >  bind\n\n### this面试题\n#### 一\n![[Pasted image 20240727141059.png]]\n#### 二\n![[Pasted image 20240727191000.png]]\n#### 三\n![[Pasted image 20240727211810.png]]\n\n![[Pasted image 20240727211824.png]]\n#### 四\n![[Pasted image 20240727220053.png]]\n### 手写call、apply、bind函数\nday36\n\n\n\n\n## 箭头函数\n- 箭头函数 *不会绑定this、arguments属性*， 没有显示原型，不能和new一起使用\n- `nums.forEach((item, index, arr) => { })`\n- 优化：\n\t- 如果只有一个参数，( )可以省略![[Pasted image 20240725150801.png]]\n\t- 如果执行体只有一行代码，可以省略大括号，并且会返回这行代码的返回值![[Pasted image 20240725150853.png]]\n\t- 如果执行体只返回一个对象，需要给对象加上( )![[Pasted image 20240725150934.png]]\n# 深入浏览器的渲染原理\n## 网页被解析的过程\n![[Pasted image 20240801121708.png]]\n## 浏览器的内核\n- 常见的浏览器内核![[Pasted image 20240801123558.png]]\n- 浏览器内核也称作浏览器排版引擎\n## 渲染页面的详细流程\n![[Pasted image 20240801123756.png]]\n解析HTML生成 DOM Tree ，遇到css文件时，解析CSS生成 Style Rules，这两者的解析过程不产生冲突。DOM Tree 和 Style Rules生成 Render Tree（渲染树，渲染树中没有节点的位置），再通过 Layout进行布局，然后进行绘画和展示\n### HTML解析过程\n- 解析HTML是所有步骤的开始（服务器给浏览器默认返回  .html 文件）\n- 解析HTML构建 DOM Tree![[Pasted image 20240801124525.png]]\n### 生成CSS规则\n- 解析过程中，遇到CSS的 link元素，浏览器会下载对应的CSS文件（下载CSS文件不会影响DOM解析）\n- 下载完CSS文件，会对CSS文件进行解析，得到对应的 Style Rules（规则树， 也可以称之为CSSOM，CSS对象模型）![[Pasted image 20240801124907.png]]\n### 构建Render Tree\n- DOM Tree 和 CSSOM Tree 结合构建 **Render Tree**![[Pasted image 20240801125031.png]]\n- *link元素不会阻碍DOM Tree 的构建过程，但会阻碍 Render Tree 的构建过程*，因为在构建Render Tree时，需要对应的CSSOM Tree\n- *Render Tree 和 DOM Tree 并不是一一对应的关系*， display为none的元素，不会出现在Render Tree中\n### 布局（Layout）和绘制（paint）\n- 在Render Tree上运行 *布局* 来计算每个节点的几何体\n\t- Render Tree会显示节点及其他样式，但不显示 *每个节点的尺寸、位置*等信息\n\t- 布局可以确定呈现树中 *所有节点的宽度、高度和位置信息*\n- 将每个节点绘制到屏幕上\n\t- 绘制时，浏览器将布局的每个frame转为屏幕上实际的像素点\n\t- 包括将元素的可见部分进行绘制，如 *文本、颜色、边框、阴影、替换元素（img等）*\n### 回流和重绘\n- 回流\n\t- 在第一次确定节点的大小和位置，称之为布局\n\t- 之后再进行修改重新计算称为回流\n- 引起回流的情况![[Pasted image 20240801131023.png]]\n- 重绘\n\t- 第一次渲染内容称之为绘制\n\t- 之后重新渲染称之为重绘\n- 引起重绘的情况\n\t- 修改背景色、文字颜色、边框颜色、样式等\n![[Pasted image 20240801131232.png]]\n## 特殊解析 - composite合成\n- 每个合成层都是 *单独渲染的*\n- 默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中\n- 有一些属性绘创建一个新的合成层，利用GPU来加速绘制\n\t- **3D transforms\n\t- **video、canvas、iframe\n\t- **opacity动画转换时\n\t- **position: fixed(固定定位)\n\t- **will-change**（目前还是一个实验性的属性，提前告诉浏览器元素可能发生的变化）\n\t- **animation 或 transition 设置了 opacity(透明度)、transform\n- 分层是以内存管理为代价提高性能，不能作为性能优化策略过度使用\n## script元素和页面解析的关系\n- 浏览器在解析HTML过程中，遇到了 *script元素是不能继续构建DOM树的*，会停止构建，先下载JavaScript代码，并且执行JavaScript的脚本，等到JavaScript脚本执行结束后，再继续解析HTML，构建DOM树\n![[Pasted image 20240801142428.png]] \n## defer属性\n- defer属性告诉浏览器 *不要等待脚本下载， 继续解析HTML， 构建DOM Tree*， 如果脚本提前下载好了，它会 *等待DOM Tree构建完成，在DOMContentLoaded事件完成前先执行defer中的代码*\n- 多个带defer的脚本会保持正确的顺序执行\n- defer可以提高网页的性能，推荐放在head元素中\n- **注意：** defer只适用于外部脚本，对于script默认内容会被忽略\n## async属性\n- async让一个脚本完全独立\n\t- async脚本不会阻碍浏览器的解析（与defer类似）\n\t- *async脚本不能保证顺序，它独立下载、独立运行，不会等待其他脚本*\n\t- async不能保证在DOMContentLoaded之前或者之后执行\n- defer常用于需要在文档解析后操作DOM的JavaScript代码，并且对多个script文件有顺序要求\n- async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的\n# 深入JavaScript的运行原理\n## V8引擎的执行原理\n![[Pasted image 20240801154302.png]]\n### V8引擎的架构\n![[Pasted image 20240801154530.png]]\n## JS执行上下文\n### 执行上下文\n- JS引擎内部有一个执行上下文栈（Execution Context Stack，简称ECS），用于执行代码的调用栈\n- 全局的代码块为了执行会构建一个Global Execution Context（GEC），GEC会被放入ECS中执行\n### 认识VO对象\n- 每一个执行上下文会关联一个 *VO（Variable Object，变量对象），变量和函数声明*会被添加到这个VO对象中\n- 当全局代码被执行的时候，VO就是GO对象了\n### 函数执行上下文\n![[Pasted image 20240801172129.png]]\n# JavaScript的内存管理和闭包\n## JavaScript内存管理\n- JavaScript会在 *定义数据时*为我们分配内存\n- JavaScript对于 *原始数据类型内存的分配*  会在执行时，直接在栈空间进行分配\n- 对于 *复杂数据类型内存的分配*  会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用\n## 垃圾回收（GC）算法\n### 引用计数\n- 当 *一个对象有一个引用指向它* 时，这个对象的的引用就 +1\n- 当 *一个对象的引用为0* 时，这个对象就可以被销毁掉\n- **弊端**：会产生循环引用![[Pasted image 20240802152232.png]]\n### 标记清除\n- *核心思路：* 可达性\n- *实现思路：* 设置一个 *根对象*，垃圾回收器会定期从这个根对象开始，找到所有从根开始有引用到的对象，对于没有引用到的对象，认为是不可用的对象\n- 这个算法解决了上一个算法产生的循环引用的问题![[Pasted image 20240802154857.png]]\n### 算法优化\nV8引擎为了进行更好的优化，在算法实现细节上会结合一些其他算法\n- **标记整理**\n\t- 回收期间会将保存的储存对象 *搬运汇集到连续的内存空间*，从而 *整合空闲空间，避免内存碎片化*\n- **分代收集**：对象被分为 *新的* 和 *旧的*\n\t- 很多对象完成工作并很快死去，它们会被 *很快被清理*\n\t- 那些长期存活的对象会变 *老旧*，而且 *被检查的频次也会减少*\n- **增量收集\n\t- 将垃圾收集工作分成几个部分来做，然后将这几部分逐一处理，这样把一个大的延迟分成许多微小的延迟\n- **闲时收集\n\t- 垃圾收集器 *只会在CPU空闲时尝试运行，减少可能对代码执行的影响*\n## 闭包\n### 闭包的定义\n- 一个函数和周围的环境的引用捆绑在一起，这样的组合就是闭包\n- 闭包可以在一个内层函数中访问到其外层函数的作用域\n- 广义理解：JavaScript中的函数都是闭包\n- 狭义理解：JavaScript中的一个函数，如果访问了外层作用域的变量，那么它就是一个闭包\n# JavaScript函数的增强知识\n## 函数对象的属性和argumens\n### 属性name和length\n- **属性name**：一个函数的名词我们可以通过name来访问![[Pasted image 20240802203605.png]]\n- **属性length**：返回函数输入参数的个数（rest参数不参与参数的个数）![[Pasted image 20240802203941.png]]\n### 认识arguments\n- arguments是一个类数组对象（不是一个数组类型，而是一个对象类型）\n\t- 它拥有数组的一些特性，如length、可以用Index索引来访问\n\t- 但没有数组的一些方法，如filter、map\n### arguments转Array\n- 方法一：遍历arguments，添加到一个新数组中![[Pasted image 20240802205908.png]]\n- 方法二：ES6中的两个方法\n\t- 1.Array.from![[Pasted image 20240802210001.png]]\n\t- 2.`[...arguments]`![[Pasted image 20240802210026.png]]\n- 方法三：调用slice函数的call方法![[Pasted image 20240802210124.png]]\n### 函数的剩余（rest）参数\n- ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中\n\t- 最后一个参数是 ... 为前缀，那么剩余的参数会作为一个数组放到该参数中![[Pasted image 20240803163950.png]]\n- 剩余参数和arguments的区别\n\t- 剩余参数只包含 *没有对应形参的实参*，arguments对象包含了 *传给函数的所有实参*\n\t- *arguments对象不是一个数组，只是类数组对象，而rest参数是一个真正的数组，可以进行数组的所有操作*\n- **剩余参数必须放到最后一个位置，否则会报错**\n## 纯函数\n### 理解纯函数\n- 有确定的输入，一定会产生确定的输出\n- 函数在执行过程中，不能产生副作用\n## 柯里化函数\n![[Pasted image 20240803194335.png]]\n### 自动柯里化（了解）\n![[Pasted image 20240803201340.png]]\n## 组合函数\n![[Pasted image 20240803203237.png]]\n## 严格模式\n![[Pasted image 20240803210307.png]]\n# 对象增强\n## Object.defineProperty\n- Object.defineProperty()方法会直接在对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象：`Object.defineProperty(obj, prop, descriptor)`\n- 可接受三个参数\n\t- obj：要定义属性的对象\n\t- prop：要定义或修改属性的名称或Symbol\n\t- descriptor：要定义或修改的属性描述符\n- 返回值被传递给函数的对象\n## 数据属性描述符\n![[Pasted image 20240805170950.png]]\n## 存取属性描述符\n![[Pasted image 20240805172134.png]]\n## 同时定义多个属性\n- Object.defineProperties()方法直接在一个对象上定义多个新的属性或修改现有属性，并且返回该对象![[Pasted image 20240805173134.png]]\n# ES5中的继承\n## 对象和函数的原型\n### 认识对象原型\n\n![[Pasted image 20240805192039.png]]\n### 函数对象的原型\n![[Pasted image 20240805192551.png]]\n**将方法放在原型上**\n1. *减少内存占用：\n    - 当方法定义在对象的实例上时,每个对象都会有一个独立的方法副本,这会浪费内存。\n    - 将方法放在原型上,所有对象实例共享同一个方法,大大减少了内存的使用。\n2. *提高代码复用性*：\n    - 将方法放在原型上,可以让所有对象实例都能访问和使用这些方法。\n    - 这提高了代码的复用性,避免了在每个对象实例上都定义相同的方法,提高了开发效率。\n3. *动态添加/修改方法：\n    - 通过修改原型,可以动态地为所有对象实例添加或修改方法。\n    - 这使得代码更加灵活和可扩展。\n4. *保持对象实例的轻量级*：\n    - 将方法放在原型上,可以保持对象实例本身更加简单和轻量级。\n    - 对象实例中只保存自己的属性,方法都存储在原型上,这样可以提高性能。\n5. *继承和多态：\n    - 通过原型链机制,可以实现继承和多态。\n    - 子类可以重写或扩展从父类继承的方法,实现代码复用和多态特性。\n**注意：** 讲方法放在原型上的方法也叫做实例方法，在没有实例对象的情况下，不能调用此函数\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <script>\n\n    function Students(name, age, grade) {\n      this.name = name;\n      this.age = age;\n      this.grade = grade;\n    } // 定义构造函数\n    \n    Students.prototype.running = function() {\n      console.log(this.name + \" is running\");\n    } // 将方法放在原型上\n\n    var std1 = new Students(\"jojo\", 20, 100) // 创建实例对象\n\n    std1.running()\n\n  </script>\n</body>\n</html>\n```\n## constructor属性\n![[Pasted image 20240806141712.png]]\n**理解\n![[Pasted image 20240806145948.png]]\n\n![[Pasted image 20240806145900.png]]\n- 重写原型对象![[Pasted image 20240806151052.png]]![[Pasted image 20240806151113.png]]![[Pasted image 20240806151123.png]]![[Pasted image 20240806151136.png]]\n## 通过原型链实现继承\n创建父类对象，并且作为子类的原型对象![[Pasted image 20240806160312.png]]![[Pasted image 20240806160344.png]]![[Pasted image 20240806160612.png]]\n## 借用构造函数实现继承\n![[Pasted image 20240806161649.png]]![[Pasted image 20240806161712.png]]![[Pasted image 20240806161725.png]]\n- 组合原型链和借用构造函数实现继承的问题![[Pasted image 20240806162633.png]]\n## 寄生组合实现继承\n![[Pasted image 20240806165456.png]]\n最终实现方案：\n- 将继承函数封装成工具放在JS文件中![[Pasted image 20240806170337.png]]\n- 代码![[Pasted image 20240806170358.png]]\n## 对象的方法补充\n![[Pasted image 20240806173132.png]]\n# ES6实现继承\n## 原型继承关系图\n![[Pasted image 20240806211030.png]]\n## class方式定义类\n- 使用class来定义一个类：\n\t- 类声明和类表达式![[Pasted image 20240807133150.png]]\n- 在创建对象的时候想给类传递一些参数：\n\t- 每个类有一个固定的构造函数方法**constructor**\n\t- 每个类只能有一个构造函数\n- **注意**：类中定义的多个内容不需要使用 \",\" 进行分割\n### 实例方法\n```js\n class Person {\n      constructor(name, age) {\n        this.name = name\n        this.age = age\n      }\n\n      //running和eating被添加在Person.prototype上\n      running() {\n        console.log(`${this.name} is running.`)\n      }\n\n      eating() {\n        console.log(`${this.name} is eating.`)\n      }\n    }\n\n    var p1 = new Person(\"jojo\", 20)\n    p1.running()\n    p1.eating()\n```\n### 类的静态方法\n- 静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用 **static关键字**来定义\n- 类方法里面的this指向类本身\n```js\n<script>\n\n    class Person {\n      constructor(name, age) {\n        this.name = name\n        this.age = age\n      }\n\n      static running() {\n        console.log(`${this.name} is running.`); \n      }\n    }\n\n    Person.running() // 静态方法可以直接通过类名调用，不需要实例化对象,这里的this指向类本身，输出Person is running.\n\n  </script>\n```\n### super关键字\n- 执行 super.method(...) 来调用一个父类方法\n- 执行 super(...) 来调用一个父类 constructor (只能在自己的constructor中调用)\n- **注意：** 在子类的构造函数中使用this或者返回默认对象之前，必须先通过super调用父类的构造函数\n- super的使用位置有三个：子类的构造方法、实例方法、静态方法\n```js\n<script>\n\n    class Person {\n\n      constructor(name, age) {\n        this.name = name\n        this.age = age\n      }\n      running() {\n        console.log('running')\n      }\n      eating() {\n        console.log('eating')\n      }\n\n      static sleep() {\n        console.log('sleeping')\n      }\n    }\n\n    class Student extends Person {\n      constructor(name, age, grade) {\n        // 调用父类构造函数\n        super(name, age)\n        this.grade = grade\n      }\n\n      // 重写父类方法\n      running() {\n        console.log('running in class')\n        super.running() // 调用父类方法\n      }\n\n      // 新增方法\n      studying() {\n        console.log('studying')\n      }\n\n      // 重写父类静态方法\n      static sleep() {\n        console.log('sleeping in class')\n        super.sleep() // 调用父类静态方法\n      }\n    }\n\n    var stu = new Student(\"jojo\", 18)\n    stu.running()\n    stu.eating()\n    stu.studying()\n    Student.sleep()\n    \n  </script>\n```\n### 继承内置类\n```js\n<script>\n\n    // 1、创建一个新的类，继承内置类 Array\n    class xyArray extends Array {\n      get lastItem() {\n        return this[this.length - 1]\n      }\n\n      get firstItem() {\n        return this[0]\n      }\n    }\n\n    var arr = new xyArray(1, 2, 3, 4, 5)\n    console.log(arr) // [1, 2, 3, 4, 5]\n    console.log(arr.length) // 5\n    console.log(arr.lastItem) // 5\n    console.log(arr.firstItem) // 1\n\n    // 2、直接对Array进行扩展\n    Array.prototype.lastItem = function() {\n      return this[this.length - 1]\n    }\n\n    Array.prototype.firstItem = function() {\n      return this[0]\n    }\n\n    var arr2 = [1, 2, 3, 4, 5]\n    console.log(arr2) // [1, 2, 3, 4, 5]\n    console.log(arr2.length) // 5\n    console.log(arr2.lastItem()) // 5\n    console.log(arr2.firstItem()) // 1\n\n  </script>\n```\n### 类的混入mixins\n- JavaScript的类只支持单继承，当我们需要多继承时，可以使用混入![[Pasted image 20240807153120.png]]\n## ES6对象的增强\n### 字面量的增强\n- 属性的简写\n```js\n// 1、属性的增强\n    var name = \"小明\"\n    var age = 18\n\n    var obj = {\n      name, // 等同于 name: name\n      age // 等同于 age: age\n    }\n\n    function foo() {\n      var message = \"Hello World\"\n      var info = \"This is a message from \"\n      return {\n        message, // 等同于 message: message\n        info // 等同于 info: info\n      }\n    }\n\n    var result = foo()\n    console.log(result.message) // Hello World\n    console.log(result.info) // This is a message from \n```\n- 方法的增强\n```js\n    // 2、方法的增强\n    var obj = {\n      name: \"小明\",\n      age: 18,\n      sayHello() { // 等同于 sayHello: function() {...}\n        console.log(\"Hello, \" + this.name)\n      }\n    }\n\n    obj.sayHello() // Hello, 小明\n```\n- 计算属性名\n```js\n// 3、计算属性名\n    var key = \"address\"\n    var value = \"北京市海淀区\"\n    var obj = {\n      [key]: value // 等同于 obj[key] = value\n    }\n\n    console.log(obj.address) // 北京市海淀区\n\n```\n### 解构\n- 数组的解构\n```js\n// 1.数组的解构语法\n    var arr = [1, 2, 3, undefined, 5]\n\n    // 1.1基本用法\n    var [a, b, c] = arr\n    console.log(a, b, c) // 1 2 3\n\n    // 1.2按照严格的顺序\n    var [a, , c] = arr\n    console.log(a, c) // 1 3\n\n    // 1.3解构出数组\n    var [a, b, ...arr2] = arr\n    console.log(a, b, arr2) // 1 2 [3, 4, 5]\n\n    // 1.4默认值\n    var [a , b, c, d = 4, e] = arr\n    console.log(a, b, c, d, e) // 1 2 3 4 5\n```\n- 对象的解构\n```js\n// 2.对象的解构语法\n    var obj = {name: 'zhangsan', age: 20, city: 'beijing'}\n\n    // 2.1基本用法\n    var {name, age, city} = obj\n    console.log(name, age, city) // zhangsan 20 beijing\n\n    // 2.2对象的解构没有顺序，根据key值解构\n    var {age, name, city} = obj\n    console.log(name, age, city) // zhangsan 20 beijing\n\n    // 2.3解构出对象\n    var {name, age, ...obj2} = obj\n    console.log(name, age, obj2) // zhangsan 20 {city: \"beijing\"}\n\n    // 2.4默认值\n    var {name, age, city, job = 'teacher'} = obj\n    console.log(name, age, city, job) // zhangsan 20 beijing teacher\n\n    // 2.5对变量名进行重命名\n    var {name: myName, age: myAge, city: myCity} = obj\n    console.log(myName, myAge, myCity) // zhangsan 20 beijing\n\n```\n# ES6新特性\n## let、const\n### 基本使用\n- let关键字：与var没有太大的区别，都是用于声明一个变量\n- const关键字\n\t- 用const关键字声明的变量一旦被赋值，就不能被修改\n\t- 如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容![[Pasted image 20240810011845.png]]\n- let、const都不允许重复声明变量\n- let、const不会给window上添加任何属性 \n### let、const的块级作用域\n- let、const、function、class声明的标识符具备块级作用域的限制![[Pasted image 20240810022228.png]]\n- 但是函数拥有块级作用域，但是在外面依然可以访问\n#### 应用场景\n- 获取多个按钮监听点击\n![[Pasted image 20240810023404.png]]\n## 模版字符串\n- ES6开始使用模版字符串来嵌入JS的变量或者表达式来进行拼接\n\t- 使用反引号来编写字符串，称为模版字符串\n\t- 再通过 **${expression}** 来动态嵌入内容![[Pasted image 20240810025103.png]]\n### 标签模版字符串\n- 使用标签模版字符串，在调用时插入其他变量\n\t- 模版字符串会被拆分\n\t- 第一个元素是数组，是被模版字符串拆分的字符串组合\n\t- 后面的元素是一个个模版字符串传入的内容![[Pasted image 20240810030121.png]]\n## 展开运算符\n### 展开语法\n![[Pasted image 20240810032922.png]]\n![[Pasted image 20240810033004.png]]\n## Symbol\n![[Pasted image 20240810034748.png]]![[Pasted image 20240810034808.png]]\n![[Pasted image 20240810035320.png]]![[Pasted image 20240810035344.png]]\n## Set-Map\n### Set\n- 基本使用\n\t- Set中的元素不能重复\n\t- 这个功能可以给数组去重![[Pasted image 20240810143447.png]]\n- 常见属性和方法\n\t- 属性\n\t\t- size：返回Set中元素的个数\n\t- 方法\n\t\t- add(value)：添加某个元素，返回Set对象本身\n\t\t- delete(value)：从Set中删除和value值相等的元素，返回Boolean类型\n\t\t- has(value)：判断Set中是否存在某个元素，返回Boolean类型\n\t\t- clear()：清空Set中的所有的元素，没有返回值\n\t\t- forEach(callback, [,thisArg])：通过forEach遍历Set\n### WeakSet\n\n![[Pasted image 20240810145329.png]]\n![[Pasted image 20240810145349.png]]\n### Map\n![[Pasted image 20240810150140.png]]\n![[Pasted image 20240810150225.png]]\n### WeakMap\n\n![[Pasted image 20240810152228.png]]\n![[Pasted image 20240810152332.png]]\n## Promise\n- 用于处理异步的解决方案\n1. **Promise 的状态**: Promise 有三种状态:Pending（进行中）、Fulfilled（已成功）和 Rejected（已失败）。这些状态可以帮助我们更好地跟踪异步操作的进度。\n    \n2. **Promise 的链式调用**: 通过 `.then()` 和 `.catch()` 方法,我们可以将多个异步操作串联起来,形成一个 Promise 链。这样可以使代码更加清晰和可读。\n    \n3. **错误处理**: 在 Promise 链中,只需在最后添加一个 `.catch()` 方法即可捕获任何一个步骤中出现的错误,大大简化了错误处理的逻辑。\n    \n4. **async/await**: 为了进一步简化 Promise 的使用,ES2017 引入了 `async/await` 语法糖。使用 `async` 函数可以让异步代码看起来更像同步代码,大大提高了可读性。\n- 使用基本格式：\n1. **创建 Promise**:\n    - 使用 `new Promise()` 创建一个新的 Promise 对象。\n    - 传递一个函数作为参数,这个函数被称为 Promise 执行器(Executor)。\n    - 在 Promise 执行器函数内部,我们执行异步操作。\n    - 如果异步操作成功,调用 `resolve(result)` 函数,将结果传递出去。\n    - 如果异步操作失败,调用 `reject(error)` 函数,将错误信息传递出去。\n2. **使用 Promise**:\n    - 通过 `.then()` 方法处理 Promise 成功的情况。\n    - 通过 `.catch()` 方法处理 Promise 失败的情况。\n    - 通过 `.finally()` 方法处理无论成功还是失败都要执行的代码。\n3. **Promise 链式调用**:   \n    - 每次调用 `.then()` 或 `.catch()` 方法都会返回一个新的 Promise 对象。\n    - 可以将多个 Promise 操作串联起来,形成 Promise 链。\n    - 下一个 `.then()` 方法会等待上一个 Promise 完成后再执行。\n```js\nnew Promise((resolve, reject) => {\n  // 执行一些异步操作\n  if (/* 操作成功 */) {\n    resolve(result);\n  } else {\n    reject(error);\n  }\n})\n.then(result => {\n  // 处理成功的结果\n})\n.catch(error => {\n  // 处理失败的情况\n})\n.finally(() => {\n  // 无论成功还是失败都会执行的代码\n});\n```\n- resolve不同值的区别\n1. **传递普通值**\n    ```js\n    new Promise((resolve, reject) => {\n      resolve('success');\n    })\n    .then(result => {\n      console.log(result); // 输出: 'success'\n    })\n    .catch(error => {\n      console.error(error);\n    });\n    ```\n    - 如果 `resolve()` 函数传递一个普通值,这个值会作为 Promise 的 resolve 结果被传递到后续的 `.then()` 方法中。\n2. **传递 Promise 对象**\n    ```js\n    new Promise((resolve, reject) => {\n      resolve(\n        new Promise((innerResolve, innerReject) => {\n          setTimeout(() => {\n            innerResolve('inner promise result');\n          }, 2000);\n        })\n      );\n    })\n    .then(result => {\n      console.log(result); // 输出: 'inner promise result'\n    })\n    .catch(error => {\n      console.error(error);\n    });\n    ```\n    - 如果 `resolve()` 函数传递的是另一个 Promise 对象,那么外层 Promise 的状态会跟随内层 Promise 的状态进行变化。\n    - 外层 Promise 会\"等待\"内层 Promise 完成,然后采用内层 Promise 的状态和结果。\n3. **传递 thenable 对象**\n    ```js\n    const myThenable = {\n      then(resolve, reject) {\n        resolve('thenable result');\n      }\n    };\n    \n    new Promise((resolve, reject) => {\n      resolve(myThenable);\n    })\n    .then(result => {\n      console.log(result); // 输出: 'thenable result'\n    })\n    .catch(error => {\n      console.error(error);\n    });\n    ```\n    - 如果 `resolve()` 函数传递的是一个具有 `.then()` 方法的对象(称为 thenable 对象),那么 Promise 会\"等待\"这个对象执行完 `.then()` 方法,并采用其返回的结果。\n4. **传递 throw 或 reject()**\n    ```js\n    new Promise((resolve, reject) => {\n      reject(new Error('Something went wrong'));\n    })\n    .then(result => {\n      console.log(result);\n    })\n    .catch(error => {\n      console.error(error); // 输出: Error: Something went wrong\n    });\n    ```\n    - 如果在 Promise 执行器函数内部调用 `throw` 或 `reject()` 函数,那么 Promise 的状态会变为 `rejected`。\n    - 后续的 `.catch()` 方法会捕获到这个错误,并进行处理。\n# ES8~ES13\n## ES8中对象的相关属性\n1. **Object.values()**:\n    - 该方法返回一个给定对象自身的所有可枚举属性值的数组。\n    - 它的行为与 `Object.keys()` 类似,但返回的是属性值,而不是属性名。\n2. **Object.entries()**:\n    - 该方法返回一个给定对象自身可枚举字符串键属性 `[key, value]` 的数组。\n    - 这个方法提供了一种迭代一个对象的所有属性的便捷方式。\n3. **Object.getOwnPropertyDescriptors()**:\n    - 该方法返回指定对象所有自身属性的描述符。\n    - 这个方法在 `Object.create()` 时很有用,用于实现属性的复制和继承。\n4. **Trailing commas**:\n    - Trailing commas 允许在对象字面量、数组字面量、函数参数列表和函数调用中使用尾随逗号。\n    - 这可以使代码更容易维护和扩展,因为添加新属性或参数不会影响前面的代码。\n5. **Async functions**:\n    - Async functions 是 ES8 中引入的一个重要特性,用于简化异步编程。\n    - Async 函数返回一个 Promise 对象,可以使用 `await` 关键字来等待 Promise 完成。\n## ES8-padStart和padEnd\n- `padStart(targetLength, [padString])` 方法将当前字符串填充到指定的长度。填充从字符串的开始(左侧)应用的。\n```js\n// 用 '0' 填充到长度 5\nconsole.log('42'.padStart(5, '0')); // Output: '00042'\n\n// 用空格填充到长度 10\nconsole.log('foo'.padStart(10)); // Output: '       foo'\n```\n- `padEnd(targetLength, [padString])` 方法将当前字符串填充到指定的长度。填充从字符串的末尾(右侧)应用的。\n```js\n// 用 '.' 填充到长度 5\nconsole.log('hello'.padEnd(5, '.')); // Output: 'hello.'\n\n// 用空格填充到长度 10\nconsole.log('foo'.padEnd(10)); // Output: 'foo        '\n```\n\n这些方法在处理金额、日期、编号等数据格式时非常有用,可以帮助我们快速地格式化字符串。\n```js\n// 格式化金额\nconst amount = 123.45;\nconsole.log(amount.toFixed(2).padStart(10, '0')); // Output: '0000123.45'\n\n// 格式化日期\nconst date = '2023-5-1';\nconsole.log(date.padStart(10, '0')); // Output: '2023-05-01'\n\n// 隐藏卡号\nfunction hideIdCard(idCard) {\n  return idCard.slice(-4).padStart(18, '*');\n}\n\nconsole.log(hideIdCard('123456789012345678')); // Output: ***************5678\n\nfunction hideBankCard(bankCard) {\n  const length = bankCard.length;\n  const front = bankCard.slice(0, 4);\n  const back = bankCard.slice(-4);\n  return front + '*'.repeat(length - 8) + back;\n}\n\nconsole.log(hideBankCard('1234567890123456')); // Output: 1234************3456\nconsole.log(hideBankCard('123456789012345678')); // Output: 1234************5678\n```\n## ES9-Object spread operators\n1. **Spread 操作符 (`...`)**\nSpread 操作符可以在对象字面量中使用,用于展开一个现有的对象,将其属性复制到新的对象中。\n```js\nconst originalObj = { a: 1, b: 2 };\nconst newObj = { ...originalObj, c: 3 };\n\nconsole.log(newObj); // Output: { a: 1, b: 2, c: 3 }\n```\n在上面的例子中,我们使用 Spread 操作符 `...` 将 `originalObj` 的属性复制到 `newObj` 中,并添加了一个新的属性 `c`。\n2. **合并多个对象**\nSpread 操作符可以方便地合并多个对象:\n```js\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\nconst mergedObj = { ...obj1, ...obj2 };\n\nconsole.log(mergedObj); // Output: { a: 1, b: 3, c: 4 }\n```\n在这个例子中,我们使用多个 Spread 操作符将 `obj1` 和 `obj2` 的属性合并到 `mergedObj` 中。当有重复的属性时,后面的对象的属性会覆盖前面对象的属性。\n3. **与解构赋值结合使用**\nSpread 操作符也可以与对象解构赋值结合使用:\n```js\nconst originalObj = { a: 1, b: 2, c: 3 };\nconst { a, ...rest } = originalObj;\n\nconsole.log(a); // Output: 1\nconsole.log(rest); // Output: { b: 2, c: 3 }\n```\n在这个例子中,我们使用对象解构赋值提取 `a` 属性,并使用 Spread 操作符将剩余的属性赋值给 `rest` 对象。\n4. **浅拷贝和深拷贝**\n需要注意的是,Spread 操作符只能进行**浅拷贝**,如果对象中嵌套了其他对象或数组,则需要使用其他方法实现**深拷贝**。\n```js\nconst originalObj = { a: 1, b: { c: 2 } };\nconst newObj = { ...originalObj };\n\nconsole.log(newObj.b === originalObj.b); // Output: true (浅拷贝)\n```\n## ES10-flat flatMap\n1. **`flat()`**\n`flat()` 方法用于将嵌套数组\"拉平\"为一维数组。它接受一个可选的 `depth` 参数,指定要提取嵌套数组的深度。如果不传 `depth` 参数,默认深度为 1。\n```js\nconst nestedArray = [1, [2, 3], [4, [5, 6]]];\n\nconsole.log(nestedArray.flat()); // Output: [1, 2, 3, 4, [5, 6]]\nconsole.log(nestedArray.flat(2)); // Output: [1, 2, 3, 4, 5, 6]\n```\n在上面的例子中,第一个 `flat()` 调用将数组拉平一层,第二个调用将数组拉平两层。\n2. **`flatMap()`**\n`flatMap()` 是 `map()` 和 `flat()` 的组合。它首先使用提供的映射函数映射每个元素,然后将结果压缩成一个新数组。\n```js\nconst arr = [1, 2, 3, 4];\n\nconst doubledAndFlattened = arr.flatMap(x => [x, x * 2]);\nconsole.log(doubledAndFlattened); // Output: [1, 2, 2, 4, 3, 6, 4, 8]\n```\n在上面的例子中,我们使用 `flatMap()` 将每个元素映射为一个包含原始值和其双倍值的数组,然后将这些数组压缩成一个新数组。\n`flatMap()` 的好处是,它可以在一步操作中完成映射和拉平操作,相比于先使用 `map()` 再使用 `flat()`,效率更高。\n## ES10-Object.fromEntries\n1. **`Object.entries()`**\n`Object.entries()` 方法返回一个给定对象自身可枚举字符串属性 `[key, value]` 对组成的数组。\n```js\nconst obj = { a: 1, b: 2, c: 3 };\nconst entries = Object.entries(obj);\n\nconsole.log(entries); // Output: [['a', 1], ['b', 2], ['c', 3]]\n```\n这个方法在需要遍历对象属性时非常有用,比如使用 `for...of` 循环:\n```js\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(key, value);\n}\n// Output:\n// a 1\n// b 2\n// c 3\n```\n\n2. **`Object.fromEntries()`**\n`Object.fromEntries()` 方法执行与 `Object.entries()` 逆向操作,将一个键值对列表转换为一个对象。\n```js\nconst entries = [['a', 1], ['b', 2], ['c', 3]];\nconst obj = Object.fromEntries(entries);\n\nconsole.log(obj); // Output: { a: 1, b: 2, c: 3 }\n```\n这个方法在需要从其他数据结构(如 Map)转换为对象时非常有用:\n```js\nconst map = new Map([['a', 1], ['b', 2]]);\nconst obj = Object.fromEntries(map);\n\nconsole.log(obj); // Output: { a: 1, b: 2 }\n```\n应用场景\n![[Pasted image 20240812145943.png]]\n## ES10-trimStart trimEnd\n`trim()`, `trimStart()` 和 `trimEnd()` 是 JavaScript 中用于删除字符串两端空白字符的三个方法。\n1. **`trim()`**\n`trim()` 方法返回一个新的字符串,其中从字符串的两端删除了所有空白字符。\n```js\nconst str = \"   Hello, world!   \";\n\nconsole.log(str.trim()); // Output: \"Hello, world!\"\n```\n\n2. **`trimStart()`**\n`trimStart()` 方法返回一个新的字符串,其中从字符串的开头删除了所有空白字符。\n```js\nconst str = \"   Hello, world!   \";\n\nconsole.log(str.trimStart()); // Output: \"Hello, world!   \"\n```\n\n3. **`trimEnd()`**\n`trimEnd()` 方法返回一个新的字符串,其中从字符串的末尾删除了所有空白字符。\n```js\nconst str = \"   Hello, world!   \";\n\nconsole.log(str.trimEnd()); // Output: \"   Hello, world!\"\n```\n这三个方法的主要区别在于它们删除空白字符的位置:\n- `trim()` 删除字符串两端的空白字符\n- `trimStart()` 删除字符串开头的空白字符\n- `trimEnd()` 删除字符串末尾的空白字符\n## ES11-BigInt\n要表示大于NUmber.MAX_SAFE_INTEGER的数值，需要在数值后面加上n![[Pasted image 20240812151216.png]]\n## ES11-Nullish Coalescing Operator (空值合并运算符)\nNullish Coalescing Operator (空值合并运算符) 是 ECMAScript 2020 (ES11) 引入的一个新的运算符,它可以帮助我们处理 `null` 和 `undefined` 值。\n这个运算符的符号是 `??`它的工作原理是:\n1. 如果左侧的操作数不是 `null` 或 `undefined`，则返回左侧的操作数。\n2. 如果左侧的操作数是 `null` 或 `undefined`，则返回右侧的操作数。\n下面是一些例子:\n```js\n// 基本用法\nconst username = '';\nconst displayName = username ?? 'Guest'; // 输出: 'Guest'\n\nconst age = 0;\nconst defaultAge = age ?? 30; // 输出: 0\n\n// 与逻辑OR (||) 运算符的比较\nconst username2 = '';\nconst displayName2 = username2 || 'Guest'; // 输出: 'Guest'\n```\n在上面的例子中,当 `username` 为空字符串时,逻辑 OR (`||`) 运算符将返回 `'Guest'`。但是,空字符串在 JavaScript 中是一个有效的值,我们可能不希望将其视为\"falsy\"。这时,Nullish Coalescing Operator 就很有用,它只会在值为 `null` 或 `undefined` 时返回右侧操作数。\n\n另一个常见的用例是设置默认值:\n```js\nfunction greet(name) {\n  const displayName = name ?? 'Guest';\n  console.log(`Hello, ${displayName}!`);\n}\n\ngreet(null); // 输出: \"Hello, Guest!\"\ngreet(''); // 输出: \"Hello, !\"\ngreet('John'); // 输出: \"Hello, John!\"\n```\n在这个例子中,如果 `name` 参数是 `null` 或 `undefined`，Nullish Coalescing Operator 会将 `displayName` 设置为 `'Guest'`。但如果 `name` 是一个空字符串,它仍然会被使用,因为空字符串不是 `null` 或 `undefined`。\n## ES11-Optional Chaining (可选链)\nOptional Chaining (可选链) 是 ECMAScript 2020 (ES11) 引入的一个新的运算符,用于安全地访问嵌套对象的属性。它的符号是 `?.`\nOptional Chaining 可以帮助我们避免在访问嵌套对象属性时出现的 `TypeError: Cannot read property 'x' of undefined` 错误。\n下面是一些例子:\n```js\n// 不使用可选链\nlet adventurer = {\n  name: 'Alice',\n  cat: {\n    name: 'Dinah'\n  }\n};\n\nconsole.log(adventurer.dog.name); // TypeError: Cannot read property 'name' of undefined\n\n// 使用可选链\nlet adventurer2 = {\n  name: 'Alice',\n  cat: {\n    name: 'Dinah'\n  }\n};\n\nconsole.log(adventurer2?.dog?.name); // undefined\n```\n在第一个例子中,尝试访问 `adventurer.dog.name` 会抛出 `TypeError`,因为 `adventurer.dog` 是 `undefined`。\n但在第二个例子中,使用 Optional Chaining 运算符 `?.` 可以安全地访问嵌套属性。如果 `adventurer2.dog` 是 `undefined`,则整个表达式的结果也是 `undefined`,而不会抛出错误。\n\nOptional Chaining 也可以与函数调用一起使用:\n```js\nlet customer = {\n  name: 'Carl',\n  address: {\n    city: 'Seattle'\n  }\n};\n\nconsole.log(customer.address.city); // 'Seattle'\nconsole.log(customer.address?.city); // 'Seattle'\nconsole.log(customer.address?.getZipCode?.());  // undefined\n```\n在最后一个例子中,即使 `customer.address.getZipCode` 不存在,使用 Optional Chaining 也不会抛出错误,而是返回 `undefined`。\n## ES12-FinalizationRegistry\nFinalizationRegistry 是 ECMAScript 2021 (ES12) 引入的一个新的 API,它允许在对象被垃圾回收时执行自定义的清理逻辑。\nFinalizationRegistry 的主要用途是:\n1. **监听对象的清理**:当一个对象被垃圾回收时,FinalizationRegistry 会通知注册的回调函数。这可以用于执行清理操作,比如释放资源、发送通知等。\n2. **避免内存泄漏**:FinalizationRegistry 可以帮助开发者避免内存泄漏,因为它可以确保在对象被销毁时执行清理逻辑。\n 示例:\n```js\n// 创建FinalizationRegistry实例\nconst registry = new FinalizationRegistry((value) => {\n  console.log(`Finalized: ${value}`);\n});\n\n// 注册对象\nconst obj = { id: 1 };\nregistry.register(obj, 'object-1');\n\n// 手动触发垃圾回收\nobj = null;\nglobal.gc(); // 在Node.js中手动触发\n\n// 输出: Finalized: object-1\n```\n在上述示例中:\n1. 我们创建了一个 FinalizationRegistry 实例,并传入一个回调函数,该函数将在对象被垃圾回收时被调用。\n2. 我们注册了一个对象 `obj` 到 FinalizationRegistry,并为其提供了一个标识符 `'object-1'`。\n3. 我们手动将 `obj` 设置为 `null`,然后调用 `global.gc()` 来触发垃圾回收(在 Node.js 中,需要使用 `--expose-gc` 标志来启用手动垃圾回收)。\n4. 当对象被垃圾回收时,FinalizationRegistry 会调用我们提供的回调函数,并输出 `'Finalized: object-1'`。\nFinalizationRegistry 的一个主要优点是,它不会阻止对象被垃圾回收。相反,它会在对象被回收后执行清理逻辑,这使得它比 `WeakMap` 和 `WeakSet` 更加灵活和强大。\nFinalizationRegistry 的典型用例包括:\n- 清理 DOM 元素和事件监听器\n- 关闭数据库连接或释放其他系统资源\n- 发送对象销毁的通知\n## ES12-WeakRefs\nWeakRef 是 ECMAScript 2021 (ES12) 引入的一个新的 API,它允许创建对对象的\"弱引用\"。这意味着被引用的对象可以被垃圾回收器回收,即使还有 WeakRef 引用它。\n主要用途:\n1. **避免内存泄漏**: 由于 WeakRef 不会妨碍对象被垃圾回收,因此可以帮助开发者避免内存泄漏的问题。\n2. **缓存模式**: WeakRef 可以用于实现一种\"缓存模式\",在需要时重新创建对象,而不是持有永久引用。\n3. **观察对象生命周期**: WeakRef 可以用于观察对象的生命周期,并在对象被垃圾回收时执行相应的清理操作。\n示例:\n```js\n// 创建一个对象\nconst obj = { id: 1 };\n\n// 创建一个 WeakRef 实例\nconst weakRef = new WeakRef(obj);\n\n// 手动触发垃圾回收\nobj = null;\nglobal.gc(); // 在Node.js中手动触发\n\n// 尝试访问 WeakRef 持有的对象\nconst refObj = weakRef.deref();\nif (refObj) {\n  console.log(refObj.id); // 输出 1\n} else {\n  console.log('Object has been garbage collected');\n}\n```\n1. 我们创建了一个对象 `obj`。\n2. 我们使用 `new WeakRef(obj)` 创建了一个 WeakRef 实例,它持有对 `obj` 的引用。\n3. 我们手动将 `obj` 设置为 `null`,然后调用 `global.gc()` 来触发垃圾回收(在 Node.js 中,需要使用 `--expose-gc` 标志来启用手动垃圾回收)。\n4. 我们尝试使用 `weakRef.deref()` 方法访问 WeakRef 持有的对象。如果对象还存在,则输出 `1`。否则,输出 `'Object has been garbage collected'`。\n\nWeakRef 的一个主要特点是,它不会阻止被引用的对象被垃圾回收。相反,一旦对象没有其他强引用,它就可以被垃圾回收,即使还有 WeakRef 引用它。这使得 WeakRef 非常适合于缓存模式和生命周期观察等用例\nWeakRef 通常与 FinalizationRegistry 配合使用,后者可以在对象被垃圾回收时执行清理逻辑。这种组合可以帮助开发者更好地管理内存和系统资源。\n## ES13-method.at()\n`method.at()` 是 ECMAScript 2022 (ES13) 引入的一个新的数组方法,它允许使用索引值访问数组元素,并且可以接受负值索引。\n特点:\n1. **支持负值索引**: `at()` 方法可以接受负值索引,这意味着可以从数组末尾开始计数。例如, `arr.at(-1)` 返回数组的最后一个元素。\n2. **返回 undefined 而不是抛出错误**: 如果使用无效的索引值(例如索引超出数组范围),`at()` 方法不会抛出错误,而是返回 `undefined`。\n3. **更简洁的语法**: `at()` 方法提供了一种更简洁的语法来访问数组元素,相比于使用方括号语法 (`arr[index]`) 更加直观。\n示例:\n```js\nconst arr = [1, 2, 3, 4, 5];\n\nconsole.log(arr.at(2)); // 输出: 3\nconsole.log(arr.at(-1)); // 输出: 5\n\nconsole.log(arr.at(10)); // 输出: undefined\n```\n## ES13-Object.hasOwn(obj, prop)\n`Object.hasOwn()` 是 ECMAScript 2022 (ES13) 引入的一个新的静态方法,它用于检查一个对象是否包含指定的属性。这个方法是 `Object.prototype.hasOwnProperty()` 方法的一种更简洁的替代方式。\n特点:\n1. **更简洁的语法**: `Object.hasOwn(obj, prop)` 方法提供了一种更简洁的语法来检查对象是否包含指定的属性,相比于使用 `obj.hasOwnProperty(prop)` 更加简洁。   \n2. **更安全的属性检查**: `Object.hasOwn()` 避免了原型污染问题,因为它直接在对象上检查属性,而不会受到原型链上的属性影响。这使得它更安全地用于检查对象属性。   \n3. **支持 null 和 undefined**: 与 `obj.hasOwnProperty(prop)` 不同, `Object.hasOwn()` 可以接受 `null` 或 `undefined` 作为第一个参数,并在这种情况下返回 `false`。\n示例:\n```js\nconst obj = { name: 'John', age: 30 };\n\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'address')); // false\n\nconsole.log(Object.hasOwn(null, 'name')); // false\nconsole.log(Object.hasOwn(undefined, 'name')); // false\n```\n与 `obj.hasOwnProperty(prop)` 语法相比, `Object.hasOwn()` 的优势优势:\n- 更简洁的语法,更容易阅读和理解。\n- 避免了原型污染问题,更安全地检查对象属性。\n- 可以处理 `null` 和 `undefined` 参数,返回 `false`。\n# Proxy-Reflect\n## Proxy基本使用\n- 如果我们希望 *监听一个对象的相关操作*，那么我们可以 *先创建一个代理对象（Proxy对象）*\n- 之后通过对代理对象的操作来监听我们想要对原对象进行的操作\n步骤：\n- 首先需要 *new Proxy对象*，并且传入需要监听的对象以及一个处理对象，称之为handler \n`const p = new Proxy(target, handler)`\n- 其次， *我们之后的操作都是直接对Proxy的操作*，而不是原有的对象，因为我们需要在handler里\n## Proxy的捕获器\n如果想要监听某些具体的操作，就可以在handler中添加对应的 *捕获器*\n![[Pasted image 20240812213843.png]]\n\n- set函数有4个参数\n\t- target：目标对象（监听的对象）\n\t- property：将被设置的属性key\n\t- value：新属性值\n\t- receiver：调用的代理对象\n- get函数有3个参数\n\t- target：目标对象（监听的对象）\n\t- property：将被设置的属性key\n\t- receiver：调用的代理对象\n```js\n<script>\n\n    const obj = {\n      name: \"why\",\n      age: 18,\n      height: 1.88\n    }\n\n    const objProxy = new Proxy(obj, {\n      set: function(target, key, value) {\n        console.log(`属性${key}被设置成${value}`)\n        target[key] = value\n      },\n      get: function(target, key) {\n        console.log(`属性${key}被读取`)\n        return target[key] // 这里返回target[key]，可以让属性的读取操作正常进行\n      }\n    })\n\n    objProxy.address = \"四川省\"\n    console.log(objProxy.address) // 四川省\n    objProxy.age = 20\n\n  </script>\n```\n![[Pasted image 20240812215441.png]]\n## Reflect\n- 作用：Reflect 是 JavaScript 中的一个内置对象,它提供了一组方法和属性,用于更好地反映和操作对象。相比于直接使用对象的属性和方法,Reflect 提供了一些额外的功能和便利。\n- 与Object的区别： Reflect 与 Object 的方法名称很相似,但 Reflect 方法会返回操作结果,而 Object 方法则会返回操作对象本身。![[Pasted image 20240813000221.png]]\n- 常见方法：\n1. **获取属性值**:\n    - `Reflect.get(target, property[, receiver])`: 获取对象 `target` 的属性 `property` 的值。\n2. **设置属性值**:\n    - `Reflect.set(target, property, value[, receiver])`: 设置对象 `target` 的属性 `property` 的值为 `value`。\n3. **删除属性**:\n    - `Reflect.deleteProperty(target, property)`: 删除对象 `target` 的属性 `property`。\n4. **检查属性是否存在**:\n    - `Reflect.has(target, property)`: 检查对象 `target` 是否拥有属性 `property`。\n5. **获取对象原型**:\n    - `Reflect.getPrototypeOf(target)`: 获取对象 `target` 的原型。\n6. **设置对象原型**:\n    - `Reflect.setPrototypeOf(target, prototype)`: 设置对象 `target` 的原型为 `prototype`\n7. **判断对象是否可扩展**:\n    - `Reflect.isExtensible(target)`: 判断对象 `target` 是否可扩展。\n8. **冻结对象**:\n    - `Reflect.preventExtensions(target)`: 让对象 `target` 变为不可扩展。\n9. **获取自身属性描述符**:\n    - `Reflect.getOwnPropertyDescriptor(target, property)`: 获取对象 `target` 的属性 `property` 的描述符。\n10. **定义属性**:\n    - `Reflect.defineProperty(target, property, descriptor)`: 在对象 `target` 上定义属性 `property`。\n11. **调用函数**:\n    - `Reflect.apply(target, thisArgument, argumentsList)`: 使用给定的 `this` 值和参数列表调用目标函数。\n12. **使用 new 创建实例**:\n    - `Reflect.construct(target, argumentsList[, newTarget])`: 使用给定的构造函数 `target` 和参数列表创建一个新实例。\n![[Pasted image 20240813000437.png]]\n```js\n<script>\n\n    const obj = {\n      name: \"why\",\n      age: 18,\n      get info() {\n        return this.name\n      }\n    }\n\n    const objProxy = new Proxy(obj, {\n      set(target, key, value, receiver) {\n\n        // target[key] = value\n        // return true\n        // 好处1、代理对象的目的：不再直接操作原对象\n        // 好处2、Reflect.set()方法可以返回一个布尔值，表示是否设置成功\n        /* 好处3、\n          reciver === objProxy,就是外层的Proxy对象\n          Reflect.set/get最后一个参数receiver可以决定对象访问器的setter/getter的this指向\n        */\n        console.log(\"Proxy中的设置方法被调用\")\n        const isSuccess = Reflect.set(target, key, value)\n\n        if(!isSuccess) {\n          throw new Error(\"set failed\")\n        }\n      },\n      get(target, key, receiver) {\n        console.log(\"Proxy中的获取方法被调用\")\n        return Reflect.get(target, key, receiver)\n      }\n    })\n\n    objProxy.name = \"kobe\"\n    console.log(objProxy.info)\n\n```\n# Promise\n## 异步任务的处理\n- 我们调用一个函数，这个函数中发送网络请求\n- 如果 *发送网络请求成功了*，那么告知调用者发送成功，并且返回相关数据\n- 如果 *发送网络请求失败了*，那么告知调用者发送失败，并且告知错误信息![[Pasted image 20240816165910.png]]\n## Promise的基本使用\n- Promise是一个类，当我们需要的时候，给予调用者一个承诺：待会儿回调函数的时候，就可以创建一个Promise对象\n- 在通过new创建Promise对象时，我们需要传入一个回调函数，称为executor\n\t- 这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject\n\t- 调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数\n\t- 调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数![[Pasted image 20240816172919.png]]\n```js\n<script>\n\n    function execCode(counter) {\n      // 异步处理\n      const promise = new Promise((resolve, reject) => {\n        // 模拟异步处理\n        if(counter > 0) {\n          let total = 0\n          for(let i = 0; i < counter; i++) {\n            total += i\n          }\n          resolve(total)\n        } else {\n          reject(`${counter}输入错误`)\n        }\n      })\n      return promise\n    }\n\n    execCode(5).then(sucessed => {\n      console.log(\"成功：\", sucessed)\n    }).catch(error => {\n      console.log(\"失败：\", error)\n    })\n\n    execCode(-5).then(sucessed => {\n      console.log(\"成功：\", sucessed)\n    }).catch(error => {\n      console.log(\"失败：\", error)\n    })\n\n  </script>\n```\n## resolve不同值\n1. **传递普通值**\n    ```js\n    new Promise((resolve, reject) => {\n      resolve('success');\n    })\n    .then(result => {\n      console.log(result); // 输出: 'success'\n    })\n    .catch(error => {\n      console.error(error);\n    });\n    ```\n    - 如果 `resolve()` 函数传递一个普通值,这个值会作为 Promise 的 resolve 结果被传递到后续的 `.then()` 方法中。\n2. **传递 Promise 对象**\n    ```js\n    new Promise((resolve, reject) => {\n      resolve(\n        new Promise((innerResolve, innerReject) => {\n          setTimeout(() => {\n            innerResolve('inner promise result');\n          }, 2000);\n        })\n      );\n    })\n    .then(result => {\n      console.log(result); // 输出: 'inner promise result'\n    })\n    .catch(error => {\n      console.error(error);\n    });\n    ```\n    - 如果 `resolve()` 函数传递的是另一个 Promise 对象,那么外层 Promise 的状态会跟随内层 Promise 的状态进行变化。\n    - 外层 Promise 会\"等待\"内层 Promise 完成,然后采用内层 Promise 的状态和结果。\n3. **传递 thenable 对象**\n    ```js\n    const myThenable = {\n      then(resolve, reject) {\n        resolve('thenable result');\n      }\n    };\n    \n    new Promise((resolve, reject) => {\n      resolve(myThenable);\n    })\n    .then(result => {\n      console.log(result); // 输出: 'thenable result'\n    })\n    .catch(error => {\n      console.error(error);\n    });\n    ```\n    - 如果 `resolve()` 函数传递的是一个具有 `.then()` 方法的对象(称为 thenable 对象),那么 Promise 会\"等待\"这个对象执行完 `.then()` 方法,并采用其返回的结果。\n4. **传递 throw 或 reject()**\n    ```js\n    new Promise((resolve, reject) => {\n      reject(new Error('Something went wrong'));\n    })\n    .then(result => {\n      console.log(result);\n    })\n    .catch(error => {\n      console.error(error); // 输出: Error: Something went wrong\n    });\n    ```\n    - 如果在 Promise 执行器函数内部调用 `throw` 或 `reject()` 函数,那么 Promise 的状态会变为 `rejected`。\n    - 后续的 `.catch()` 方法会捕获到这个错误,并进行处理。\n## then的返回值\n`Promise` 的 `then` 方法的返回值是一个新的 `Promise` 对象。这个返回值可以用于实现链式调用。\n- 关键点\n1. **成功回调的返回值**:\n    - 如果在 `then` 的成功回调中返回一个值，这个值将作为下一个 `then` 的输入。\n    - 如果返回的是一个 `Promise`，下一个 `then` 将等待该 `Promise` 完成。\n2. **失败回调的返回值**:\n    - 如果在 `then` 的失败回调中返回一个值，该值将被忽略，链中的下一个 `then` 将继续执行。\n    - 如果返回的是一个 `Promise`，同样会等待下一个 `Promise` 完成。\n-  示例\n```JS\nconst promise = new Promise((resolve, reject) => {\n    resolve(42);\n});\n\npromise\n    .then(result => {\n        console.log(result); // 输出: 42\n        return result + 1; // 返回 43\n    })\n    .then(result => {\n        console.log(result); // 输出: 43\n        return Promise.resolve(result + 1); // 返回一个新的 Promise\n    })\n    .then(result => {\n        console.log(result); // 输出: 44\n    });\n```\n## catch的返回值\n`Promise` 的 `catch` 方法的返回值也会是一个新的 `Promise` 对象，具有和 `then` 方法相似的特性。具体来说，`catch` 主要用于处理链中的错误，但是它的返回值可以影响后续的链式调用。\n\n-  关键点\n1. **处理错误并返回值**:\n    - 如果 `catch` 处理了错误并返回一个值，这个值将作为后续链中下一个 `then` 的输入。\n2. **返回新 Promise**:\n    - 如果在 `catch` 中返回一个 `Promise`，下一个 `then` 会等待这个 `Promise` 完成，然后将结果传递下去。\n-  示例\n```JS\nconst promise = new Promise((resolve, reject) => {\n    reject('出错了');\n});\n\npromise\n    .then(result => {\n        console.log(result); // 不会执行\n    })\n    .catch(error => {\n        console.error(error); // 输出: 出错了\n        return '处理完毕'; // 返回一个字符串\n    })\n    .then(result => {\n        console.log(result); // 输出: 处理完毕\n    });\n```\n- 如果我们希望后续继续执行catch，那么需要抛出一个异常![[Pasted image 20240816202837.png]]\n## finally的回调\n`Promise` 的 `finally` 方法用于在 `Promise` 操作结束后执行一个回调函数，无论是成功还是失败。这使得 `finally` 非常适合用于清理或执行一些始终需要进行的操作，比如关闭文件、清理资源等。\n- 特点\n1. **不影响链的结果**:\n    - `finally` 的回调不会接收 `Promise` 的结果或错误。\n    - 无论前面的 `then` 或 `catch` 是否成功，`finally` 始终会执行。\n2. **返回值**:\n    - `finally` 返回一个新的 `Promise`，其解析方式与前面的 `Promise` 一致。\n    - 如果在 `finally` 中返回一个值或 `Promise`，将不会影响前面 `then` 或 `catch` 的结果。\n-  示例\n```JS\nconst promise = new Promise((resolve, reject) => {\n    const success = true; // 模拟操作成功或失败\n\n    if (success) {\n        resolve('成功');\n    } else {\n        reject('失败');\n    }\n});\n\npromise\n    .then(result => {\n        console.log(result); // 输出: 成功\n    })\n    .catch(error => {\n        console.error(error); // 不会执行\n    })\n    .finally(() => {\n        console.log('清理操作'); // 输出: 清理操作\n    });\n```\n## Promise类方法\n`Promise` 的类方法提供了用于创建和操作 `Promise` 实例的多种功能。以下是主要的 `Promise` 类方法及其描述：\n### 1. `Promise.resolve(value)`\n- **功能**: 返回一个以给定值解析后的 `Promise` 对象。\n- **示例**:\n```JS\nconst promise1 = Promise.resolve(42);\npromise1.then(value => console.log(value)); // 输出: 42\n```\n\n### 2. `Promise.reject(reason)`\n- **功能**: 返回一个以给定原因拒绝后的 `Promise` 对象。\n- **示例**:\n```JS\nconst promise2 = Promise.reject('出错了');\npromise2.catch(error => console.error(error)); // 输出: 出错了\n```\n### 3. `Promise.all(iterable)`\n- **功能**: 接受一个可迭代对象（如数组），当所有 `Promise` 都已成功时，返回一个新的 `Promise`，并解析为一个数组，包含所有 `Promise` 的结果。如果其中任何一个 `Promise` 被拒绝，它将立即返回拒绝状态。\n- **示例**:\n```JS\nconst promise3 = Promise.all([\n    Promise.resolve(1),\n    Promise.resolve(2),\n    Promise.resolve(3)\n]);\n\npromise3.then(values => {\n    console.log(values); // 输出: [1, 2, 3]\n});\n```\n\n### 4. `Promise.allSettled(iterable)`\n- **功能**: 接受一个可迭代对象，返回一个新的 `Promise`，当所有 `Promise` 的状态都已确定时（不论成功还是失败），以数组的形式解析，数组中的每个对象描述了每个 `Promise` 的结果。\n- **示例**:\n```JS\nconst promise4 = Promise.allSettled([\n    Promise.resolve(1),\n    Promise.reject('失败'),\n    Promise.resolve(3)\n]);\n\npromise4.then(results => {\n    console.log(results);\n    // 输出: [\n    //   { status: 'fulfilled', value: 1 },\n    //   { status: 'rejected', reason: '失败' },\n    //   { status: 'fulfilled', value: 3 }\n    // ]\n});\n```\n\n### 5. `Promise.any(iterable)`\n- **功能**: 接受一个可迭代对象，返回一个新的 `Promise`。只要有一个 `Promise` 成功，它就会解析为那个成功的值。如果所有 `Promise` 都被拒绝，则返回一个拒绝的 `Promise`，其理由是一个 `AggregateError`。\n- **示例**:\n```JS\nconst promise5 = Promise.any([\n    Promise.reject('失败1'),\n    Promise.resolve(3),\n    Promise.reject('失败2')\n]);\n\npromise5.then(value => {\n    console.log(value); // 输出: 3\n});\n```\n\n### 6. `Promise.race(iterable)`\n- **功能**: 接受一个可迭代对象，返回一个新的 `Promise`，只要有一个 `Promise` 完成或被拒绝，返回的 `Promise` 就会返回这个完成或被拒绝的值。\n- **示例**:\n```JS\nconst promise6 = Promise.race([\n    new Promise((resolve) => setTimeout(() => resolve('快速完成'), 100)),\n    new Promise((resolve) => setTimeout(() => resolve('慢完成'), 200))\n]);\n\npromise6.then(value => {\n    console.log(value); // 输出: 快速完成\n});\n```\n# 迭代器和生成器\n## 什么是迭代器\n![[Pasted image 20240816214845.png]]![[Pasted image 20240816214905.png]]![[Pasted image 20240817154234.png]]\n## 自定义可迭代对象\n![[Pasted image 20240817155356.png]]\n## 可迭代对象的应用\n\n![[Pasted image 20240817162522.png]]\n## 什么是生成器\n![[Pasted image 20240817191031.png]]\n## 生成器函数参数返回值\n- 在中间位置直接return\n```js\nfunction* generatorFunction() {\n    yield 1;\n    yield 2;\n    return '结束'; // 在这里返回，终止生成器\n    yield 3; // 此行不会被执行\n}\n\nconst gen = generatorFunction();\n\nconsole.log(gen.next()); // 输出: { value: 1, done: false }\nconsole.log(gen.next()); // 输出: { value: 2, done: false }\nconsole.log(gen.next()); // 输出: { value: '结束', done: true }\nconsole.log(gen.next()); // 输出: { value: undefined, done: true }\n```\n- 给函数每次执行的时候传入参数\n```js\n<script>\n\n    function* foo(name1) {\n      console.log('内部：111');\n      console.log('内部：222');\n      const name2 = yield \"aaaa\"\n\n      console.log('内部：333');\n      console.log('内部：444');\n      const name3 = yield \"bbbb\"\n      console.log('内部：555'); \n      console.log('内部：666');\n      yield \"cccc\"\n      return undefined\n    }\n\n    const bar = foo(\"next1\")\n\n    console.log(bar.next()) // {value: \"aaaa\", done: false}\n    console.log(bar.next(\"next2\")) // {value: \"bbbb\", done: false}\n    console.log(bar.next(\"next3\")) // {value: \"cccc\", done: true}\n\n  </script>\n```\n## 生成器函数提前结束\n- 1. 使用 `return` 语句\n```JS\nfunction* generatorFunction() {\n    yield 1;\n    yield 2;\n    return '结束'; // 提前结束\n    yield 3; // 不会被执行\n}\n\nconst gen = generatorFunction();\n\nconsole.log(gen.next()); // 输出: { value: 1, done: false }\nconsole.log(gen.next()); // 输出: { value: 2, done: false }\nconsole.log(gen.next()); // 输出: { value: '结束', done: true }\nconsole.log(gen.next()); // 输出: { value: undefined, done: true }\n```\n\n- 2. 使用 `throw` 语句\n```JS\nfunction* generatorFunction() {\n    try {\n        yield 1;\n        yield 2;\n    } catch (e) {\n        console.log(e); // 捕获错误\n    }\n    yield 3; // 如果被抛出错误，将不会执行\n}\n\nconst gen = generatorFunction();\n\nconsole.log(gen.next()); // 输出: { value: 1, done: false }\nconsole.log(gen.next()); // 输出: { value: 2, done: false }\ngen.throw('捕获错误'); // 输出: 捕获错误\nconsole.log(gen.next()); // 输出: { value: undefined, done: true }\n```\n\n- 3. 使用 `return` 结合 `next()`\n```JS\nfunction* generatorFunction() {\n    yield 1;\n    yield 2;\n}\n\nconst gen = generatorFunction();\n\nconsole.log(gen.next()); // 输出: { value: 1, done: false }\nconsole.log(gen.return('提前结束')); // 输出: { value: '提前结束', done: true }\nconsole.log(gen.next()); // 输出: { value: undefined, done: true }\n```\n## 生成器替代迭代器\n```js\n<script>\n\n    function* foo(start, end) {\n      for(let i = start; i <= end; i++) {\n        yield i\n      }\n    }\n\n    const gen = foo(1, 10)\n    console.log(gen.next().value)\n    console.log(gen.next())\n    console.log(gen.next())\n    console.log(gen.next())\n    console.log(gen.next())\n    console.log(gen.next())\n    console.log(gen.next())\n    console.log(gen.next())\n    console.log(gen.next())\n    console.log(gen.next())\n\n    const names = ['Alice', 'Bob', 'Charlie', 'David']\n    function* nameGenerator() {\n      yield* names\n    }\n\n    const nameGen = nameGenerator()\n    console.log(nameGen.next().value)\n    console.log(nameGen.next().value)\n    console.log(nameGen.next().value)\n    console.log(nameGen.next().value)\n\n  </script>\n```\n## 异步处理方案\n```js\n <script>\n\n    /*\n      需求：\n      1、发送一次网络请求，等到这次网络请求的结果\n      2、再发送一次网络请求，并将这次网络请求的结果作为参数，再次发送网络请求\n      3、再次发送网络请求，并将这次网络请求的结果作为参数，再次发送网络请求\n      4、最后一次的网络请求的结果作为最终结果\n    */\n    // 异步请求代码结构\n    function requestData(url) {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          resolve(url)\n        }, 2000);\n      })\n    }\n\n    // 方法一：回调地域\n    // function getData() {\n    //   requestData(\"why\").then(res1 => {\n    //     console.log(\"第一次结果：\", res1)\n    //     requestData(res1 + \"aaa\").then(res2 => {\n    //       console.log(\"第二次结果：\", res2)\n    //       requestData(res2 + \"bbb\").then(res3 => {\n    //         console.log(\"第三次结果：\", res3)\n    //       })\n    //     })\n    //   })\n    // }\n\n    // 方法二：使用Promise进行重构（解决回调地狱）\n    // function getData() {\n    //   requestData(\"why\").then(res1 => {\n    //     console.log(\"第一次结果：\", res1)\n    //     return requestData(res1 + \"aaa\")\n    //   }).then(res2 => {\n    //     console.log(\"第二次结果：\", res2)\n    //     return requestData(res2 + \"bbb\")\n    //   }).then(res3 => {\n    //     console.log(\"第三次结果：\", res3)\n    //     requestData(res3 + \"ccc\")\n    //   })\n    // }\n\n    // 方法三：使用生成器进行重构\n    // function* getData() {\n    //   const res1 = yield requestData(\"why\")\n    //   console.log(\"第一次结果：\", res1)\n    //   const res2 = yield requestData(res1 + \"aaa\")\n    //   console.log(\"第二次结果：\", res2)\n    //   const res3 = yield requestData(res2 + \"bbb\")\n    //   console.log(\"第三次结果：\", res3)\n    // }\n\n    // const gen = getData()\n    // gen.next().value.then(res1 => {\n    //   gen.next(res1).value.then(res2 => {\n    //     gen.next(res2).value.then(res3 => {\n    //       gen.next(res3)\n    //     })\n    //   })\n    // })\n\n    // 方法四：使用async/await进行重构\n      async function getData() {\n        const res1 = await requestData(\"why\")\n        console.log(\"第一次结果：\", res1)\n        const res2 = await requestData(res1 + \"aaa\")\n        console.log(\"第二次结果：\", res2)\n        const res3 = await requestData(res2 + \"bbb\")\n        console.log(\"第三次结果：\", res3)\n      }\n    getData()\n\n  </script>\n```\n# async、await - 队列\n## 异步函数async function\n\n-\n## await关键字\n![[Pasted image 20240819154154.png]]\n处理异步请求\n```js\n<script>\n\n    function requestData() {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          reject(\"error message\")\n      }, 2000);\n    })\n  }\n\n  async function getData() {\n    const res1 = await requestData(\"why\")\n    console.log(res1)\n    const res2 = await requestData(\"how\")\n    console.log(res2)\n  }\n\n  getData().catch(err => {\n    console.log(err)\n  })\n\n  </script>\n```\n## 进程和线程\n![[Pasted image 20240819193235.png]]\n## 浏览器中的JavaScript线程\n![[Pasted image 20240819205046.png]]\n## 浏览器的事件循环\n![[Pasted image 20240819205801.png]]\n## 微任务和宏任务\n![[Pasted image 20240819210919.png]]\n## Promise面试题\n### 1\n```js\n<script>\n\n    console.log(\"script start\")\n    setTimeout(function () {\n      console.log(\"setTimeout1\")\n      new Promise(function (resolve) {\n        resolve()\n      }).then(function () {\n        new Promise(function (resolve) {\n          resolve()\n        }).then(function () {\n          console.log(\"then4\")\n        })\n        console.log(\"then2\")\n      })\n    })\n    \n    new Promise(function (resolve) {\n      console.log(\"promise1\")\n      resolve()\n    }).then(function () {\n      console.log(\"then1\")\n    })\n\n    setTimeout(function () {\n      console.log(\"setTimeout2\")\n    })\n\n    console.log(2)\n\n    queueMicrotask(() => {\n      console.log(\"queueMicrotask1\")\n    })\n\n    new Promise(function (resolve) {\n      resolve()\n    }).then(function () {\n      console.log(\"then3\")\n    })\n\n    console.log(\"script end\")\n    /*\n     代码执行顺序：\n      script start\n      promise1\n      2\n      script end\n\n      then1\n      queueMicrotask1\n      then3\n\n      setTimeout1\n      then2\n      then4\n\n      setTimeout2\n    */\n\n  </script>\n```\n### 2\n```js\n<script>\n\n    async function async1 () {\n      console.log('async1 start')\n      await async2()\n      console.log('async1 end')\n    }\n\n    async function async2 () {\n      console.log(\"async2\")\n    }\n\n    console.log('script start')\n\n    setTimeout(function () {\n      console.log('setTimeout')\n    }, 0)\n\n    async1()\n\n    new Promise (function (resolve) {\n      console.log('promise1')\n      resolve()\n    }).then(function () {\n      console.log('promise2')\n    })\n\n    console.log('script end')\n\n    /*\n      代码执行顺序：\n      script start\n      async1 start\n      async2\n      promise1\n      script end\n      async1 end\n      promise2\n      setTimeout\n    */\n\n  </script>\n```\n## 异常处理\n### throw关键字\n![[Pasted image 20240820191231.png]]\n### Error类型\n![[Pasted image 20240820191257.png]]\n![[Pasted image 20240820191347.png]]\n### 异常的捕获\n![[Pasted image 20240820191801.png]]\n# Storage和正则表达式\n## 认识Storage\n![[Pasted image 20240821160128.png]]\n### Storage的基本使用\n```js\n<script>\n\n    // token操作\n    let token = localStorage.getItem(\"token\")\n    if(!token) {\n      console.log(\"从服务器获取token\")\n      token = \"aaaaaaaaa\"\n      localStorage.setItem(\"token\", token)\n    }\n\n    // 用户名和密码操作\n    let username = localStorage.getItem(\"username\")\n    let password = localStorage.getItem(\"password\")\n    if(!username || !password) {\n      console.log(\"从服务器获取用户名和密码\")\n      username = \"admin\"\n      password = \"123456\"\n      localStorage.setItem(\"username\", username)\n      localStorage.setItem(\"password\", password)\n    }\n\n    console.log(token)\n\n  </script>\n```\n### localStorage和sessionStorage的区别\n![[Pasted image 20240821160903.png]]\n### Storage工具封装\n```js\nclass Cache {\n  constructor(isLoacl = true) {\n    this.storage = isLocal ? localStorage : sessionStorage\n  }\n\n  setCache(key, value) {\n    if(!value) {\n      throw new Error(\"value error: value 必须有值\")\n    }\n\n    if(value) {\n      this.storage.setItem(key, JSON.stringify(value))\n    }\n  }\n\n  getCache(key) {\n    const res = this.storage.getItem(key)\n    if (res) {\n      return JSON.parse(res)\n    }\n  }\n\n  removeCache(key) {\n    this.storage.removeItem(key)\n  }\n\n  clear() {\n    this.storage.clear()\n  }\n}\n\nconst localCache = new Cache(true)\nconst sessionCache = new Cache(false)\n```\n## 正则表达式\n- 使用单个字符串来描述、匹配一系列句法规则的字符串，是一种字符串匹配利器，可以帮助我们搜索、获取、替代字符串\n- 正则表达式主要由两部分组成：模式和修饰符![[Pasted image 20240821170906.png]]\n### 正则表达式的使用方法\n- JavaScript的正则表达式被用于RegExp的exec和test方法，String的match、matchAll、replace、search、split方法![[Pasted image 20240821172016.png]]![[Pasted image 20240821173022.png]]\n ![[Pasted image 20240821173046.png]]\n### 修饰符flag的使用\n![[Pasted image 20240821173451.png]]\n\n### 正则表达式规则\n#### 字符类\n![[Pasted image 20240821174044.png]]\n#### 锚点\n![[Pasted image 20240821182149.png]]\n#### 转义\n![[Pasted image 20240821193427.png]]\n#### 集合\n![[Pasted image 20240821193816.png]]\n#### 量词\n![[Pasted image 20240821195144.png]]\n![[Pasted image 20240821195046.png]]\n#### 贪婪和惰性\n![[Pasted image 20240821200334.png]]\n![[Pasted image 20240821200355.png]]\n#### 捕获组\n![[Pasted image 20240821201218.png]]\n![[Pasted image 20240821201443.png]]\n![[Pasted image 20240821201509.png]]\n#### 正则练习-歌词解析\n![[Pasted image 20240822152859.png]]\n```js\nfunction parseLyric(lyricstring) {\n  // 根据\\n切割字符串\n  const lyricLineStrings = lyricstring.split(\"\\n\")\n  // console.log(lyricLineStrings)\n\n  // 根据每一行歌词进行解析\n  const timeRe = /\\[(\\d{2}):(\\d{2})\\.(\\d{2,3})\\]/i\n  const lyricInfos = []\n  for (const lineString of lyricLineStrings) {\n    // 获取时间\n    const result = lineString.match(timeRe)\n    if(!result) continue\n    const minuteTime = result[1] * 60 * 1000\n    const secondTime = result[2] * 1000\n    const millisecondTime = result[3].length === 3? result[3] : result[3] * 10\n    const time = minuteTime + secondTime + millisecondTime\n\n    // 获取歌词\n    const content = lineString.replace(timeRe, \"\").trim()\n\n    // 保存歌词信息\n    lyricInfos.push({\n      time,\n      content \n    })\n  }\n\n    return lyricInfos\n}\n```\n#### 正则练习-时间格式化\n![[Pasted image 20240822161914.png]]\n```js\n<h2 class=\"time\"></h2>\n\n  <script>\n\n    function formatTime(timestamp, fmtString) {\n      // 将时间戳转化为Date\n      const date = new Date(timestamp)\n\n      // 将正则和值匹配\n      const dateO = {\n        \"y+\": date.getFullYear(),\n        \"M+\": date.getMonth() + 1,\n        \"d+\": date.getDate(),\n        \"h+\": date.getHours(),\n        \"m+\": date.getMinutes(),\n        \"s+\": date.getSeconds(),\n      }\n\n      for (const key in dateO) {\n        const keyRe = new RegExp(key) // 构造正则表达式\n        // 如果正则表达式匹配到fmtString中，则替换\n        if(keyRe.test(fmtString)) {\n          const value = (dateO[key] + \"\").padStart(2, \"0\") // 补零\n          fmtString = fmtString.replace(keyRe, value) // 替换\n        }\n      }\n\n      return fmtString\n    }\n\n    const timeEl = document.querySelector('.time')\n    const productJSON = {\n      name : \"iphone\",\n      newPrice : 10000,\n      oldPrice : 8000,\n      endTime : 1659252290626 \n    }\n    timeEl.textContent = formatTime(productJSON.endTime, \"yyyy/MM/dd hh:mm:ss\")\n\n  </script>\n```\n# 防抖、节流、深拷贝、事件总线\n## 防抖函数\n### 认识防抖debounce函数\n![[Pasted image 20240822171403.png]]\n### 手动实现防抖函数\n- 基本实现\n```js\n<script>\n    function yy_debounce(fn, delay) {\n      let timer = null\n\n      const _debounce = () => {\n        if(timer) clearTimeout(timer)\n        timer = setTimeout(() => {\n          fn()\n          timer = null\n        }, delay)\n      }\n      return _debounce\n    }\n  </script>\n  <script>\n\n    const inputEl = document.querySelector(\"input\")\n\n    let cnt = 1\n    inputEl.oninput = yy_debounce(function() {\n      console.log(`第${cnt++}次输入`)\n    }, 1000)\n\n  </script>\n```\n- 绑定this\n```js\n<script>\n    function yy_debounce(fn, delay) {\n      let timer = null\n\n      const _debounce = function(...args) {\n        if(timer) clearTimeout(timer)\n        timer = setTimeout(() => {\n          fn.apply(this, args) //这里的this绑定到inputEl\n          timer = null\n        }, delay)\n      }\n      return _debounce\n    }\n  </script>\n  <script>\n\n    const inputEl = document.querySelector(\"input\")\n\n    let cnt = 1\n    inputEl.oninput = yy_debounce(function() {\n      console.log(`第${cnt++}次输入`)\n    }, 1000)\n\n  </script>\n```\n- 实现取消功能\n```js\n<script>\n    function yy_debounce(fn, delay) {\n      // 用于记录上一次事件触发的timer\n      let timer = null\n\n      // 触发事件时执行的函数\n      const _debounce = function(...args) {\n        // 如果有再次触发事件，那么取消上一次的事件\n        if(timer) clearTimeout(timer)\n\n        // 延迟去执行对应 fn函数\n        timer = setTimeout(() => {\n          fn.apply(this, args) //这里的this绑定到inputEl\n          timer = null\n        }, delay)\n      }\n\n      // 给_debounce添加一个cancel方法，用于取消防抖\n      _debounce.cancel = function() {\n        if(timer) clearTimeout(timer)\n      }\n\n      return _debounce\n    }\n  </script>\n  <script>\n\n    const inputEl = document.querySelector(\"input\")\n\n    let cnt = 1\n    inputEl.oninput = yy_debounce(function(event) {\n      console.log(`第${cnt++}次输入`)\n    }, 1000)\n\n  </script>\n```\n- 立即执行功能\n```js\n<script>\n    function yy_debounce(fn, delay, immediate = true) {\n      // 用于记录上一次事件触发的timer\n      let timer = null\n      let isInvoke = false // 是否立即执行\n\n      // 触发事件时执行的函数\n      const _debounce = function(...args) {\n        // 如果有再次触发事件，那么取消上一次的事件\n        if(timer) clearTimeout(timer)\n\n        // 如果是立即执行，那么立即执行对应 fn函数\n        if(immediate && !isInvoke) {\n          fn.apply(this, args)\n          isInvoke = true\n          return\n        }\n\n        // 延迟去执行对应 fn函数\n        timer = setTimeout(() => {\n          fn.apply(this, args) //这里的this绑定到inputEl\n          // 重置timer和isInvoke\n          timer = null\n          isInvoke = false\n        }, delay)\n      }\n\n      // 给_debounce添加一个cancel方法，用于取消防抖\n      _debounce.cancel = function() {\n        if(timer) clearTimeout(timer)\n        // 重置timer和isInvoke\n        timer = null\n        isInvoke = false\n      }\n\n      return _debounce\n    }\n  </script>\n  <script>\n\n    const inputEl = document.querySelector(\"input\")\n\n    let cnt = 1\n    inputEl.oninput = yy_debounce(function(event) {\n      console.log(`第${cnt++}次输入:`, this, event)\n    }, 1000)\n\n  </script>\n```\n- 获取返回值\n```js\n<script>\n    function yy_debounce(fn, delay, immediate = true, resultCallback) {\n      // 用于记录上一次事件触发的timer\n      let timer = null\n      let isInvoke = false // 是否立即执行\n\n      // 触发事件时执行的函数\n      const _debounce = function(...args) {\n        return new Promise((resolve, reject) => {\n          try {\n                // 如果有再次触发事件，那么取消上一次的事件\n                if(timer) clearTimeout(timer)\n\n                let res = undefined\n                // 如果是立即执行，那么立即执行对应 fn函数\n                if(immediate && !isInvoke) {\n                  res = fn.apply(this, args)\n                  if (resultCallback) resultCallback(res)\n                  resolve(res)\n                  isInvoke = true\n                  return\n                }\n\n                // 延迟去执行对应 fn函数\n                timer = setTimeout(() => {\n                  res = fn.apply(this, args) //这里的this绑定到inputEl\n                  if (resultCallback) resultCallback(res)\n                  resolve(res)\n                  // 重置timer和isInvoke\n                  timer = null\n                  isInvoke = false\n                }, delay);\n              } catch (error) {\n                reject(error)\n              }\n            })\n          }\n          // 给_debounce添加一个cancel方法，用于取消防抖\n        _debounce.cancel = function() {\n            if(timer) clearTimeout(timer)\n            // 重置timer和isInvoke\n            timer = null\n             isInvoke = false\n        }\n      return _debounce\n    }\n  </script>\n  <script>\n\n    const inputEl = document.querySelector(\"input\")\n\n    const myDebounce = yy_debounce(function(name, age, height) {\n      console.log(`name: ${name}, age: ${age}, height: ${height}`)\n      return \"jojo\"\n    }, 1000, false)\n\n    myDebounce(\"jojo\", 20, 1.80).then(res => {\n      console.log(res)\n    })\n\n  </script>\n```\n可以用underscore库\n## 节流函数\n### 认识节流throttle函数\n![[Pasted image 20240825101157.png]]\n### 手动实现节流函数\n- 实现思路\n![[Pasted image 20240825103812.png]]\n- 基本实现\n```js\n<script>\n\n    function yy_throttle(fn, interval) {\n      let startTime = 0\n\n      const _throttle = function() {\n        const noeTime = new Date().getTime()\n        const waitTime = interval - (noeTime - startTime)\n        if(waitTime <= 0) {\n          fn()\n          startTime = noeTime\n        }\n      }\n\n      return _throttle\n    }\n\n  </script>\n\n  <script>\n\n    const inputEl = document.querySelector('input')\n    inputEl.oninput = yy_throttle(function() {\n      console.log('input')\n    }, 1000)\n\n  </script>\n```\n- this绑定\n```js\n<script>\n\n    function yy_throttle(fn, interval) {\n      let startTime = 0\n\n      const _throttle = function(...args) {\n        const noeTime = new Date().getTime()\n        const waitTime = interval - (noeTime - startTime)\n        if(waitTime <= 0) {\n          fn.apply(this, args)\n          startTime = noeTime\n        }\n      }\n\n      return _throttle\n    }\n\n  </script>\n\n  <script>\n\n    const inputEl = document.querySelector('input')\n    inputEl.oninput = yy_throttle(function(event) {\n      console.log('input:',this.value, event)\n    }, 1000)\n\n  </script>\n```\n- 控制立即执行\n```js\n<script>\n\n    function yy_throttle(fn, interval, leading = false) {\n      let startTime = 0\n\n      const _throttle = function(...args) {\n        // 获取当前时间\n        const nowTime = new Date().getTime()\n\n        // 对立即执行函数进行控制\n        if(!leading && startTime === 0) {\n          startTime = nowTime\n        }\n\n        const waitTime = interval - (nowTime - startTime)\n        if(waitTime <= 0) {\n          fn.apply(this, args)\n          startTime = nowTime\n        }\n      }\n\n      return _throttle\n    }\n\n  </script>\n\n  <script>\n\n    const inputEl = document.querySelector('input')\n    inputEl.oninput = yy_throttle(function(event) {\n      console.log('input:',this.value, event)\n    }, 1000)\n\n  </script>\n```\n- 尾部执行控制\n```js\n<script>\n\n    function yy_throttle(fn, interval, {leading = false, trailing = true} = {}) {\n      let startTime = 0\n      let timer = null\n\n      const _throttle = function(...args) {\n        // 获取当前时间\n        const nowTime = new Date().getTime()\n\n        // 对立即执行函数进行控制\n        if(!leading && startTime === 0) {\n          startTime = nowTime\n        }\n\n        const waitTime = interval - (nowTime - startTime)\n        if(waitTime <= 0) {\n          if (timer) clearTimeout(timer)\n          fn.apply(this, args)\n          startTime = nowTime\n          timer = null\n          return\n        }\n\n        // 节流函数尾部执行控制\n        if (trailing && !timer) {\n          timer = setTimeout(() => {\n            fn.apply(this, args)\n            startTime = new Date().getTime()\n            timer = null\n          }, waitTime)\n        }\n      }\n\n      return _throttle\n    }\n\n  </script>\n\n  <script>\n\n    const inputEl = document.querySelector('input')\n    inputEl.oninput = yy_throttle(function(event) {\n      console.log('input:',this.value, event)\n    }, 1000, {trailing: true})\n\n  </script>\n```\n- 取消尾部功能\n```js\n<script>\n\n    function yy_throttle(fn, interval, {leading = false, trailing = true} = {}) {\n      let startTime = 0\n      let timer = null\n\n      const _throttle = function(...args) {\n        // 获取当前时间\n        const nowTime = new Date().getTime()\n\n        // 对立即执行函数进行控制\n        if(!leading && startTime === 0) {\n          startTime = nowTime\n        }\n\n        const waitTime = interval - (nowTime - startTime)\n        if(waitTime <= 0) {\n          if (timer) clearTimeout(timer)\n          fn.apply(this, args)\n          startTime = nowTime\n          timer = null\n          return\n        }\n\n        // 节流函数尾部执行控制\n        if (trailing && !timer) {\n          timer = setTimeout(() => {\n            fn.apply(this, args)\n            startTime = new Date().getTime()\n            timer = null\n          }, waitTime)\n        }\n      }\n\n      _throttle.cancel = function() {\n        if(timer) clearTimeout(timer)\n        startTime = 0\n        timer = null\n      }\n\n      return _throttle\n    }\n\n  </script>\n\n  <script>\n\n    const inputEl = document.querySelector('input')\n    const buttonEl = document.querySelector('button')\n    inputEl.oninput = yy_throttle(function(event) {\n      console.log('input:',this.value, event)\n    }, 1000, {trailing: true})\n    \n    buttonEl.onclick = function() {\n      inputEl.oninput.cancel()\n    }\n  </script>\n```\n- 获取返回值\n```js\n<script>\n\n    function yy_throttle(fn, interval, {leading = false, trailing = true} = {}) {\n      let startTime = 0\n      let timer = null\n\n      const _throttle = function(...args) {\n        // 获取当前时间\n        return new Promise((resolve, reject) => {\n          try {\n            const nowTime = new Date().getTime()\n\n            // 对立即执行函数进行控制\n            if(!leading && startTime === 0) {\n              startTime = nowTime\n            }\n\n            const waitTime = interval - (nowTime - startTime)\n            if(waitTime <= 0) {\n              if (timer) clearTimeout(timer)\n              const res = fn.apply(this, args)\n              resolve(res)\n              startTime = nowTime\n              timer = null\n              return\n            }\n\n            // 节流函数尾部执行控制\n            if (trailing && !timer) {\n              timer = setTimeout(() => {\n                const res = fn.apply(this, args)\n                resolve(res)\n                startTime = new Date().getTime()\n                timer = null\n              }, waitTime);\n            }\n          }\n          catch (error) {\n            reject(error)\n          }\n        })\n      }\n\n      _throttle.cancel = function() {\n        if(timer) clearTimeout(timer)\n        startTime = 0\n        timer = null\n      }\n\n      return _throttle\n    }\n\n  </script>\n\n  <script>\n\n    const inputEl = document.querySelector('input')\n    const buttonEl = document.querySelector('button')\n    inputEl.oninput = yy_throttle(function(event) {\n      console.log('input:',this.value, event)\n      return \"jojo\"\n    }, 1000, {trailing: true})\n    \n    buttonEl.onclick = function() {\n      inputEl.oninput.cancel()\n    }\n  </script>\n```\n## 深拷贝\n- 深拷贝函数的基本使用\n```js\n<script>\n\n    function isObject(obj) {\n      const objType = typeof obj\n      return (obj !== null) && (objType === \"object\" || objType === \"function\")\n    }\n\n    // 深拷贝函数\n    function deepCopy(obj) {\n      if(!isObject(obj)) {\n        return obj\n      }\n\n      const newObj = {}\n      for (const key in obj) {\n        newObj[key] = deepCopy(obj[key])\n      }\n      return newObj\n    }\n\n    const info = {\n      name: \"jojo\",\n      age: 20,\n      friend: {\n        name: \"小羊\",\n        age: 19,\n        address: {\n          name: \"四川\",\n          detail: \"成都市\"\n        }\n      }\n    }\n\n    const newObj = deepCopy(info)\n\n    console.log(newObj)\n\n  </script>\n```\n- 区分数组与对象\n```js\n<script>\n\n    function isObject(obj) {\n      const objType = typeof obj\n      return (obj !== null) && (objType === \"object\" || objType === \"function\")\n    }\n\n    // 深拷贝函数\n    function deepCopy(obj) {\n      if(!isObject(obj)) {\n        return obj\n      }\n\n      const newObj = Array.isArray(obj) ? [] : {}\n      for (const key in obj) {\n        newObj[key] = deepCopy(obj[key])\n      }\n      return newObj\n    }\n\n    const info = {\n      name: \"jojo\",\n      age: 20,\n      friend: {\n        name: \"小羊\",\n        age: 19,\n        address: {\n          name: \"四川\",\n          detail: \"成都市\"\n        },\n        cnt: [1, 2, 3]\n      }\n    }\n\n    const newObj = deepCopy(info)\n\n    console.log(newObj)\n\n  </script>\n```\n- 其他类型处理\n```js\n<script>\n\n    function isObject(obj) {\n      const objType = typeof obj\n      return (obj !== null) && (objType === \"object\" || objType === \"function\")\n    }\n\n    // 深拷贝函数\n    function deepCopy(obj) {\n\n      // symbol类型\n      if (typeof obj === \"symbol\") {\n        return Symbol(obj.description)\n      }\n\n      if(!isObject(obj)) {\n        return obj\n      }\n\n      // set类型\n      if(obj instanceof Set) {\n        const newSet = new Set()\n        for(const setItem of obj) {\n          newSet.add(deepCopy(setItem))\n        }\n        return newSet\n      }\n\n      // function类型,不需要深拷贝\n      if(typeof obj === \"function\") {\n        return obj\n      }\n\n      // key为symbol类型\n      const symbolKeys = Object.getOwnPropertySymbols(obj)\n      for(const symbolKey of symbolKeys) {\n        obj[symbolKey] = deepCopy(obj[symbolKey])\n      }\n\n      // 如果是对象类型\n      const newObj = Array.isArray(obj) ? [] : {}\n      map.set(obj, newObj)\n      for (const key in obj) {\n        newObj[key] = deepCopy(obj[key])\n      }\n      return newObj\n    }\n\n\n    const set = new Set([1, 2, 3, 4, 5])\n    const s1 = Symbol(\"s1\")\n    const s2 = Symbol(\"s2\")\n    const info = {\n      name: \"jojo\",\n      age: 20,\n      friend: {\n        name: \"小羊\",\n        age: 19,\n        address: {\n          name: \"四川\",\n          detail: \"成都市\"\n        },\n        cnt: [1, 2, 3]\n      },\n      set: set,\n      running: function() {\n        console.log(\"running\")\n      },\n      symbolKey: Symbol,\n      \n      [s1]: \"s1\",\n      [s2]: \"s2\"\n    }\n\n\n    const newObj = deepCopy(info)\n\n    console.log(newObj)\n\n  </script>\n```\n- 函数的循环引用\n```js\n<script>\n\n    function isObject(obj) {\n      const objType = typeof obj\n      return (obj !== null) && (objType === \"object\" || objType === \"function\")\n    }\n\n    // 深拷贝函数\n    function deepCopy(obj, map = new WeakMap()) {\n\n      // symbol类型\n      if (typeof obj === \"symbol\") {\n        return Symbol(obj.description)\n      }\n\n      if(!isObject(obj)) {\n        return obj\n      }\n\n      // set类型\n      if(obj instanceof Set) {\n        const newSet = new Set()\n        for(const setItem of obj) {\n          newSet.add(deepCopy(setItem))\n        }\n        return newSet\n      }\n\n      // function类型,不需要深拷贝\n      if(typeof obj === \"function\") {\n        return obj\n      }\n\n      // key为symbol类型\n      const symbolKeys = Object.getOwnPropertySymbols(obj)\n      for(const symbolKey of symbolKeys) {\n        obj[symbolKey] = deepCopy(obj[symbolKey], map)\n      }\n\n      // 如果是对象类型\n      if(map.get(obj)) {\n        return map.get(obj)\n      }\n      const newObj = Array.isArray(obj) ? [] : {}\n      map.set(obj, newObj)\n      for (const key in obj) {\n        newObj[key] = deepCopy(obj[key], map)\n      }\n      return newObj\n    }\n\n\n    const set = new Set([1, 2, 3, 4, 5])\n    const s1 = Symbol(\"s1\")\n    const s2 = Symbol(\"s2\")\n    const info = {\n      name: \"jojo\",\n      age: 20,\n      friend: {\n        name: \"小羊\",\n        age: 19,\n        address: {\n          name: \"四川\",\n          detail: \"成都市\"\n        },\n        cnt: [1, 2, 3]\n      },\n      set: set,\n      running: function() {\n        console.log(\"running\")\n      },\n      symbolKey: Symbol,\n      \n      [s1]: \"s1\",\n      [s2]: \"s2\"\n    }\n\n    info.self = info\n\n    const newObj = deepCopy(info)\n\n    console.log(newObj)\n\n  </script>\n```\n## 事件总线\n- 实现\n```js\nclass yy_EventBus {\n  constructor() {\n    // 用于存储所有注册的事件及其对应的回调函数\n    this.eventMap = {}\n  }\n\n  // 注册事件监听器\n  on(eventName, eventFn) {\n    // 获取指定事件名称下的回调函数列表\n    let eventFns = this.eventMap[eventName]\n    // 如果列表不存在,则创建一个新的列表\n    if(!eventFns) {\n      eventFns = []\n      this.eventMap[eventName] = eventFns\n    }\n    // 将新的回调函数添加到列表中\n    eventFns.push(eventFn)\n  }\n\n  // 取消事件监听器\n  off(eventName, eventFn) {\n    // 获取指定事件名称下的回调函数列表\n    let eventFns = this.eventMap[eventName]\n    // 如果列表不存在,则直接返回\n    if (!eventFns) return \n    // 遍历列表,找到与传入的 eventFn 相同的函数,并从列表中移除\n    for(let i = 0; i < eventFns.length; i++) {\n      const fn = eventFns[i]\n      if(fn === eventFn) {\n        eventFns.splice(i, 1)\n        break\n      }\n    }\n    // 如果列表中已经没有回调函数了,则从 eventMap 中移除该事件\n    if(eventFns.length === 0) {\n      delete this.eventMap[eventName]\n    }\n  }\n\n  // 发布事件,触发指定事件名称下的所有回调函数\n  emit(eventName, ...args) {\n    // 获取指定事件名称下的回调函数列表\n    let eventFns = this.eventMap[eventName]\n    // 如果列表不存在,则直接返回\n    if(!eventFns) return \n    // 遍历列表,依次执行回调函数,并传递参数\n    eventFns.forEach(fn => {\n      fn(...args)\n    })\n  }\n}\n\n// 创建一个事件总线实例\nconst eventBus = new yy_EventBus()\n\n// 注册事件监听器\neventBus.on(\"navclick\", (name, age, height) => {\n  console.log(`navclick: ${name}, ${age}, ${height}`)\n})\n\n// 另一个事件监听器\nconst click = () => {\n  console.log(\"click\")\n}\neventBus.on(\"navclick\", click)\n\n// 2 秒后取消 click 监听器\nsetTimeout(() => {\n  eventBus.off(\"navclick\", click)\n}, 2000)\n\n// 点击按钮时触发事件\nconst navBtnEl = document.querySelector(\".nav-btn\")\nnavBtnEl.onclick = function() {\n  console.log(\"navBtnEl clicked\")\n  eventBus.emit(\"navclick\", \"张三\", 25, 170)\n}\n```\n# JavaScript网络编程\n## 前后端分离的优势\n![[Pasted image 20240825203521.png]]\n- 服务器端渲染过程![[Pasted image 20240825203823.png]]\n- 前后端分离渲染过程![[Pasted image 20240825203756.png]]\n## Http协议\n### 什么是Http\n![[Pasted image 20240825204441.png]]![[Pasted image 20240825204459.png]]\n### 网页中资源的获取\n![[Pasted image 20240825204658.png]]\n### Http的组成\n![[Pasted image 20240825211123.png]]\n### Http的版本\n![[Pasted image 20240825211713.png]]\n### Http的请求方式\n![[Pasted image 20240825212611.png]]\n#### Header\n![[Pasted image 20240826111103.png]]\n![[Pasted image 20240826110852.png]]\n#### Response响应状态码\n![[Pasted image 20240826120304.png]]\n-  MDN响应码地址：[HTTP 响应状态码 - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)\n![[Pasted image 20240826120226.png]]\n## XHR发送请求\n### XHR发送请求的基本过程\n#### AJAX发送请求\n![[Pasted image 20240826150750.png]]\n```js\n<script>\n\n    // 1.创建XMLHttpRequest对象\n    const xhr = new XMLHttpRequest()\n\n    // 2.监听状态的改变\n    xhr.onreadystatechange = function() {\n      // 将字符串转化为json对象\n      if (xhr.readyState !== XMLHttpRequest.DONE) return \n      const resJSON = JSON.parse(xhr.response)\n      const banner = resJSON.data.banner\n      console.log(banner)\n    }\n\n    // 3.配置请求open\n    xhr.open(\"get\", \"http://123.207.32.32:8000/home/multidata\") // 请求方式和请求地址\n\n    // 4.发送请求send\n    xhr.send()\n\n  </script>\n```\n#### XMLHttpRequest的state\n![[Pasted image 20240826153519.png]]\n![[Pasted image 20240826153458.png]]\n#### 其他事件监听\n![[Pasted image 20240826154018.png]]\n#### 响应数据和类型\n![[Pasted image 20240826160123.png]]\n#### HTTP响应的状态status\n![[Pasted image 20240826160737.png]]\n### GET/POST请求传递参数\n![[Pasted image 20240826212439.png]]![[Pasted image 20240826212419.png]]\n### ajax网络请求封装\n- 可以使用axios库\n- ajax封装\n```js\nfunction ajax({\n  url,\n  method = \"get\",\n  data = {},\n  success,\n  failure\n} = {}) {\n  // 1.创建XMLHttpRequest对象\n  const xhr = new XMLHttpRequest()\n\n  // 2.监听数据\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      success && success(xhr.response)\n    } else {\n      failure && failure({ status: xhr.status, message: xhr.statusText})\n    }\n  }\n\n  // 3.设置类型\n  xhr.responseType = \"json\"\n\n  // 4.配置请求open\n  if(method.toUpperCase() === \"GET\") {\n    const queryStrings = []\n    for (const key in data) {\n      queryStrings.push(`${key}=${data[key]}`)\n    }\n    url = url + \"?\" + queryStrings.join(\"&\")\n    xhr.open(method, url)\n    xhr.send()\n  } else {\n    xhr.open(method, url)\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\")\n    xhr.send(JSON.stringify(data))\n  }\n}\n\n```\n- ajax-promise封装\n```js\nfunction ajax({\n  url,\n  method = \"get\",\n  data = {},\n} = {}) {\n  return new Promise((resolve, reject) => {\n    // 1.创建XMLHttpRequest对象\n    const xhr = new XMLHttpRequest()\n\n    // 2.监听数据\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.response)\n      } else {\n        reject({ status: xhr.status, message: xhr.statusText})\n      }\n    }\n\n    // 3.设置类型\n    xhr.responseType = \"json\"\n\n    // 4.配置请求open\n    if(method.toUpperCase() === \"GET\") {\n      const queryStrings = []\n      for (const key in data) {\n        queryStrings.push(`${key}=${data[key]}`)\n      }\n      url = url + \"?\" + queryStrings.join(\"&\")\n      xhr.open(method, url)\n      xhr.send()\n    } else {\n      xhr.open(method, url)\n      xhr.setRequestHeader(\"Content-Type\", \"application/json\")\n      xhr.send(JSON.stringify(data))\n    }\n  })\n}\n\n```\n### 过期时间和取消请求\n![[Pasted image 20240827115020.png]]\n### Fetch和Fetch API\n#### 认识Fetch和API\n![[Pasted image 20240827133055.png]]![[Pasted image 20240827133115.png]]\n#### Fetch数据的响应\n![[Pasted image 20240827133215.png]]\n![[Pasted image 20240827134223.png]]\n![[Pasted image 20240827134242.png]]\n![[Pasted image 20240827134254.png]]\n![[Pasted image 20240827134308.png]]\n### XMLHttpRequest文件上传\n![[Pasted image 20240827164139.png]]![[Pasted image 20240827164146.png]]![[Pasted image 20240827164213.png]]\n### Fetch文件上传 \n![[Pasted image 20240827164955.png]]","tags":["前端三件套"],"categories":["前端开发"]}]