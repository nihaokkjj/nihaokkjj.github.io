<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1，map简介</strong></p><p>map是STL的一个关联容器，它提供一对一的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>。</p><ul><li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li><li>第二个可能称为该关键字的值(value)；</li><li></li></ul><p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。<br>![[Pasted image 20241118103547.png]]</p><p><strong>2，map的功能</strong></p><p>自动建立key － value的对应。key 和 value可以是任意你需要的类型，包括自定义类型。</p><p><strong>3，使用map</strong></p><p>使用map得包含map类所在的头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;map&gt;  //注意，STL头文件没有扩展名.h<br></code></pre></td></tr></table></figure><p>map对象是模板类，需要关键字和存储对象两个模板参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std:map&lt;int, string&gt; personnel;<br></code></pre></td></tr></table></figure><p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p><p>为了使用方便，可以对模板类进行一下类型定义，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;<br><br>UDT_MAP_INT_CSTRING enumMap;<br></code></pre></td></tr></table></figure><p>4，map的构造函数</p><p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">map&lt;int, string&gt; mapStudent;<br></code></pre></td></tr></table></figure><p>5，插入元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 定义一个map对象<br>map&lt;int, string&gt; mapStudent;<br> <br>// 第一种 用insert函數插入pair<br>mapStudent.insert(pair&lt;int, string&gt;(000, &quot;student_zero&quot;));<br> <br>// 第二种 用insert函数插入value_type数据<br>mapStudent.insert(map&lt;int, string&gt;::value_type(001, &quot;student_one&quot;));<br> <br>// 第三种 用&quot;array&quot;方式插入<br>mapStudent[123] = &quot;student_first&quot;;<br>mapStudent[456] = &quot;student_second&quot;;<br></code></pre></td></tr></table></figure><p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mapStudent.insert(map&lt;int, string&gt;::value_type (001, &quot;student_one&quot;));<br> <br>mapStudent.insert(map&lt;int, string&gt;::value_type (001, &quot;student_two&quot;));<br></code></pre></td></tr></table></figure><p>上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 构造定义，返回一个pair对象<br>pair&lt;iterator,bool&gt; insert (const value_type&amp; val);<br> <br>pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;<br> <br>Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (001, &quot;student_one&quot;));<br> <br>if(!Insert_Pair.second)<br>    cout &lt;&lt; &quot;&quot;Error insert new element&quot; &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p><p>6， 查找元素</p><p>当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置<br>iter = mapStudent.find(&quot;123&quot;);<br> <br>if(iter != mapStudent.end())<br>       cout&lt;&lt;&quot;Find, the value is&quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;<br>else<br>   cout&lt;&lt;&quot;Do not Find&quot;&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>7， 刪除与清空元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//迭代器刪除<br>iter = mapStudent.find(&quot;123&quot;);<br>mapStudent.erase(iter);<br> <br>//用关键字刪除<br>int n = mapStudent.erase(&quot;123&quot;); //如果刪除了會返回1，否則返回0<br> <br>//用迭代器范围刪除 : 把整个map清空<br>mapStudent.erase(mapStudent.begin(), mapStudent.end());<br>//等同于mapStudent.clear()<br></code></pre></td></tr></table></figure><p>8，map的大小</p><p>在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int nSize = mapStudent.size();<br></code></pre></td></tr></table></figure><p> 9，map的基本操作函数：</p><pre><code> C++ maps是一种关联式容器，包含“关键字/值”对 begin()         返回指向map头部的迭代器 clear(）        删除所有元素 count()         返回指定元素出现的次数, (帮助评论区理解： 因为key值不会重复，所以只能是1 or 0) empty()         如果map为空则返回true end()           返回指向map末尾的迭代器 equal_range()   返回特殊条目的迭代器对 erase()         删除一个元素 find()          查找一个元素 get_allocator() 返回map的配置器 insert()        插入元素 key_comp()      返回比较元素key的函数 lower_bound()   返回键值&gt;=给定元素的第一个位置 max_size()      返回可以容纳的最大元素个数 rbegin()        返回一个指向map尾部的逆向迭代器 rend()          返回一个指向map头部的逆向迭代器 size()          返回map中元素的个数 swap()           交换两个map upper_bound()    返回键值&gt;给定元素的第一个位置 value_comp()     返回比较元素value的函数</code></pre><p>————————————————</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
