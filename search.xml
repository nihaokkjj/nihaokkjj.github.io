<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MinVue</title>
    <url>/posts/2025/04/Fronted/MinVue/4a7e677b.html</url>
    <content><![CDATA[Mini Vue前言在尝试读懂这篇文章之前，请保证已经学习过面向对象基本知识、HTML基础、JS基础，并且有过一定的实践开发基础，不然可能会有非常多的小问号。
如果不满足上述条件，也可以试着读一读，不必为其中不懂的内容感到焦虑，后面都能学会的。
本文旨在教会读者实现一个精简版的Vue，很多Vue的功能会被简化，但是核心思想是相通的。
本文会尽可能通俗易懂、避开JS的各种生僻特性。
我们先不说Vue的事情，让我们先通过一些场景了解一点前置知识和概念——只需要知道大概是什么，没必要咬文嚼字：
一个场景里的概念：响应式数据、依赖、数据劫持、MVVM 和双向绑定看看这段代码：
// 我们希望这个关系恒成立： y = 2 * x + 1 let x = 10 let y = 2 * x + 1 x = 20 // x变了，但是y却不会发生变化

我们希望，x变化时y能自动地变化，而不是我们还需要手动赋值多此一举。
那么怎么实现呢？这里有一种思路是，设置一个角色专门监听x的变化，在察觉x变化时能够通知y发生变化。
这很容易做到，JS为我们提供了一个API，Object.defineProperty：
const data = &#123;   x: 10,   y: 21 &#125;; // 监听 data.x 的 修改 Object.defineProperty(data, &#x27;x&#x27;, &#123;   set(value) &#123;     data.y = value * 2 + 1; // 当 x 修改时，通知 y 发生相应变化   &#125; &#125;); console.log(&#x27;一开始:&#x27;, data.y); // 21 data.x = 100; console.log(&#x27;x变化后:&#x27;, data.y); // 201

在Vue中，将普通数据变成响应式数据的过程，就叫数据劫持。
而Object.defineProperty扮演的这个角色，在下文中被称为 数据劫持者（hijacker）。
回到web中，JS的DOM操作是如何去修改视图的呢？
让我们再看看一个DOM操作修改&lt;input /&gt;内容的例子：
let value = document.querySelector(&#x27;input&#x27;).value; // 1.获取input当前内容 value = Number(value) + 1; // 2. 修改内容 document.querySelector(&#x27;input&#x27;).value = value; // 3.重新赋值

我们能不能将第3步干掉？重新赋值看上去太多此一举了！
结合上文x和y的关系，相信大家应该是灵光一闪。
我们这里先抛出问题，暂时不考虑其中具体的实现细节。
响应式数据指的是，依赖变化时，该数据会自动变化。如上文的y就是响应式数据，x则是其依赖，响应式数据和其依赖总是能表达为y=F(x)。
M-V-VM是一种技术架构，M代表数据层(Model)，V代表视图层(View)，VM(ViewModel)在这里则是Vue代表的层次。
VM层会监听另外两层的变化，在其中一个变化时，使另外一个发生相应的变化，即VM层将V层和M层进行了双向绑定——V&#x3D;F1(M)且M&#x3D;F2(V),V与M互为依赖。
具体一点：

用户在输入框输入了123（V层），内存里与之关联的数据自动变为123（M层）
通过代码修改内存的数据为123（M层），界面上与之关联的部分自动变为123（V层）

Vue通过建立MVVM架构实现了双向的响应式，即双向绑定。

又一个场景里的概念：观察者模式、依赖收集&lt;script&gt;  let v = 1;&lt;/script&gt;&lt;div&gt;  &lt;input value=&#123;v&#125; /&gt;  &lt;input value=&#123;v&#125; /&gt;&lt;/div&gt;

上述HTML片段中，两个&lt;input /&gt;内使用了一个JS变量v。
我们实现一下对v变化的监听，察觉到它发生变化的时机，然后及时通知到两个&lt;input /&gt;的value改变：
// 监听v，一旦v变化，就改变两个input的值Object.defineProperty(window, &#x27;v&#x27;, () =&gt; &#123;  set(value) &#123;    const inputDoms = document.querySelectorAll(&#x27;input&#x27;)    inputDoms[0].value = value    inputDoms[1].value = value  &#125;       &#125;)

注意，这里我们能进行通知，是因为这个片段很简单，我们能直接看到v被使用的位置，所以可以写像创建上文x与y的关系那样的代码。
但是，如果我们的项目有无穷多处都依赖了v, 那我们还能一个一个手动去实现每一个响应式数据吗？
所以我们面临一个问题：怎么快速修改所有v？
这里我们需要先学习业界大佬们总结的23种设计模式之一，观察者模式。
什么是观察者模式？
这个模式中一共有2个角色，发布者与观察者。
发布者好比一个UP主，观察者就是ta的粉丝，当UP发视频的时候，粉丝就会第一时间收到通知。
让我们用代码表述一下：
我们的问题解决了——怎么快速修改所有v:
通过发布者通知所有观察者执行update方法修改数据，就实现了修改所有v。
我们可以手动创建一个发布者，但是新的问题是，我们该怎么创建观察者？
让我们分析一下该怎么做，就像是把大象放进冰箱一样，凡事都只需要三步：

观察局势，发现很多地方都使用了变量v，比如&lt;input value=&#123;v&#125;&gt;
特殊标记这些v的位置
让被标记的变量成为观察者

怎么标记呢？那就是创造一种语法，比如&lt;input value=&#123;v&#125;&gt;中的&#123;v&#125;。
然后通过一些~~暴力~~巧妙的操作，遍历所有HTML，找到其中格式满足&#123;xxx&#125;的内容，将其变成观察者即可。
同时，我们会用巧妙的操作实现一种逻辑，在观察者产生的时候，它会主动关注发布者。
具体怎么操作，我们后面再谈。
寻找被特殊标记的变量的过程，就是依赖收集；将标记变量转化为响应式的过程，就是数据劫持；
至此，我们实现了单向的响应式，在publisher的内容被修改时触发publish方法通知所有存在于HTML片段里面的observer一起修改——也就是完成了V=F1(M)。
那双向绑定，M=F2(V)怎么实现呢？
有了上述的铺垫之后就非常简单了！视图层(V层)的变动主要是来自于用户的输入（键盘输入、鼠标点击等），所以我们只需要监听一些用户操作事件就好，比如当用户输入时，让publisher进行通知就行了。
代码示意如下：
&lt;div&gt;  &lt;input value=&#123;v&#125; /&gt; // 用户在这里标签上进行输入  &lt;input value=&#123;v&#125; /&gt;&lt;/div&gt;&lt;script&gt;  // ... 省略一堆代码  const inputDom1 = document.querySelector(&#x27;input&#x27;)  // 监听键盘输入  inputDom1.oninput = (e) =&gt; &#123;    // 一旦用户进行输入，就让UP主（publisher）把新的值告诉其他所有粉丝（观察者）    publisher.publish(e.target.value)  &#125;&lt;/script&gt;


再一个场景里的概念：虚拟DOM和Diff算法让我们先来讲个故事：
某个疯狂星期四，乐程的xxl点外卖。打开某团先点了一份黄金鸡块，五分钟后，觉得不够吃又点了一份吮指原味鸡，再过了五分钟，觉得有点渴于是又点了一杯肥宅快乐水…
这个故事给我们什么启发？
很明显，这样多次操作下来，需要支付多次配送费用，显然不如一次性点完所有来得划算。
在web中也是类似的：
JS引擎和处理HTML的渲染引擎不在同一个进程下，每当用JS去操作HTML（DOM操作），都需要开辟一个跨进程的通道，这种操作开销不小。
看不懂没关系，我们通俗一点说，
相当于，JS和HTML是不在同一个国家的，JS要去处理HTML相关的事情，就得花大价钱买机票出国去做，做完了又得买机票回来继续做自己的事情，如果下次又有HTML的事情要处理，那么就又得买机票出国…
这种开销是昂贵的。
所以，如果JS能先把要处理的DOM统一记录下来，之后一次性处理完，就能节省许多不必要的开销。
而这种记录，就是虚拟DOM。
众所周知，HTML会被解析为DOM树，下图左侧HTML对应就是右侧的DOM树：
DOM这个词严格来说指的是DOM树，其中每个节点就叫DOM节点，而DOM元素专指标签。
但是口头上，DOM、DOM树、DOM节点这几个词经常混用，并不做严格的区分…








我们为了更明确地表示区分，在提到虚拟DOM的语境下，会把DOM称为真实DOM。
虚拟DOM就是用JS代码表示上图右侧结构(主要看a标签那一块的表示就好了)：
const visualDom = &#123;     tag: &#x27;html&#x27;,  // 标签名     props: &#123;&#125;,    // 标签的属性     content: [    // 标签的内容         &#123;             tag: &#x27;head&#x27;,             props: &#123;&#125;,             content: []         &#125;,         &#123;             tag: &#x27;body&#x27;,             props: &#x27;&#x27;,             content: [                 &#123;                     tag: &#x27;a&#x27;,                     props: &#123;                         href: &#x27;xxx&#x27;                     &#125;,                     content: [                         &#x27;a的内容&#x27; // 内容可以直接就是一个字符串,所以后面需要区分,是字符串还是标签                     ]                 &#125;,                 &#x27;123&#x27;             ]         &#125;     ] &#125;

之后，每次JS先在自己家里把要做的改变记录好，后面出国就能一次性把所有事情办完，节省开销。
那么如何构建虚拟DOM呢？让我们一步一步考虑：

起初，遍历所有真实DOM，产生上述结构。
当发送改变时，比如新增&#x2F;删除了一些标签，我们得先在虚拟DOM记录这种改变——这时候问题出现了！

我们怎么知道这种改变发生在虚拟DOM的哪个位置？又重新遍历所有真实DOM节点产生新的结构吗？这听上去开销也太大了，甚至比我们使用虚拟DOM前的情况还要大，那这简直是得不偿失。
所以我们需要一些算法来优化一下，也就是Diff算法。
Diff算法不是具体某个算法，而是像DP一样，是一类算法，解决的问题是如何尽快找出两份内容中不同的部分。

准备开始在了解了上面所有概念之后，我们最后来进行一点总结。
我们要做的是My-Vue，所以简称为MUE吧。
在正式开始之前，希望大家能先去体验一下真正的Vue。
由于Mue的语法模仿的是Vue2, 所以推荐大家选择Vue2进行体验。
因为Vue3语法发生了一些变化，可能会给大家带来一些困扰。
但无论什么版本，底层原理还是基本一致的。
**体验到什么程度？**只需要看看大概长啥样，自己再写一点响应式数据试一下就行了。
让我们梳理一下上面三个场景中提到的内容，整体流程大概是这样的：
其中需要注意的是，我们之前提到的观察者模式中，没有实现反向通知的能力，这点会在下文提及。
让我们准备一下文件结构：
其中index.html和main.js中的内容分别是：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Mue&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div&gt;&#123;msg&#125;&lt;/div&gt;    &lt;input type=&quot;text&quot; value=&quot;&#123;msg&#125;&quot;&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;

如果一切顺利，html中出现的&#123;msg&#125;将被替换成Hello Mue。
import Mue from &#x27;../mue-core/mue.js&#x27;;window.mue = new Mue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    msg: &#x27;Hello MUE!&#x27;  &#125;,&#125;);

和上文一样，接下来涉及到面向对象的部分，我们都用Class进行实现。
JS中，Class本质是Function，这意味着可以用Function实现——并且这是更推荐的做法。
但是考虑到大家的面向对象基础更多来自于Java，用Class实现应该更容易上手。

实现核心能力实现：ViewModel层核心 Mue非常简单，主要是记录一下el和data。
el即对应的真实DOM节点，后续我们将把整个项目挂载到el上。
然后创建数据劫持者Hijacker和模板编译者Compiler即可。
import Hijacker from &#x27;../mue-core/hijacker.js&#x27;;import Compiler from &#x27;./compiler.js&#x27;;class Mue &#123;  constructor(options) &#123;    // element的简写。作为项目挂载的根节点。    this.el = document.querySelector(options.el);    this.data = options.data;    new Hijacker(this, &#x27;data&#x27;);    new Compiler(this); // 把整个mue都传给Compiler  &#125;&#125;export default Mue;

实现：发布者 Publisher比较简单，基本和之前提到的部分一致，不再过多赘述：
// 发布者class Publisher &#123;  constructor(data) &#123;    this.viewers = [];  &#125;  addViewer(viewer) &#123;    this.viewers.push(viewer);  &#125;  publish() &#123;    this.viewers.forEach((viewer) =&gt; &#123;      viewer.update();    &#125;);  &#125;&#125;export default Publisher;

实现：数据劫持者 Hijacker考虑到大家的JS基础，我们这里先简单说明一个JS的知识点，this指向。
本文的目的不是学习this，所以只做不严谨且粗略的介绍。（如果你已经弄懂了this，请跳过这个部分）
上文已经用到过不少了，看到这里相信也也应该知道Class中的this大部分时候的意思就是”我自己”。
我们上文也提到了，Class本质是Function，而且Function内部也有this。
大部分情况下，**一个函数的this指向这个函数的调用者。**来看看下面这个例子：
// case 1：类的方法class A &#123;  testThis() &#123;    console.log(this);  &#125;&#125;new A().testThis(); // **A**// case 2: 全局函数function B() &#123;  console.log(this);&#125;B(); // (浏览器环境下)**window**。 因为这是window.B()的缩写// case 3: 类的方法中使用全局函数class C &#123;  testThis() &#123;    B();  &#125;&#125;new C().testThis(); // (浏览器环境下)**window**, 因为还是 window.B()// case 4: 为了让 类的方法中使用的全局函数 访问到 类的this, 我们需要这么改：function Dfunction(that) &#123;  console.log(that);&#125;class Dclass &#123;  testThis() &#123;    const that = this; // 这里多开一个变量的确是不必要的，这里这么做是为了**强调这种处理方式**    Dfunction(that);  &#125;&#125;new Dclass().testThis(); // Dclass

另外，数据劫持还需要注意一个事情就是，可能出现下面这样树形的数据，所以我们需要进行一个遍历处理，这里我们采用递归实现。
const data = &#123;    a: &#123;        aa:123,        ab: &#123;            aba: &#x27;hhh&#x27;        &#125;    &#125;,    b: &#x27;aaaaaaa&#x27;&#125;

好了，现在让我们来实现Hijacker:
import Publisher from &quot;./publisher.js&quot;;// 数据劫持者class Hijacker &#123;  constructor(mue, data) &#123;    this.hijack(mue, data);  &#125;  // Object.defineProperty劫持数据需要拿到 该数据节点 及 其父级对象  hijack(object, key) &#123;    // **创建发布者**    const publisher = new Publisher();    let value = object[key];    if (!value) &#123;      return;    &#125; else if (typeof value === &#x27;object&#x27;) &#123; // 当前节点是树，递归;      Object.keys(value).forEach((key) =&gt; &#123;        this.hijack(value, key);      &#125;);    &#125; else &#123; // 当前节点是叶子节点；object则是其父级节点      // **上文提到的知识点：JS的this指向**      const that = this;          // **开始劫持数据**      Object.defineProperties(object, value, &#123;        // **记住这个get, 这个很重要**        get() &#123;  // **实现反向通知的核心步骤**，具体怎么回事在**实现Viewer时进一步说明**          if (Publisher.target) &#123;            publisher.addViewer(Publisher.target);          &#125;          return value;        &#125;,        set(newValue) &#123;          if (value === newValue) &#123; // 防止死循环: 更新-&gt;触发publish-&gt;更新-&gt;...            return          &#125;          value = newValue;          that.hijack(object, newValue); // 提防一首新的数据是树形结构，递归一下          publisher.publish();        &#125;      &#125;);    &#125;  &#125;&#125;export default Hijacker;

实现：观察者 Viewer观察者也非常容易实现，只需要在之前提到过的代码上加一点点内容实现反向通知即可：
import Publisher from &quot;./publisher.js&quot;;// 观察者class Viewer &#123;  constructor(mue, dataKey, updateHandler) &#123;    this.mue = mue; // 传说中的vm层，即mue实例    this.dataKey = dataKey; // 数据的键    this.updateHandler = updateHandler; // 用来更新视图层(V层)的方法    // 这里是反向通知的关键操作：    // 绑定一个静态属性。相当于在Publisher内部创建一个“全局”变量，记录是哪个观察者触发的反向通知    Publisher.target = this;    // 这里使用了 mue.data[dataKey]，**将触发劫持者设置的 get方法**：    // **反向通知 publisher邀请当前这个viewer成为观察者（也可以理解为viewer主动成为观察者）**    this.oldValue = mue.data[dataKey];    // 结束，标记为空，释放内存    Publisher.target = null;  &#125;  update() &#123;    const newValue = this.mue.data[dataKey];    if (this.oldValue === newValue) &#123; // 同样地，没有更新就啥也不干      return;    &#125;    // 更新视图，实现 V = F1(M)    this.updateHandler(newValue);  &#125;&#125;export default Viewer;

让我们分析一下其中Publisher.target是一个什么操作：
在创建Viewer的时候，会给Publisher添加一个静态属性target，记录一下当前是在创建哪个观察者。
静态属性可以理解为，在Publisher上创建的一个全局变量。
然后使用这个观察者对应的值时，会触发get方法，让观察者实例publisher将刚刚记录的观察者添加进观察者队列——看上去就像是观察者一创建就主动关注了发布者一样。
这里其实有个有意思的小知识点，就顺口提一句：import的内容是原数据的引用而不是拷贝，所以我们可以在viewer.js引入的Publisher上绑定新的值，然后在hijacker.js中访问到这些值。
实现：模板编译者 Compiler这个是五个角色中最难的一个部分了。
在开始写代码前我们仍然需要介绍一堆前置概念。

首先我们要复习一下JS的DOM类型——请记住DOM也是有类型的，常见的类型如下表所示：




类型
说明
编号
图示参考



元素
每一个标签都是一个元素节点，如 &lt;div&gt; 、 &lt;span&gt;
1



属性
id 、class 、style等
2



文本
元素节点或属性节点中的文本内容
3



注释
注释，比如``
8



文档
也叫根节点，即document
9




然后再让我们了解一下 伪数组。



// 伪数组也叫类数组，本质是对象，只不过键是0-N, 就像是下面这样const objectArray = &#123;    0: &#x27;aaa&#x27;,    1: &#x27;bbb&#x27;,    2: &#x27;ccc&#x27;&#125;console.log(objectArray[0]) // aaa

什么场景下会出现伪数组？
比如document.querySelectorAll的返回值、函数的arguments参数列表等都是伪数组。

如果要把伪数组变为数组，可以使用Array.from方法:



&lt;div id=&quot;app&quot;&gt;  &lt;span&gt;Hello&lt;/span&gt;  World&lt;/div&gt;&lt;script&gt;  const dom = document.querySelector(&#x27;#app&#x27;)  const children = dom.childNodes // **获取当前节点的所有子节点。可以以此进行前序遍历**  console.log(&#x27;伪数组&#x27;, children)  console.log(&#x27;真数组&#x27;, Array.from(children))&lt;/script&gt;

那为什么要把伪数组转为真数组呢？
因为伪数组是对象，不具有数组的某些方法，比如push和pop，许多场景下使用起来不方便。
那JS设计者为什么要搞出伪数组这种东西？
据JS之父自己坦白——“当初只用了十天就搞完了…现在看起来确实设计得太糙了…”

最后，我们需要简单认识一下正则表达式（regular expression）。

实现Compiler只会简单用到一点正则，所以这里只给出3种case给大家了解一下概念，不做过多深入:
const reg = /\&#123;(.+?)\&#125;/; // 正则表达式。这个能够匹配形如 &#123;xxx&#125; 的字符串, ()表示要获取的部分const str = &#x27;这是&#123;msg&#125;&#x27;;// case 1: 用正则表达式去匹配字符串console.log(reg.test(str)); // true// case 2: 用字符串去匹配正则表达式console.log(str.match(reg)); // [ &#x27;&#123;msg&#125;&#x27;, &#x27;msg&#x27;, index: 2, input: &#x27;这是&#123;msg&#125;&#x27;, ...]// case 3: 替换匹配内容const data = &#x27;swpu-lec, yyds&#x27;;console.log(str.replace(reg, data));  // 这是swpu-lec, yyds

由于主题是Vue，而且正则又博大精深，所以限于篇幅此处不做更多介绍了。如果对此感兴趣，可以学习：[该类型的内容暂不支持下载]
熟悉了以上内容后，先来大体看看我们要做的东西。
内容比较多，我们拆成了几个层次分开看，首先我们需要一个大体的框架如下：
import Viewer from &quot;./viewer.js&quot;;// 模板编译者class Compiler &#123;  constructor(mue) &#123;    this.mue = mue;    this.el = mue.el;    this.compile(this.el);  &#125;  // 开始编译  compile(el) &#123;    const childNodes = el.childNodes; // 真实DOM伪数组    const childNodesList = Array.from(childNodes); // 转为真数组，进而可以用数组的api    // 前序遍历整个DOM树    childNodesList.forEach((node,) =&gt; &#123;      // 判断是什么类型的DOM, 扔给不同的处理方法      if (node.nodeType === 1) &#123; // 元素类型        this.compileForElement(node);      &#125; else if (node.nodeType === 3) &#123; // 文本类型        this.compileForText(node);      &#125;      // 如果还有子节点，递归获取下一层      if (node.childNodes.length) &#123;        this.compile(node);      &#125;    &#125;);  &#125;  // TODO: 主要就是实现这俩函数：  // 处理元素类型DOM  compileForElement(node) &#123;&#125;  // 处理文本类型DOM  compileForText(node) &#123;&#125;&#125;export default Compiler;

怎么实现函数呢？既然我们都说过正则匹配了，那么也会用上吧：
// 处理元素类型DOMcompileForElement(node) &#123;  const reg = /\&#123;(.+?)\&#125;/; // 正则表达式，匹配形如 &#123;xxx&#125; 的字符串  const allAttributes = Array.from(node.attributes); // 将节点的所有属性，处理为数组  // 遍历数组，处理每个属性  allAttributes.forEach((attribute) =&gt; &#123;    // 比如 data=&quot;&#123;msg&#125;&quot;, attribute.name就是&quot;data&quot;, attribute.value就是&quot;&#123;msg&#125;&quot;    const text = attribute.value;    const matchRes = text.match(reg);    if (matchRes) &#123; // 如果包含形如 &#123;xxx&#125; 的部分      const dataKey = matchRes[1];    // 比如匹配的是&quot;&#123;msg&#125;&quot;, matchRes[1]就是&quot;msg&quot;      // 创建观察者，触发相关逻辑      new Viewer(this.mue, dataKey, (newValue) =&gt; &#123;        node.textContent = newValue;      &#125;);      const newValue = this.mue.data[dataKey];      node.value = text.replace(reg, newValue); // 将 &#123;xxx&#125; 替换为具体的值      // 监听键盘输入，完成双向绑定，M=F2(V)      node.addEventListener(&#x27;input&#x27;, () =&gt; &#123;        this.mue.data[dataKey] = node.value;      &#125;);    &#125;  &#125;);&#125;// 处理文本类型DOMcompileForText(node) &#123;  const reg = /\&#123;(.+?)\&#125;/;  const text = node.textContent;  const matchRes = text.match(reg);  if (matchRes) &#123;  // 与上面的方法基本上一样的逻辑    const dataKey = matchRes[1];    const newText = this.mue.data[dataKey];    node.textContent = text.replace(reg, newText);    new Viewer(this.mue, dataKey, (newText) =&gt; &#123;      node.textContent = newText;    &#125;);  &#125;&#125;

至此，MUE已经基本完成了。可以打开HTML页面体验一下成果了！
但也再额外给一点开放性挑战，感兴趣可以做一做：
// challenge 1：if、else-if、else，当值为布尔或可以类型转换为布尔时，进行相应的渲染控制&lt;div&gt;  &lt;div if=&quot;&#123;false&#125;&quot;&gt;A&lt;/div&gt;  &lt;div else-if=&quot;&#123;0&#125;&quot;&gt;B&lt;/div&gt;  &lt;div else=&quot;&#123;true&#125;&quot;&gt;C&lt;/div&gt;&lt;/div&gt;// challenge 2：循环渲染, 其中arr是一个数组，element是其元素，index是其下标&lt;div for=&quot;i:arr&quot;&gt;  &lt;span&gt;&#123;i&#125;&lt;/span&gt;&lt;/div&gt;


~~【废弃】实现性能优化~~我们不需要下述的性能优化方案——因为我们有了超越虚拟DOM性能的方案。
~~实现：虚拟DOM~~~~经过一番体验后就发现，如果非常快速地输入中文的话，可能会导致双向绑定出错…~~
~~这是因为，目前我们是每输入一个字符都会触发一次真实DOM的更改，高频且大量的操作就可能超出浏览器处理数据的极限（输入频率超过浏览器最大渲染频率），出现数据和视图不一致的情况…~~
~~总结就是，太卡了，需要优化一下，那么就像是我们上文提到的，实现一下虚拟DOM。~~
~~实现：Diff算法~~如果我们没有虚拟DOM，那么我们或许可以不使用Diff算法？

实现更多场景我突然意识到这不仅是一次尝试，更是一个开发真实可用的框架的好机会！
由于Mue名字寓意太明显了抄袭痕迹太重，所以正式版改名叫Mud吧，寓意非常丰富：

实现思路借鉴了Vue，React(JSX)，Svelte等多个框架，是各种东西糊成的一坨
实现并不精致，但是容易被塑造成各种形状，朴素实用
泥巴里面可以催生出很多东西，以此为基础可以产生更多技术框架
出淤泥而不染

（我的确是在自吹自擂）
1. 在多种模块化规范下使用Mud.js先简单介绍一下JS的模块化规范：



规范名称
说明
示例



umd
几乎是前端诞生以来，就有了雏形，但是一直到2009年左右才终于形成正式的规范
&lt;script src=&quot;xxx&quot; /&gt; &lt;br&gt;像这样引入的就是umd包


cjs
NodeJS的伴生产物，也是2009年左右形成的规范
const a = require(&#39;a&#39;) &lt;br&gt;module.exports = &#123;&#125; &lt;br&gt;像这样的导入、导出的则是cjs包


esm
ECMAScript官方2015年推出的规范，JS正统
import a from &#39;a&#39; &lt;br&gt;export default b &lt;br&gt;像这样导入、导出的则是esm包


cmd和amd
2009年前后出现，现如今使用频率较低，不在本次兼容的范围内。
?（不详）


我们将借助rollup的能力实现一套代码转变为多种规范的包。
在这之前你一定听说过webpack或者vite——不使用这些是因为它们太重了，我们这里只是需要简单地转变规范，所以轻量小巧的rollup就成了首选。
相信配置一套满足上述要求的rollup文件不会困扰大家，所以交由大家自行实现。
在打包完成后，引入不同规范的包：
umd
非常容易实现，但是需要输入完整路径（形如../node_modules/mud/umd/index.js）
cjs
由于node和node_modules的关系不一般，所以只需要require直接导入包名即可(require(&#39;mud&#39;))
esm
这是最难的一个部分，需要有webpack等打包构建工具（这就埋下了一个伏笔——我们需要构建一个脚手架；还有，我个人更倾向用vite）
这里为了更好地验证包发布的效果，这里可以使用工具yalc来模拟验证。
2. 比虚拟DOM更直接的内容更新办法相比虚拟DOM，其实有个更简单且还算高效的办法——innerHTML。
一键替换内容。
这样的实现将会减小代码体积，并且在常规情况下的效率会高于虚拟DOM。
3. 模块化受到腾讯的微前端框架无界的启发，我们想到了一种不一样的模块化方案：
先到根目录下src/index.html中写入（根组件）
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Mud.js&lt;/title&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div&gt;&#123;msg&#125;&lt;/div&gt;    &lt;input type=&quot;text&quot; value=&quot;&#123;msg&#125;&quot;&gt;    &lt;component1 /&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;module&quot; src=&quot;./xxx/Mud.js&quot;&gt;&lt;/script&gt;&lt;script&gt;new Mud(&#123;  el: &#x27;#app&#x27;,  data: &#123;    msg: &#x27;Hello Mud!&#x27;,    arr: [&#x27;Someday&#x27;, &#x27;I&#x27;, &#x27;Will&#x27;, &#x27;Be&#x27;, &#x27;Like&#x27;, &#x27;You&#x27;],    cnt: 1,  &#125;,  components: &#123;    component1: &#x27;src/components/component1/index.html&#x27;  &#125;&#125;);const plus = () =&gt; &#123;  mud.data.cnt ++&#125;&lt;/script&gt;&lt;/html&gt;

然后这里是模块src/components/component1/index.html：
&lt;div&gt;这是组件&lt;/div&gt;&lt;script&gt; new Mud(&#123;  el: &#x27;#component1&#x27;,  data: &#123;&#125;,&#125;);       &lt;/script&gt;

怎么引入模块呢？

从根组件开始解析（模板编译的过程），访问每个DOM节点时，通过字符串比较发现了非原生标签，那么我们就推断这是一个Mud组件。
要求用户手写组件注册（id: path），据此便能够通过组件名称（即id），找到对应的文件路径，用ajax等方式请求下来（异步解析非常高效，也为ssr提供了能力），直接替换原来的组件标签的innerHTML即可。
注意，替换之后，该组件内部可能还有组件，也遵循上述规则进行解析——这样的设计，我们便以一种非常简单的方式实现了单页面应用、组件化设计，它的特点是渲染顺序是先序，更新粒度是一个组件——所以我们不需要Diff，并且…
更好的数据劫持

初步实现将Object.defineProperty换为Proxy，这样我们就能够在不重写方法的前提下监听到数组的push、pop等操作了。这是一个改动量非常大的工作，但是很显然，它的收益是相当可观的。
多级调用还需要支持对象多级调用，思路就是通过点来分割即可。
性能优化对于已经被劫持过的数据，我们要防止其被再次劫持以避免不必要的性能开销。
5. 【TODO】更好的观察者模式现在的观察者都是不具名的，存在很多性能问题：

一处变量a改变时，除了通知其他变量a更新之外，还会通知变量b更新。
比如handleIf中，反复改变状态时，会创建大量重复的观察者。

优化的方案也比较简单，将Publisher的数组改为一个Set，通过键名指定更新某一个变量。
6. 丰富语法现在已经实现了插值语法、for循环等，目前还打算实现以下语法。
if系列
If else-if else，这是vue中非常优秀的一个设计，抄了。
for
组件参数传递
父级组件中：
&lt;component1 a=&#123;xxx&#125; /&gt;&lt;script&gt;new Mud(&#123;    data: &#123;        xxx:1    &#125;&#125;)&lt;/script&gt;

子级组件中：
会把这个组件标签上所有的属性搜刮下来，然后自动放到props.data中（之后，props将作为一个关键字，不允许用户自定义data叫props）：
&lt;div&gt;    &#123;&#123;props.data.xxx&#125;&#125;&lt;/div&gt;&lt;script&gt;new Mud(&#123;    data: &#123;&#125;,&#125;)&lt;/script&gt;

另外还有props.child的操作，这个则是react中非常符合直觉的设计：
父组件中：
&lt;component1 a=&#123;xxx&#125;&gt;    &lt;div&gt;这是嵌入的内容&lt;/div&gt;&lt;/component1&gt;&lt;script&gt;new Mud(&#123;    data: &#123;        xxx:1    &#125;&#125;)&lt;/script&gt;

子组件中：
结合if等语法可以实现非常多骚操作，而且这部分由于是用innerHTML直接插入的，所以还可以使用子组件中的变量。
&lt;div&gt;    &#123;&#123;props.child&#125;&#125;&lt;/div&gt;&lt;script&gt;new Mud(&#123;    data: &#123;&#125;,&#125;)&lt;/script&gt;

Watch监听
即让用户手动监听数据，这个比较简单，将观察者的内部方法暴露出去即可。
7. 实现生命周期对此，我们还得仔细思考一下，到底是实现Hook还是生命周期。
onMounted
直接在挂载的时候加个函数就行了。
8. 更多生态实现Mud-Doc：Mud官方文档
【TODO】实现Root：Mud框架的路由
实现Mud-Cli：快速搭建Mud项目
【TODO】产出Mud-Demo：利用Mud快速构建优秀的作品
组件样式库
~~暂时使用开源的xy-ui:https://github.com/xboxyan~~
可以先考虑 semi-ui
发布上线

测试点1. 内容插值语法
☑ 常规的基础数据插值，如&#123;a&#125;

☑ 特殊的基础数据插值，如NaN，undefined，null，空字符串，symbol，基本数学运算表达式，三元表达式

对于undefined和symbol，插值语法不解析，其余均正常。


☑ 常规的引用数据类型插值，如&#123;b&#125;，其中b=&#123;name: 1&#125;

支持n级连续调用，但是Proxy的setter并没有生效（已修复）。


☑ 特殊的引用数据类型插值，如空对象, 函数表达式，函数运算结果，new新建对象

对于函数表达式，竟然会直接获取到运算结果，出乎意料。


☑ 更多插值方式，如直接插入表达式，插入函数调用，插入连续调用

暂不打算支持插入表达式和函数调用。


☑ 非常极端的插值方式，如不填写任何变量，填写不存在的变量，填写特殊符号，填写标签

很好，填写标签也是能够如预期的一样进行。


☑ 两个对象内有相同的属性名字

☑ 在插值语法的括号两侧写入其他内容，如aaaa&#123;a&#125;aa

会把两侧的其他内容覆盖掉（已修复）。



2. 属性插值语法
☑ 常规的属性插值，如input=&quot;&#123;a&#125;&quot;，其中a=1

☑ 不恰当的插值，如input属性需要number或string等类型的数据，但是插入函数、对象等

☑ 更多插值方式，如插入表达式，插入函数调用，连续调用

同上，暂不打算支持直接插入表达式和函数调用。


☑ 错误的插值，如填写不存在的变量，特殊符号，标签


3. if系列（由于if-else和else暂未上线，所以暂时满足2.属性插值语法的标准即可判定为通过）

☑ 满足2.属性插值语法中的要求

4. for循环
☑ 满足2.属性插值语法中的要求

☑ 插入非数组元素

对于形如() =&gt; [1]的值，会无法解析！


但是之前在data中直接写函数表达式的话，是能够解析返回值的，所以这里后续最好统一一下。


另外，最好再支持一下下标。



5. 组件化
☑ 参数传递满足2.属性插值语法中的要求

☐ 远程组件

只是试试能不能，不作为必要的测试标准。


☑ 传递多个参数

☑ 组件多级嵌套

☑ 一个父组件多个子组件

☑ 传递连续调用的对象

☑ 传递函数

是比较符合预期的，能够实现组件通信。


不过有个问题是，直接在script宏任务中访问window.mud是undefined，大概是还没有加载上。


只能够异步地调用函数。


☑ 传递同一个变量，以及改个名字之后重复传递

☑ 特殊的组件调用，如父子相互引用，兄弟引用，自己调用自己

自己调用自己：只会进行一次，递归会被阻止。


父子相互引用：被浏览器阻止，子组件引用父组件失败。



6. 兼容性
☑ 移动端设备
☑ Chrome&#x2F;Edge(其他浏览器暂时不用管)

]]></content>
      <categories>
        <category>进一步学习vue</category>
      </categories>
      <tags>
        <tag>minvue</tag>
      </tags>
  </entry>
  <entry>
    <title>node</title>
    <url>/posts/2025/06/Fronted/node/857fe845.html</url>
    <content><![CDATA[Node定义Node.js是一个基于 V8 JavaScript 引擎的JavaScript运行时的环境
Node 程序是使用 c++/ c/ js 语言编写的[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;e49f63c48826b59143b4b3366c92cf75_MD5.jpeg|Open: Pasted image 20250522151116.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;e49f63c48826b59143b4b3366c92cf75_MD5.jpeg]]
应用场景一: *目前前端开发的库都是以node包的形式进行管理
二: *npm、yarn、pnpm工具成为前端开发使用最多的工具；
三: 越来越多的公司使用Node.js作为web服务器开发、中间件、代理服务器；
四, 大量项目需要借助Node.js完成前后端渲染的同构应用
五, 资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用JavaScript,而不是Python或者shel)
六, 很多企业在使用Electron来开发桌面应用程序； 
管理node的工具Node 程序传递参数
正常情况下执行一个node程序，直接跟上我们对应的文件即可：node index.js

在某些情况下执行node程序的过程中，我们可能希望给node传递一些参数：node index.js env=development coderwhy

*在程序中获取到传递的参数：

获取参数其实是在process的内置对象中的；
如果我们直接打印这个内置对象，它里面包含特别的信息：  √其他的一些信息，比如版本、操作系统等可以自行查看



Node 的输出[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;31f26b1a8f5f31430c83ade96744ad0b_MD5.jpeg|Open: Pasted image 20250528223104.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;31f26b1a8f5f31430c83ade96744ad0b_MD5.jpeg]]
Node 的 REPLREPL是 Read-Eval-Print Loop 的简称，翻译为“读取-求值-输出”循环；
REPL是一个 简单的, 交互式的编程环境
方法

在终端中直接输入node
在控制台中直接使用

[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;9f0b8de46e04486b4b72bf793ce3f9ce_MD5.jpeg|Open: Pasted image 20250530103657.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;9f0b8de46e04486b4b72bf793ce3f9ce_MD5.jpeg]]
Node 的全局对象常见的全局对象[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;f96f2a2c114478a8e54fb92e91463952_MD5.jpeg|Open: Pasted image 20250530105737.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;f96f2a2c114478a8e54fb92e91463952_MD5.jpeg]]
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;2872b99e65ce425d36b0ff9342c0c39a_MD5.jpeg|Open: Pasted image 20250530121231.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;2872b99e65ce425d36b0ff9342c0c39a_MD5.jpeg]]
global是一个全局对象 ，process、.console、setTimeouts等都有被放到globalr中;

新的标准中还有一个globalThis,也是指向全局对象的；
类似于浏览器中的window;

特殊的全局对象
这些全局对象是实际上是模块中的变量, 只是每个模块都有, 看起来*像是全局变量
在命令行交互中式不可以使用的
包括: __dirname, __filename, export, module, require() 

__dirname : 获取当前文件所在的路径 ( 不包括后面的文件名)__filename : 获取当前文件所在的路径和文件名 ( 包括后面的文件名)
global 和window 的区别
在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等
在Node中，我们也有一个global属性，并且看起来它里面有很多其他对象。
在浏览器中执行的 JavaScript 代码，如果我们在顶级范围内通过var定义的一个属性，默认会被添加到window对象上;
在node中，我们通过var定义一个变量， 它只是在当前模块中有一个变量，不会放到全局中;

模块化目的 : 模块化开发最终的目的是将程序划分成一个个小的结构；
用法 : 

这个结构中编写属于自己的逻辑代码，有自己的作用域，定义变量名词时不会影响到其他的结构；
这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；
也可以通过某种方式，导入另外结构中的变量、函数、对象等；

按照这种结构划分开发程序的过程, 就是模块化开发的过程
CommonJS规范Node中的每一个 js 文件都是一个单独的模块
模块中要导出的内容 : exports模块中要导入内容 : require
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;aa2e22478987faaf12d5d70fd7bec0d4_MD5.jpeg|Open: Pasted image 20250530132649.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;aa2e22478987faaf12d5d70fd7bec0d4_MD5.jpeg]]
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;d68f7830be2871a364727e1ff645d1b6_MD5.jpeg|Open: Pasted image 20250530132724.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;d68f7830be2871a364727e1ff645d1b6_MD5.jpeg]]
util变量等于exports 对象
require的实现本质[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;a07269c198ed7949679906a92589cbb0_MD5.jpeg|Open: Pasted image 20250530145951.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;a07269c198ed7949679906a92589cbb0_MD5.jpeg]]
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;3271cf9d64e405d16db2c3f0bb625090_MD5.jpeg|Open: Pasted image 20250530150003.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;3271cf9d64e405d16db2c3f0bb625090_MD5.jpeg]]

bar变量就是exports对象
module的exports属性本质[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;354b7e2f4ebe5454f0f1c9a492d46036_MD5.jpeg|Open: Pasted image 20250530154627.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;354b7e2f4ebe5454f0f1c9a492d46036_MD5.jpeg]]
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;af508f1943b037e013561029247060db_MD5.jpeg|Open: Pasted image 20250530155343.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;af508f1943b037e013561029247060db_MD5.jpeg]]exports可以导出的原因

**module对象的exports属性是exports对象的一个引用
&#96;module.exports &#x3D; exports &#x3D; main中的bar;

require 查找模块细节require是一个函数, 可以引入一个文件(模块)中导出的对象
书写规则require(X)
require 的查找规则在nodejs中我们通过require(X),可以引入一个模块中导出的对象。
那么，require的查找规则是怎么样的呢？
导入格式require(X)，下面总结几个常见的查找规则：
情况一：X是一个NodeJs核心模块，比如path、http等直接返回核心模块，并且停止查找。
情况二：X是以.&#x2F; 或 ..&#x2F; 或 (根目录) 开头的第一步：将X当做一个文件在对应的目录下查找；

如果有后缀名，直接按照后缀名的格式查找对应的文件

如果没有后缀名，会按照如下的顺序：

直接查找文件X
查找X.js文件
查找X.json文件
查找X.node文件



第二步：没有对应的文件，将X看作一个目录

查找目录下面的index文件

查找X&#x2F;index.js文件
查找X&#x2F;index.json文件
查找X&#x2F;index.node文件



如果还没有找到，那么就报错：not found
情况三：X没有路径，也不是一个核心模块从node_modules目录查找
NodeJs从当前模块的目录开始，并添加&#x2F;node_modules，并尝试从该位置加载模块
例如，如果在”&#x2F;home&#x2F;ry&#x2F;projects&#x2F;foo.js”中调用 require(X),则将以下顺序查找：

&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_mudules
&#x2F;home&#x2F;ry&#x2F;node_modules
&#x2F;home&#x2F;node_modules
&#x2F;node_modules

以上目录找不到，那么就报错：not found
模块的加载过程
模块在被第一次引入时, 模块中的 JS 代码会被运行一次

模块被多次引入时, 回缓存, 最终只加载(运行)一次



每个模块对象module 都有一个属性 : loaded
为false 表示还没有加载, 为true 表示已经加载

循环引入[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;5379489ed74605db6eee3fdf4f43edd2_MD5.jpeg|Open: Pasted image 20250530212957.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;5379489ed74605db6eee3fdf4f43edd2_MD5.jpeg]]采用深度优先算法 main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt; bbb
CommonJS会规范缺点CommonJS加载模块是同步的：

同步 意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行
这个在服务器不会有什么问题，因为服务器加载的s文件都是本地文件，加载速度非常快：

应用于浏览器时: 

浏览器加载 js 文件需要先从服务器将文件下载下来，之后再加载运行；
那么 *采用同步的就意味着后续的S代码都无法正常运行，即使是一些简单的DOM操作；

AMD, CMD[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;3487517d1ebbbc0423bf235834f1a70a_MD5.jpeg|Open: Pasted image 20250530221305.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;3487517d1ebbbc0423bf235834f1a70a_MD5.jpeg]][[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b54379def73193201d802b0313f7f5bd_MD5.jpeg|Open: Pasted image 20250530221657.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b54379def73193201d802b0313f7f5bd_MD5.jpeg]]
ES Module采用 ES Module  将自动采用严格模式 
不允许在逻辑代码中写 import 导入语法 , 只能写在 js 代码顶层
导入和导出方式一const name = &quot;why&quot;const age = 18 export &#123;     name,     age &#125; //不是一个对象, 只是一种特殊的语法 import &#123;age, fname, sayHello&#125; from&quot;./foo.js&quot; //导入

二导出 &#x2F;导出 时给标识符起一个别名
export &#123;    name as fname,    age,    sayHello&#125;import &#123;age as fage, fname, sayHello&#125; from &quot;./foo.js&quot; //导入

三定义时导出
export const name = &quot;why&quot;export const age = 18  export function sayHello() &#123;    console.log(&quot;sayhello&quot;)&#125;

导入时给整个模块起别名import * as foo from &quot;./foo.js&quot;const name = &quot;kk&quot;console.log(name)console.log(foo.name)foo.sayHello()

优化写法规范 : 可以先把要用到的模块放在一个 js 文件里面, 其他js再从这个文件引入
一export &#123; format, formatData &#125; from &quot;./format.js&quot;

二把所有的变量导入进来
export * from &quot;./format.js&quot;

default用法
默认导出 export 时可以不需要指定名字；
在导入时不需要使用 &#123; &#125;，并且可以自己来指定名字；
它也方便我们和现有的 CommonJS  等规范相互操作；

导出[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;57fd5241907251dd268484ec9850f5cb_MD5.jpeg|Open: Pasted image 20250601201850.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;57fd5241907251dd268484ec9850f5cb_MD5.jpeg]]或者[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;937d0952c1f4cdc75bba4c0b510f1982_MD5.jpeg|Open: Pasted image 20250601201925.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;937d0952c1f4cdc75bba4c0b510f1982_MD5.jpeg]]注意 : 一个模块里面只能有一个默认导出( default export)
导入[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;bc35530ac76dd9fe66a85f0ab8da340c_MD5.jpeg|Open: Pasted image 20250601202009.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;bc35530ac76dd9fe66a85f0ab8da340c_MD5.jpeg]]
import函数的使用不允许在逻辑代码中写 import 导入语法 , 只能写在 js 代码顶层
原因 : 

这是因为*ES Module在被S引擎解析*时，就必须知道它的依赖关系
由于这个时候js 代码没有任何的运行，所以无法在进行类似于f判断中根据代码的执行情况
甚至拼接路径的写法也是错误的 : 因为我们必须到运行时能确定path的值；错误写法 import from (&quot;./foo&quot; + &quot;.js&quot;)

动态的加载某一个模坎：

使用import()函数来动态加载；√importi函数返回一个Promise,可以通过then获取结果；

[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;5790845b0be6cb9d7ecb7a760fc5631e_MD5.jpeg|Open: Pasted image 20250601205315.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;5790845b0be6cb9d7ecb7a760fc5631e_MD5.jpeg]]
import.metaimport.meta 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。
    console.log(import.meta)[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;cca6e731888b778c6f697e3b1d213964_MD5.jpeg|Open: Pasted image 20250601210256.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;cca6e731888b778c6f697e3b1d213964_MD5.jpeg]]
ES Module的解析流程   执行流程

阶段一：构建(Construction),根据地址查找js文件，并且下载，将其解析成模块记录(Module Record);import * as foo from &quot;./foo.js&quot;

阶段二：实例化(Instantiation),对模块记录进行实例化，并且分配内存空间，解析模块的导入和导出语句，把模块指向对应的内存地址。export &#123; name, age, sayHelo &#125;  &#x2F;&#x2F;此时的变量还没有值

阶段三：运行(Evaluation),运行代码，计算值，并且将值填充到内存地址中； &#x2F;&#x2F;赋上具体值


包管理工具npm官方文档
npm 的重要文件
package.json

 package.json属性详情
这是每个 Node.js 项目必备的配置文件，记录了项目的元数据和依赖信息。它包含：
package-lock.json    该文件记录了项目中每个依赖的具体版本，并锁定依赖树的结构。确保在不同机器上安装依赖时，所有的开发环境和生产环境都能一致地获取相同版本的依赖包
package.json 常见属性[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b92cff03fb298122f810093af113483b_MD5.jpeg|Open: Pasted image 20250602163215.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b92cff03fb298122f810093af113483b_MD5.jpeg]][[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;02d8e40c2946b81a4e25df73f739762a_MD5.jpeg|Open: Pasted image 20250602163342.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;02d8e40c2946b81a4e25df73f739762a_MD5.jpeg]]

dependencies 和 devDependencies：分别列出了项目的生产环境和开发环境依赖
自定义脚本，如构建、测试、启动等命令
配置信息、许可证和作者信息等

mainmain属性指定了程序的主入口文件
意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require(“foo”)来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。
它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。
scriptsscripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。具体的内容有 install start stop 等，详见 https://docs.npmjs.com/misc/scripts
scripts属性用于配置一些脚本命令，以键值对的形式存在配置后我们可以通过npm run命令的key来执行这个命令：
对于常用的start、test、stop、restart可以省略掉run直接通过npm start等方式运行
dependencies
dependencies属性是指定无论开发环境还是生成环境都需要依赖的包；
通常是我们项目实际开发用到的一些库模块vue、vuex、vue-router、react、.react-dom、axios等等

devDependencies属性一些包在生成环境是不需要的，比如webpack、babel等这个时候我们会通过npm install webpack-save-dev,将它安装到devDependencies属性中
peerDependencies属性
还有一种项目依赖关系是对等依赖，也就是你依赖的一个包，它必须是以另外一个宿主包为前提的：
比如element-plus是依赖于vue3的，ant design是依赖于react、react-dom;

依赖的版本管理semver版本规范是 X.Y.Z :

X主版本号(major): 当你做了不兼容的API修改（可能不兼容之前的版本）
Y次版本号(minor): 当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；
Z修订号(patch) :当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug);

^和~的区别：

x.y.z : 表示一个明确的版本号；
^x.y.z : 表示x是保持不变的，y和z永远安装最新的版本；
~x.y.z : 表示x和y保持不变的，z永远安装最新的版本；

npm 的常见命令
安装依赖 安装项目中列出的所有依赖： npm install

该命令会根据 package.json 安装所有依赖，并生成或更新 node_modules 文件夹。如果你希望全局安装某个工具，可以使用 -g 参数
npm install -g &lt;package-name&gt;


通常使用npm全局安装的包都是一些工具包：yarn、webpack等；
并不是类似于axios、express、koa等库文件；
所以全局安装了之后并不能让我们在所有的项目中使用axios等库；原理图[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;de93ee2b9acc3969b0b70e785cc75ea3_MD5.jpeg|Open: Pasted image 20250602205758.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;de93ee2b9acc3969b0b70e785cc75ea3_MD5.jpeg]][[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;53fd01f2d3cbf94655e82f9dbb5edafe_MD5.jpeg|Open: Pasted image 20250602210240.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;53fd01f2d3cbf94655e82f9dbb5edafe_MD5.jpeg]]


添加依赖用于安装一个新的包，并将其添加到 dependencies 或 devDependencies 中：

npm install &lt;package-name&gt; --save  # 默认会添加到dependenciesnpm install &lt;package-name&gt; --save-dev  # 添加到devDependencies

卸载依赖删除一个依赖包，并更新 package.json 和 node_modules：

npm uninstall &lt;package-name&gt;

更新依赖更新项目中的所有依赖到符合版本范围的最新版本：npm update

5.查看包信息查看已安装包的版本和详细信息：****npm list

执行脚本在 package.json 文件中定义了脚本后，可以使用 npm run &lt;script-name&gt; 命令来执行它。例如：

npm run build

npm发布自己的包[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;e52f14a0ae89ac415e7bb49a89352f71_MD5.jpeg|Open: Pasted image 20250603102555.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;e52f14a0ae89ac415e7bb49a89352f71_MD5.jpeg]]
yarnyarn 是由 Facebook 发起的包管理工具，目的是解决 npm 的一些性能和依赖管理问题。yarn 在安装速度、离线安装和一致性方面做了显著优化。

yarn 提供了更高效的依赖安装方式，采用并行安装并且支持缓存，能显著提升安装速度。
yarn.lock 文件确保所有团队成员安装的依赖版本一致，避免版本冲突。
支持离线安装，在没有网络的情况下仍然能够安装已经缓存的依赖。

下载 npm install yarn
npm 与 Yarn 的比较


特性
npm
Yarn



安装速度
npm 7+ 引入了一些性能优化，但通常速度较慢
更快，支持并行安装和缓存机制


依赖一致性
使用 package-lock.json 来锁定版本
使用 yarn.lock 锁定版本


离线安装
支持缓存，允许在没有网络的情况下安装依赖
支持离线模式，依赖会被缓存


工作空间支持
从 npm 7 开始支持工作空间
原生支持工作空间，适合 monorepo


CLI
功能全面，易用性不断提升
更简洁，但有些命令不兼容 npm


社区支持
全球最大的 JavaScript 包生态
非常活跃，尤其是在 React 社区


[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b079442e73df481b3518d0fd71f00ea8_MD5.jpeg|Open: Pasted image 20250602213810.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b079442e73df481b3518d0fd71f00ea8_MD5.jpeg]]
cnpm查看npm镜像npm config get registry
设置npm镜像
npm config set registry https://registry.npm.taobao.org

将cnpm设置为淘宝的镜像
npm install -g cnpm -registry=https://registry.npm.taobao.orgcnpm config get registry 


npx npx 是 npm5.2.0版本新增的一个工具包，它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包。
npx 是一个由 npm 提供的工具，用于直接运行 node_modules/.bin 中的可执行文件，而不必在全局安装依赖。npx 实际上是 npm 5.2+ 版本中新增的命令行工具，允许开发者运行任何命令而无需显式安装。

npx 可以临时运行安装在项目中的命令（即便这些命令没有全局安装），也可以运行 GitHub 上的命令或者从 npm 注册表中直接运行包。
npx 可以用来快速执行脚本，如运行项目中的构建工具、脚本命令等。

局部命令的执行[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b5ed850b7ea893e19c30211f5ccb4c69_MD5.jpeg|Open: Pasted image 20250603091039.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;b5ed850b7ea893e19c30211f5ccb4c69_MD5.jpeg]]
npm、yarn、pnpm 和 npx 对比总结npm、yarn、pnpm 和 npx 对比总结 



特性
npm
yarn
pnpm
npx



安装方式
使用 npm install 安装依赖
使用 yarn install 安装依赖
使用 pnpm install 安装依赖
临时执行包中的命令，不需要安装全局依赖


安装速度
较慢，依赖树较深时效率较低
快，支持并行安装和缓存
非常快，使用硬链接和共享依赖
运行时自动下载依赖，不需要安装


磁盘空间
使用重复依赖，占用较多磁盘空间
缓存依赖，但依赖安装较多时仍会占用一定磁盘空间
通过硬链接减少重复安装，节省磁盘空间
不占用磁盘空间，仅临时运行命令


锁定依赖版本
使用 package-lock.json 锁定版本
使用 yarn.lock 锁定版本
使用 pnpm-lock.yaml 锁定版本
不锁定版本，运行时临时安装和执行命令


依赖管理
默认安装多份重复依赖（有冗余）
安装时尽量避免冗余依赖
强制封闭依赖，避免隐式依赖
无依赖管理，直接执行命令


兼容性
与大部分工具和社区兼容
与 npm 兼容，但存在部分差异
与 npm 和 yarn 不完全兼容，特别是在依赖管理方式上
依赖于 npm，通过 npx 直接执行命令


离线支持
不完全支持离线安装
支持离线安装，缓存安装过的包
完全支持离线安装，依赖缓存共享
不需要离线安装，运行时自动下载依赖


适用场景
适用于大部分 Node.js 项目
适合需要高性能和一致性保证的项目
适合需要优化磁盘空间和性能的大型项目
快速执行单次命令，无需全局安装依赖


社区和支持
最大的社区支持，生态最广泛
被许多大公司采用，尤其适合 Monorepo 管理
生态较小，但专注于性能和空间优化
npm 的一部分，功能简单实用










主要差异总结：

npm：广泛使用且成熟，适合大部分项目，但安装速度和磁盘空间管理较差。
yarn：性能优于 npm，尤其在并行安装和离线支持方面，适合需要版本一致性的团队协作项目。
pnpm：通过硬链接节省磁盘空间，优化了安装速度，特别适合大型项目或多个项目共享依赖的情况。
npx：用于临时执行命令或包，不需要全局安装，适用于单次执行而不需要管理依赖的场景。

硬链接和软连接硬链接(hard link):

硬链接（英语：hard link) 是*电脑文件系统中的多个文件平等地共享同一个文件存储单元；
删除一个文件名字后，还可以用其它名字继续访问该文件；

符号链接（软链接soft link、Symbolic link):

符号链接（软链接、Symbolic link)是一类*特殊的文件；
其*包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用

[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;54cca17c4865feceebea1a9e017895f1_MD5.jpeg|Open: Pasted image 20250603130622.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;54cca17c4865feceebea1a9e017895f1_MD5.jpeg]]
文件拷贝会在硬盘中复制一份新的文件数据(改变其中一份, 不会影响另一份)copy foo.js foo_copy.js[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;9d19ae1fbdbcd9a762e142c5cf1ce2e2_MD5.jpeg|Open: Pasted image 20250603132426.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;9d19ae1fbdbcd9a762e142c5cf1ce2e2_MD5.jpeg]]
文件的硬链接多个文件平等地共享同一个文件存储单元(改变其中一份, 其他文件的内容也会变)mklink /H foo.js foo_hard.js[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;3b67fc58b7a2c415f3432e30712e6715_MD5.jpeg|Open: Pasted image 20250603132740.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;3b67fc58b7a2c415f3432e30712e6715_MD5.jpeg]]
文件的软链接mklink foo.js foo_hard.js 
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;eab8bb7351e7d0e0516366e9b9b1867e_MD5.jpeg|Open: Pasted image 20250603133709.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;eab8bb7351e7d0e0516366e9b9b1867e_MD5.jpeg]]
pnpm
磁盘空间优化：通过硬链接共享依赖，显著节省了磁盘空间。
高效的依赖管理：依赖安装速度快，尤其是在多个项目共享依赖时表现优秀。
强制封闭依赖：避免隐式依赖，提高了依 赖管理的可靠性。

pnpm的原理使用pnpm, 依赖包将被存放在一个统一的位置，因此：

如果对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件；
如果对同一依赖包需要使用不同的版本，则仅有版本之间不同的文件会被存储起来
所有文件都保存在硬盘上的统一的位置：
当安装软件包时，其包含的所有文件都会硬链接到此位置，而不会占用额外的硬盘空间；
可以在项目之间方便地共享相同版本的依赖包；

非扁平化的 node_modules 目录所有文件都会存储在硬盘上的某一位置. 当软件包被安装时, 包里的文件会硬链接到这一位置, 而不会占用额外的磁盘空间 . 允许跨项目地享用同一版本的依赖
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;216694d140e0e8643ae60a379b195f29_MD5.jpeg|Open: Pasted image 20250603152432.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;216694d140e0e8643ae60a379b195f29_MD5.jpeg]]
pnpm的store存储[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;5992ee0d4fdaca3825d820a342aeb0f5_MD5.jpeg|Open: Pasted image 20250603155958.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;5992ee0d4fdaca3825d820a342aeb0f5_MD5.jpeg]]
webpackwebpack官方文档
webpack 的核心是一个用于现代 JavaScript 应用的静态模块打包器

打包bundler:  webpack可以将帮助我们进行打包，所以它是一个打包工具
静态的static :  这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）；
模块化module:  webpack默认支持各种模块化开发ES Module、CommonJS、AMD等；
现代的modern:  现代前端开发面临各种各样的问题，催生了webpack的出现和发展；

前端开发的流程[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;a42138b7fc8da6b36cab5fc1353e9011_MD5.jpeg|Open: Pasted image 20250604105132.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;a42138b7fc8da6b36cab5fc1353e9011_MD5.jpeg]]
path[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;f588dfec8ef80c8883c609d36dab60ec_MD5.jpeg|Open: Pasted image 20250604131317.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;f588dfec8ef80c8883c609d36dab60ec_MD5.jpeg]][[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;1fe253f3c088785cef56223ff7286e52_MD5.jpeg|Open: Pasted image 20250604131328.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;1fe253f3c088785cef56223ff7286e52_MD5.jpeg]]
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;4d7bbf25139209bf647f3e62c551541d_MD5.jpeg|Open: Pasted image 20250604131334.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;4d7bbf25139209bf647f3e62c551541d_MD5.jpeg]]
const path = require(&quot;path&quot;)const filepath = &quot;C:/abc/cba/nba.txt&quot;console.log(path.extname(filepath)) // &quot;.txt&quot;console.log(path.basename(filepath))  //&quot;nba.txt&quot;console.log(path.dirname(filepath))  //  &quot;C:/abc/cba&quot;const path1 = &quot;/a/d/s&quot;const path2 = &quot;../why/ksj/mae.txt&quot;console.log(path.join(path1, path2))  //&quot;\a\d\why\ksj\mae.txt&quot;console.log(path.resolve(&quot;./acd/s&quot;, &quot;./ehdy/sd&quot;, &quot;../sda.txt&quot;))//   &quot;C:\Users\sai_8\Desktop\1\code\path\acd\s\ehdy\sda.txt&quot;console.log(path.resolve(&quot;as/sd&quot;, &quot;./dsf&quot;, &quot;/df.txt&quot;))//  &quot;C:\df.txt&quot;console.log(path.resolve(&quot;./sd/ads&quot;, &quot;/dsf/sad&quot;, &quot;./as.txt&quot;))//  &quot;C:\dsf\sad\as.txt&quot;

webpack的安装npm install webpack webpack-cli-g #全局安装npm instal1 webpack webpack-cli-D #局部安装
webpack 和 webpack-cli的关系

执行webpack命令，会执行node modules下的 .bin 目录下的webpack;
 webpack 在执行时是依赖webpack-cli的，如果没有安装就会报错：
而 webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程；
所以在安装 webpack时，我们需要同时安装 webpack-cli(第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的 vue-service-cli 的东西)

webpack的默认打包
在目录下直接执行webpack命令
生成一个dist 文件夹, 里面存放一个main.js 的文件, 就是打包之后的文件



-运行webpack 时, webpack 会查找当前目录下的 src/index.js 作为入口如果当前项目中没有存在 src/index.js文件, 就会报错
通过配置指定出入口 
npx webpack --entry ./src/main.js --output-path ./build

配置文件在根目录下创建一个 webpack.config.js  文件，来作为webpack 的配置文件
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;097f3c1fd505f887c84cb2bbdabc1eb6_MD5.jpeg|Open: Pasted image 20250604155437.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;097f3c1fd505f887c84cb2bbdabc1eb6_MD5.jpeg]]
*如果配置文件名不是 webpack.config.js的名字 *

可以通过 --config 来指定对应的配置文件

webpack --config 修改名称后的配置文件


loader的使用
loader 可以用于对模块的源代码进行转换

loader配置方式在webpack.config.js 文件中写明配置信息 
module.rules 允许配置多个 loadermodule.rules的配置 如下：

rules 属性对应的值是一个数组：[Rule]
数组中存放的是一个个的Rule  , Rule 是一个对象，对象中可以设置多个属性：
test属性：用于对resource (资源)进行匹配的，通常会设置成正表达式
use属性 ：对应的值时一个数组：[UseEntry]
UseEntry是一个对像，可以通过对象的属性来设置一些其他属性
loader:必须有一个loader属性，对应的值是一个字符串：







options : 可选的属性，值是一个字符串或者对象，值会被传入到 loader中；
query: 目前已经使用options来替代；


  传递字符串（如：use:[‘style-loader’])是loader属性的简写方式（如：use:[{loader:’style-loader’}]);

loader属性：Rule.use:[{loader}]的简写。

因为loader的执行顺序事从右向左的(从下到上, 从后到前), 所以需要将 style-loader 写道css-loader 的前面
下载
npm install css-loader -Dnpm install style-loader -D
[[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;48318a757d2ecc7795830fb554028204_MD5.jpeg|Open: Pasted image 20250604215809.png]]![[前端了解&#x2F;Node&#x2F;_resources&#x2F;node&#x2F;48318a757d2ecc7795830fb554028204_MD5.jpeg]]
简写
 loader: &quot;css-loader&quot;,
use: [&quot;style-loader&quot;, &quot;css-loader&quot;]


]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习</title>
    <url>/posts/2025/07/Fronted/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/4723d6e9.html</url>
    <content><![CDATA[前端学习学习路线跟着发的视频学就可以了，一定要记笔记 (东西很多会忘)

我是整体跟着这套视频学下来的，但是学完之后的感觉就是内容很杂很多，学的过程中也不知道哪些是重点，所以有必要在这里列一下哪些是着重需要关注的知识。

总之所有视频都要看一遍，按照自己的节奏来，不需要赶进度，重点一定要自己都理解了。
三件套HTML部分
可以适当倍速看，很多标签其实不用学，重点学会 HTML基础结构 + 标签div、h、a、img、iframe、table(后面两个其实已经过时了，但面试会问) + 浏览器原理(面试) + URL(面试)
CSS部分
👇目前常用的，也就是必须掌握的：
文本字体属性
伪元素+伪类
选择器理解+笔记记好就ok、后期的话要会用深度选择器
flex布局、绝对定位、相对定位、浮动、粘性定位(面试)
居中 (要学会所有居中方式)
盒子模型
在CSS基础学完后，跟着做一个完整的页面(我们当时做的是视频里的网易云)，跟着视频做一遍CSS基本上都会用了。（后面仿王者荣耀的我们没做，如果你觉得对CSS力不从心的话可以继续做，基本做一个就🆗了）

这部分笔记一定要记好，以后可能会经常翻出来看
不会的要经常查MDN文档 CSS：层叠样式表 | MDN

如果可以学学Less和Sass，是CSS的扩展，很好用可以简化CSS语法编写
移动端适配（就是rem-vw-vh-@media这些） (这一块我当时没当重点学也没咋学好，听说GitHub上是有写好的适配)（可以自己抉择放后面学也行）
JS部分
去翻看了一下课
这一块视频有*（掌握）*标签的都得认真学
不会的或者哪里很难懂的可以去b站找相应视频看，一般b站的视频都讲的很通俗易懂
JS学习有一定难度，按自己节奏来不能赶
框架
这一块到学完三件套再说，学完记得告知学姐学长一下。

能力要求看文档的能力
前端当前所有的无论技术，框架，语法都有相应的文档，前期在学习三件套期间我们就要接触MDN文档，很多API或是属性词条都应以官方文档为主
在有一定基础后，后续学习大部分时间是和文档&amp;AI打交道
GitHub
前期拥有有一个自己的GitHub账号，可以学一些简单的操作，把自己的笔记，简单的程序demo什么的都可以放到Github上。
自学能力
前端具有一定的广度和深度，不同方向的入门难度、体系成熟度(生态建设)都有很大的差异，当然我们前期三件套是每个前端都得掌握的，而在后的扩展，比如说：新奇的技术栈(太多了根本学不完😭)、优化方案手段、好用的插件、博客建设等等，很多东西是需要自发探索的。
工具资料推荐播放器👇（支持绑定阿里云盘，可以开几十倍速）
蜗牛云盘 - 全面的阿里云盘、115网盘第三方客户端
要是嫌Typora字量大会卡的话可以试试👇
Obsidian - Sharpen your thinking
👆这个可以自定义样式，还有很多第三方插件
各类视频资源青知木杂货铺-程序员资源网
账号：15729962898@163.com
密码：chen6411

使用完后务必退出，同一账号只支持一台设备登录
VSCode插件实用Chinese (Simplified) (简体中文)
Chinese Lorem

汉化

Auto Rename Tag

自动成对HTML标签

Live Server

在HTML文件中，右键Open Live Server可直接打开页面，可以实时更新

Image preview

鼠标悬停img链接可预览显示图片

Path Intellisense

代码自动补全

Prettier - Code formatter

格式化程序，为代码执行一致的样式

Error Lens

报错提示

project-tree

ctre + shift + p 输入 Project Tree 生成项目结构树到README文件（写文章博客可能会用到）

美化VSCode Great Icons

改变你左侧栏的文件图标

background-cover

可以改你编辑器的背景图

Gradient Theme

我当前在用的主题，非常好看

SynthWave ‘84

特别闪的主题样式 (当时豪哥给我配的)

更多的插件自己探索喽😼
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习日记</title>
    <url>/posts/2025/04/Fronted/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c4f4b3de.html</url>
    <content><![CDATA[祖传三件套html我是看的黑马程序员的课, 这个B站上面有很多资源建议时间: 三天
css黑马 + 📶学长发的三件套资料黑马通俗易懂,;coderwhy讲的更深入, 会涉及许多其他的知识, 听完后可以跟着做一个项目, 巩固css知识,;框框css学的比较差, ┭┮﹏┭┮
JavaScriptJavaScript就全看的coderwhy发的资料了, 讲的非常的细致, 从es6之前到后面的新版本es.个人建议可以把coderwhy的js视频全部看一遍, 重点学习他标注重点的视频
中间如果有看不懂的, 不要急. 掘金上面有很多前端大佬分享的笔记, 可以在上面淘淘. 或者直接问ai. 还能直接在官方文档里面找答案学js的时候一定不要急啊, 越急学的越慢, 还学不好
框框学js的时候心态感觉就不好. 现在想来完全没必要啊. 只要每天按部就班的在学, js在暑假之前是能学的差不多的, 心再急也没必要. 希望大家能有一个良好的心态学习, 因为让人崩溃的知识后面还有很多
工具篇看完js, 恭喜你, 马上就要进入框架的学习了后面还有node和工具的学习, 不要急, 你已经离成功不远了
按照我们这届的进度来看, 你们会在期末周的时候学到这(另有卷王我不说)(学的慢一点的贝贝也不用着急, 每个人有自己学习的节奏, 踏踏实实的学号每一步就是最棒的). 
这时候的心态就非常的浮躁啊, 本来要放假了, 心就静不下来. 再加上刚学完三件套, 心中成就感满满, 马上要学的这些短时间内又用不上, 学的时候跟三件套扯不上太多关系. buff叠满了
既然学不好了, 那就干脆别学了吧(不是, 我乱说的)
个人推荐一下学习的重点 (yi):

node (全看完)
Es module (全看完)
npm (重点掌握)
webpack(可以只看一半, 后面做项目遇到了再来学习也不迟)
git(重中之重, git远不止这些运用, 还需要在B站上继续进修)

学完这些, 希望前端仔仔们都能拥有一个光明的未来
学 vue 前搭建小兔鲜项目时发现什么都不懂, 个人推荐可以只跟着打完前三天的, 了解项目的基本构造, 之后就可以开始vue的学习啦!![[前端了解&#x2F;小兔鲜&#x2F;vue项目结构.canvas]]
学 vue学习vue前可以先找一个速通typescript (一二十分钟)来看一看, 后面学vue的时候遇到不会的语法了再去网上找
我当时是看的这个视频【尚硅谷Vue3入门到实战，最新版vue3+TypeScript前端开发教程】https://www.bilibili.com/video/BV1Za4y1r7KE?p=67&amp;vd_source&#x3D;26eb5025743189cb77f15d6e356b6da3暑假的时候学的, 学了十天(内容不多, 但是自己玩玩耍耍, 白天的时候打游戏去了, 只有晚上的时候学了点)
不知道大家学这个的手是什么时候, 按照正常上学时候的速度, 应该能在5-10天学完, 拖太长了也不好
练习vue不知道这个时候你们有自己的博客没有
看着学长学姐们自己写的博客, 我是真心动啊, 于是马上安排
在网上找的教程, 用 hexo 框架搭了一个博客, 中间出了一些小故障, 请问了学长, 最后也是顺利完成喽. 
(可以租一个域名, 在网上看看, 找个便宜点的, 把博客挂在上面)
在就是装饰 + 整理以前的笔记
第二次项目2025-7-10学完vue, 第二次搭小兔鲜啦
搭之前在网上找了一圈, 发现现阶段还是这个更合适一些
这个项目不需要多难, 越简单越好, 毕竟是学完vue的第一个项目, 主要目的是过一遍vue的知识点.等熟悉完vue在学习新的技术也不迟
练习2025-8-30手写pinia, 在B站上找的资源
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端三件套</tag>
      </tags>
  </entry>
  <entry>
    <title>学习网站</title>
    <url>/posts/2025/07/Fronted/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/52e318f2.html</url>
    <content><![CDATA[一些有用的网站值得被记录, 但是总是因为一些原因而搁置, 遗忘搜藏夹里面有一大堆网站, 但我从来不会打开看看
这里放个标, 希望以后还能找到, 而不是吃灰
前端学习学习网站1, 学长推荐的网站Youtubehttps://app.daily.dev/youtube的大火博主

Net Ninja 
Traversy Media
Ryan Carniato
Web Dev Simplified
Fireship

2 博客园里面看到的一个前端路线笔记https://www.cnblogs.com/qianguyihao/p/16370961.html
3 浏览器工作和实践原理https://zhqwq.github.io/broswer-working-principle/guide/intro.html
4 前端交流网站 stack overflowhttps://stackoverflow.com/questions
组件库https://uiverse.io/elements
小工具提高图片分辨率https://upscayl.org/
]]></content>
      <categories>
        <category>进修</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly安装之旅</title>
    <url>/posts/2025/07/blog/butterfly%E5%AE%89%E8%A3%85/e70f18fc.html</url>
    <content><![CDATA[创建一个文件夹
在文件夹打开git
git clone -b main https://github.com/jerryc127/hexo -theme-butterfly .git themes/butterfly

应用主题修改Hexo 根目录下的_config.yml，把主题改为butterfly
theme:  butterfly

安装插件下载安装渲染器：
npm install hexo -renderer-pug hexo -renderer-stylus  --save

重中之重
在hexo 的根目录创建一个文件_config.butterfly.yml，并把主题目录的_config.yml 内容复制_config.butterfly.yml到 去。

注意:

复制的是主题的_config.yml，而不是hexo 的_config.yml
不要把主题目录的_config.yml删掉
以后只需要在_config.butterfly.yml进行配置就行。如果使用了_config.butterfly.yml， 配置主题的_config.yml将不会有效果。
Hexo 会自动合并主题中的_config.yml和_config.butterfly.yml里的配置，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改之旅</title>
    <url>/posts/2025/07/blog/%E9%AD%94%E6%94%B9%E4%B9%8B%E6%97%85/afacad78.html</url>
    <content><![CDATA[文档指路https://butterfly.zhheo.com/create.html我的主题色 : rgb(191, 219, 221)加载动画 (安知鱼)https://blog.anheyu.com/posts/52d8.html导航栏修改(安知鱼)https://blog.anheyu.com/posts/8e53.html试了一下, 每次改完网站就挂了(细节处理太麻烦了), 以后再试试其他主题

上面这些适合想要完全按照自己喜好搭建博客的仔仔啊
但是框框太懒了, 搭一半就放弃了 , 直接去用别人现成的主题去了
找到了一个现成的主题(安知鱼)https://docs.anheyu.com/intro.html
基本clone下来就可以了, 不需要过多的配置, up主已经帮我们配好了
同时推荐一下这个up主发的部署视频(默认你已经有github了啊)07.通过github page部署至互联网
记得将autodeploy.yml中的node版本改成自己电脑上的版本哦, node-version: &quot;22.x&quot;
自动部署, 完成之后只需要把更新的内容上传就可以了, 不用再自己部署了hexo完成github action自动部署
问题中间主包遇到了一个小问题: 没有给每个文章设置自己的访问链接, 这里分享一下
首先安装一个插件
npm install hexo-abbrlink --save

在 _config.yml(不是主题的)添加
# abbrlink configabbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: hex    # 进制：dec(default) and hex  draft: false ## 草稿是否永久链接  field: post ## only support &#x27;post&#x27;  # enable: true # 是否开启，可不写，默认开启
把这个设置好(可以按照自己的喜好设置哦)
permalink: posts/:year/:month/:title/:abbrlink.html

大功告成😘
感悟这些都是框框的血泪史, 中间遇到了无数的bug, 光是blog就重装了四五次了, 希望这篇帖子能帮助到你🤣
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>日记</title>
    <url>/posts/2025/07/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/3458e8f8.html</url>
    <content><![CDATA[路漫漫其修远兮, 路还长, 一切才刚刚开始
总体来讲, 我的大学生活算是幸运的了
冥冥之中, 自有定义初识Lec2024-07说来也巧, 加入学校官方新生群后, 并没有很多卖卡卖被子(就一两个) 的”热心” 学长学姐加我, 所以我眼中的西柚学长学姐们都是十分善良的
也正是因为这一点, 在看到计算机团队在招新宣传的时候, 我才没有把团队归为社团, 部门这类相对没有意义的组织(就像一位学长说的: “能加入lec, 本身就是莫大的缘分. 有人不相信所谓的团队招新, 认为是推销骗子; 有人哪怕加入了招新群, 但在暑假没有准备开学的考试. 我们能顺利加入团队, 本身就是lec最好的选择与安排”)
2024-08感谢当时充满好奇心的我啊, 挑选了一个当时在群里发言比较积极, 看着十分乐于助人的学长(后来知道, cxh学长是lec团队非常优秀的一个人, 不仅技术好, 人也很好相处, 经常在群里发一些有用的资料 (框框经常看这个学长的blog, 争取像他一样, 进大厂!)). 后来么, 就被拉入了lec招新群. 
转折点开始!
就此框框也是知道团队的存在了, 不止lec, 当时我基本把所有的计算机团队都加了一遍(呵呵). 但是除了lec, 其他的群都不大活跃, 也有加进来的第一个群是lec的原因, 我后来主要活跃在lec招新群, (里面有个qq机器人,经常戳他签到啥的, 哈哈哈哈. 后面统计的时候, 框框积分名列前茅, 还有一杯奶茶奖励, 哈哈哈哈哈)
后面认识了jjl学姐, 她真的非常热情啊, 情绪价值给满, 聊天欲望直线上升. 从她口中, 我逐渐了解到什么是团队, 加入团队的心也越来越强烈
再就是和杨队的相遇了, 刚开始还不太敢加她的, 哈哈哈哈. 幸好当时迈出那一步了, 正式成为她门下的第一名弟子, 开启C语言学习之路
整个八月的时间, 除了完, 再就是学C语言. 我当时也不知到我学的咋样, 因为框框在此之前没咋接触过电脑, 对电脑的一些设置都不太了解(最熟悉的就是浏览器搜索东西, 呵呵), 就直接按照团队招新的范围要求, 从0开始学到了字符串(但是当时题刷的太少了, 基础根本没打劳). 感谢杨队的督促, 感谢ggl学姐, 不然当时的我肯定玩嗨了
招新考试2024-09
开学了, jjl学姐亲自把我带到团队里面去了, 以后这里就是我学习的地方啦(哈哈).
2024-10
要考试了, 我好紧张. 把十楼所有的团队考试都报了一遍, 但是考的时候我根本不知道我考的咋样啊, 看不到排名. 但是两个学姐说我考的还可以
考lec了, 考完的时候我感觉我完蛋了, 糟了, 怎么才考五十几分啊 (当时部分团队的分支设置的比较高, 框框考的时候能考到一两百分, 所以这时候根本没概念自己考的咋样).当时跟杨队说我可能进不了了, 杨队让我相信自己, 哈哈哈
进入团队我进团队了, 招新考试排名还不错, 但是lec有点邪门啊, 怎么我这届只有我一个女生进来, 其他女生呢? 跑哪去了(框框内心emmo)
进团队后就是学习之旅啦, 
欲知后事如何, 且看其他笔记
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>没有营养的话</tag>
      </tags>
  </entry>
  <entry>
    <title>使用电脑clash verge给手机共享代理</title>
    <url>/posts/2025/07/%E7%94%9F%E6%B4%BB%E5%B0%8F%E6%8A%80%E5%B7%A7/%E6%89%8B%E6%9C%BA%E4%BB%A3%E7%90%86/6c1cb663.html</url>
    <content><![CDATA[框框灵机一动, 想在手机上面也能访问github, 这里做个记录, 免得之后忘记怎么设置了
前提我现在的手机型号是 oppo Pro12, 安卓, 电脑用的是clash verge, 节点购买的 赔钱机场
网上的资料使用电脑clash verge给手机共享代理【电脑上的准备】
1.首先打开clash verge的设置界面，打开“局域网连接”，若弹出防火墙提示，请选择允许访问
2.使用win+r快捷键，在弹出页面输入“cmd”并点击确定或回车
3.在新弹出的页面中输入”ipconfig&#x2F;all“并回车
4.在显示的列表中找到“ IPv4 地址 . . . . . . . . . . . . :”一栏
【手机上的设置】
1.进入网络设置中的wifi设置，通常在你连接的wifi右侧会有感叹号图标，或者长按可以修改网络具体设置，若没有，请自行在网上查询您所使用的设备如何设置手动代理
2.在网络的具体设置中找到代理设置，通常默认为关闭，请将其设置为手动
3.在服务器一栏内填写上方电脑中获取到的ipv4地址（通常格式为192.168..或10.236..）
4.在端口一栏填写clash verge设置页面“端口设置”后方的数字，默认为“7890”您也可以自行更改
5.填写完之后点击保存即可，若提示已连接网络但无法访问互联网，请不要在意，直接打开浏览器尝试访问外网即可，此时不出意外的话应该已经能够正常连接
实际电脑跟网上找的资料说的一样, 记录下电脑的端口号 和 IPv4的数值
手机进入wife连接界面 -&gt; 点击wife右边那个感叹号 -&gt; 找到高级选项 -&gt; 把代理换成手动设置 -&gt; 将 IP设置改为静态 -&gt; IP地址设置为电脑提供的 IPv4 的数值 -&gt; 端口号也改成电脑的值 -&gt; 隐私那里改成”使用设备MAC地址”
ok, 恭喜你
现在, 你可以自由的在手机上访问github啦!
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>手机设置代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3</title>
    <url>/posts/2025/07/Fronted/Vue/Vue3/3a42db2d.html</url>
    <content><![CDATA[1. Vue3简介
2020年9月18日，Vue.js发布版3.0版本，代号：One Piece（n

经历了：4800+次提交、40+个RFC、600+次PR、300+贡献者

官方发版地址：Release v3.0.0 One Piece · vuejs&#x2F;core

截止2023年10月，最新的公开版本为：3.3.4


1.1. 【性能的提升】
打包大小减少41%。

初次渲染快55%, 更新渲染快133%。

内存减少54%。


1.2.【 源码的升级】
使用Proxy代替defineProperty实现响应式。

重写虚拟DOM的实现和Tree-Shaking。


1.3. 【拥抱TypeScript】
Vue3可以更好的支持TypeScript。

1.4. 【新的特性】
Composition API（组合API）：

setup

ref与reactive

computed与watch
……



新的内置组件：

Fragment

Teleport

Suspense
……



其他改变：

新的生命周期钩子

data 选项应始终被声明为一个函数

移除keyCode支持作为 v-on 的修饰符
……




2. 创建Vue3工程2.1. 【基于 vue-cli 创建】点击查看官方文档

备注：目前vue-cli已处于维护模式，官方推荐基于 Vite 创建项目。

## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/cli npm install -g @vue/cli## 执行创建命令vue create vue_test##  随后选择3.x##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)##  &gt; 3.x##    2.x## 启动cd vue_testnpm run serve


2.2. 【基于 vite 创建】(推荐)vite 是新一代前端构建工具，官网地址：https://vitejs.cn，vite的优势如下：

轻量快速的热重载（HMR），能实现极速的服务启动。
对 TypeScript、JSX、CSS 等支持开箱即用。
真正的按需编译，不再等待整个应用编译完成。
webpack构建 与 vite构建对比图如下：

	

具体操作如下（点击查看官方文档）

## 1.创建命令npm create vue@latest## 2.具体配置## 配置项目名称√ Project name: vue3_test## 是否添加TypeScript支持√ Add TypeScript?  Yes## 是否添加JSX支持√ Add JSX Support?  No## 是否添加路由环境√ Add Vue Router for Single Page Application development?  No## 是否添加pinia环境√ Add Pinia for state management?  No## 是否添加单元测试√ Add Vitest for Unit Testing?  No## 是否添加端到端测试方案√ Add an End-to-End Testing Solution? » No## 是否添加ESLint语法检查√ Add ESLint for code quality?  Yes## 是否添加Prettiert代码格式化√ Add Prettier for code formatting?  No
自己动手编写一个App组件
&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;h1&gt;你好啊！&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;App&#x27; //组件名  &#125;&lt;/script&gt;&lt;style&gt;  .app &#123;    background-color: #ddd;    box-shadow: 0 0 10px;    border-radius: 10px;    padding: 20px;  &#125;&lt;/style&gt;

安装官方推荐的vscode插件：
 

 

总结：

Vite 项目中，index.html 是项目的入口文件，在项目最外层。
加载index.html后，Vite 解析 &lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt; 指向的JavaScript。
Vue3**中是通过 **createApp 函数创建一个应用实例。

2.3. 【一个简单的效果】Vue3向下兼容Vue2语法，且Vue3中的模板中可以没有根标签
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;App&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        age:18,        tel:&#x27;13888888888&#x27;      &#125;    &#125;,    methods:&#123;      changeName()&#123;        this.name = &#x27;zhang-san&#x27;      &#125;,      changeAge()&#123;        this.age += 1      &#125;,      showTel()&#123;        alert(this.tel)      &#125;    &#125;,  &#125;&lt;/script&gt;


3. Vue3核心语法3.1.  【OptionsAPI 与 CompositionAPI】
Vue2的API设计是Options（配置）风格的。
Vue3的API设计是Composition（组合）风格的。

Options API 的弊端Options类型的 API，数据、方法、计算属性等，是分散在：data、methods、computed中的，若想新增或者修改一个需求，就需要分别修改：data、methods、computed，不便于维护和复用。

Composition API 的优势可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。


说明：以上四张动图原创作者：大帅老猿

3.2. 【拉开序幕的 setup】setup 概述setup是Vue3中一个新的配置项，值是一个函数，它是 Composition API “表演的舞台”，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在setup中。
特点如下：

setup函数返回的对象中的内容，可直接在模板中使用。
setup中访问this是undefined。
setup函数会在beforeCreate之前调用，它是“领先”所有钩子执行的。

&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;Person&#x27;,    setup()&#123;      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）      let name = &#x27;张三&#x27;      let age = 18      let tel = &#x27;13888888888&#x27;      // 方法，原来写在methods中      function changeName()&#123;        name = &#x27;zhang-san&#x27; //注意：此时这么修改name页面是不变化的        console.log(name)      &#125;      function changeAge()&#123;        age += 1 //注意：此时这么修改age页面是不变化的        console.log(age)      &#125;      function showTel()&#123;        alert(tel)      &#125;      // 返回一个对象，对象中的内容，模板中可以直接使用      return &#123;name,age,tel,changeName,changeAge,showTel&#125;    &#125;  &#125;&lt;/script&gt;
setup 的返回值
若返回一个对象：则对象中的：属性、方法等，在模板中均可以直接使用**（重点关注）。**
若返回一个函数：则可以自定义渲染内容，代码如下：

setup()&#123;  return ()=&gt; &#x27;你好啊！&#x27;&#125;
setup 与 Options API 的关系
Vue2 的配置（data、methos……）中可以访问到 setup中的属性、方法。
但在setup中不能访问到Vue2的配置（data、methos……）。
如果与Vue2冲突，则setup优先。

setup 语法糖setup函数有一个语法糖，这个语法糖，可以让我们把setup独立出去，代码如下：
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;Person&#x27;,  &#125;&lt;/script&gt;&lt;!-- 下面的写法是setup语法糖 --&gt;&lt;script setup lang=&quot;ts&quot;&gt;  console.log(this) //undefined    // 数据（注意：此时的name、age、tel都不是响应式数据）  let name = &#x27;张三&#x27;  let age = 18  let tel = &#x27;13888888888&#x27;  // 方法  function changName()&#123;    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的  &#125;  function changAge()&#123;    console.log(age)    age += 1 //注意：此时这么修改age页面是不变化的  &#125;  function showTel()&#123;    alert(tel)  &#125;&lt;/script&gt;
扩展：上述代码，还需要编写一个不写setup的script标签，去指定组件名字，比较麻烦，我们可以借助vite中的插件简化

第一步：npm i vite-plugin-vue-setup-extend -D
第二步：vite.config.ts

import &#123; defineConfig &#125; from &#x27;vite&#x27;import VueSetupExtend from &#x27;vite-plugin-vue-setup-extend&#x27;export default defineConfig(&#123;  plugins: [ VueSetupExtend() ]&#125;)


第三步：&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;

3.3. 【ref 创建：基本类型的响应式数据】
**作用：**定义响应式变量。
语法：let xxx = ref(初始值)。
**返回值：**一个RefImpl的实例对象，简称ref对象或ref，ref对象的value属性是响应式的。
注意点：
JS中操作数据需要：xxx.value，但模板中不需要.value，直接使用即可。
对于let name = ref(&#39;张三&#39;)来说，name不是响应式的，name.value是响应式的。



&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;  import &#123;ref&#125; from &#x27;vue&#x27;  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。  let name = ref(&#x27;张三&#x27;)  let age = ref(18)  // tel就是一个普通的字符串，不是响应式的  let tel = &#x27;13888888888&#x27;  function changeName()&#123;    // JS中操作ref对象时候需要.value    name.value = &#x27;李四&#x27;    console.log(name.value)    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。    // name = ref(&#x27;zhang-san&#x27;)  &#125;  function changeAge()&#123;    // JS中操作ref对象时候需要.value    age.value += 1     console.log(age.value)  &#125;  function showTel()&#123;    alert(tel)  &#125;&lt;/script&gt;
3.4. 【reactive 创建：对象类型的响应式数据】
作用：定义一个响应式对象（基本类型不要用它，要用ref，否则报错）
语法：let 响应式对象= reactive(源对象)。
**返回值：**一个Proxy的实例对象，简称：响应式对象。
注意点：reactive定义的响应式数据是“深层次”的。

&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;    &lt;h2&gt;游戏列表：&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;import &#123; reactive &#125; from &#x27;vue&#x27;// 数据let car = reactive(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)let games = reactive([  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;])let obj = reactive(&#123;  a:&#123;    b:&#123;      c:&#123;        d:666      &#125;    &#125;  &#125;&#125;)function changeCarPrice() &#123;  car.price += 10&#125;function changeFirstGame() &#123;  games[0].name = &#x27;流星蝴蝶剑&#x27;&#125;function test()&#123;  obj.a.b.c.d = 999&#125;&lt;/script&gt;
3.5. 【ref 创建：对象类型的响应式数据】
其实ref接收的数据可以是：基本类型、对象类型。
若ref接收的是对象类型，内部其实也是调用了reactive函数。

&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;    &lt;h2&gt;游戏列表：&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;// 数据let car = ref(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)let games = ref([  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;])let obj = ref(&#123;  a:&#123;    b:&#123;      c:&#123;        d:666      &#125;    &#125;  &#125;&#125;)console.log(car)function changeCarPrice() &#123;  car.value.price += 10&#125;function changeFirstGame() &#123;  games.value[0].name = &#x27;流星蝴蝶剑&#x27;&#125;function test()&#123;  obj.value.a.b.c.d = 999&#125;&lt;/script&gt;
3.6. 【ref 对比 reactive】宏观角度看：


ref用来定义：基本类型数据、对象类型数据；

reactive用来定义：对象类型数据。




区别：



ref创建的变量必须使用.value（可以使用volar插件自动添加.value）。
 

reactive重新分配一个新对象，会失去响应式（可以使用Object.assign去整体替换）。




使用原则：

若需要一个基本类型的响应式数据，必须使用ref。
若需要一个响应式对象，层级不深，ref、reactive都可以。
若需要一个响应式对象，且层级较深，推荐使用reactive。




3.7. 【toRefs 与 toRef】
作用：将一个响应式对象中的每一个属性，转换为ref对象。
备注：toRefs与toRef功能一致，但toRefs可以批量转换。
语法如下：

&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;性别：&#123;&#123;person.gender&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changeGender&quot;&gt;修改性别&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,reactive,toRefs,toRef&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;name:&#x27;张三&#x27;, age:18, gender:&#x27;男&#x27;&#125;)	  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力  let &#123;name,gender&#125; =  toRefs(person)	  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力  let age = toRef(person,&#x27;age&#x27;)  // 方法  function changeName()&#123;    name.value += &#x27;~&#x27;  &#125;  function changeAge()&#123;    age.value += 1  &#125;  function changeGender()&#123;    gender.value = &#x27;女&#x27;  &#125;&lt;/script&gt;
3.8. 【computed】作用：根据已有数据计算出新数据（和Vue2中的computed作用一致）。
  

&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;  import &#123;ref,computed&#125; from &#x27;vue&#x27;  let firstName = ref(&#x27;zhang&#x27;)  let lastName = ref(&#x27;san&#x27;)  // 计算属性——只读取，不修改  /* let fullName = computed(()=&gt;&#123;    return firstName.value + &#x27;-&#x27; + lastName.value  &#125;) */  // 计算属性——既读取又修改  let fullName = computed(&#123;    // 读取    get()&#123;      return firstName.value + &#x27;-&#x27; + lastName.value    &#125;,    // 修改    set(val)&#123;      console.log(&#x27;有人修改了fullName&#x27;,val)      firstName.value = val.split(&#x27;-&#x27;)[0]      lastName.value = val.split(&#x27;-&#x27;)[1]    &#125;  &#125;)  function changeFullName()&#123;    fullName.value = &#x27;li-si&#x27;  &#125; &lt;/script&gt;
3.9.【watch】
作用：监视数据的变化（和Vue2中的watch作用一致）
特点：Vue3中的watch只能监视以下四种数据：

ref定义的数据。
reactive定义的数据。
函数返回一个值（getter函数）。
一个包含上述内容的数组。




我们在Vue3中使用watch的时候，通常会遇到以下几种情况：
* 情况一监视ref定义的【基本类型】数据：直接写数据名即可，监视的是其value值的改变。
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况一：监视【ref】定义的【基本类型】数据&lt;/h1&gt;    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,watch&#125; from &#x27;vue&#x27;  // 数据  let sum = ref(0)  // 方法  function changeSum()&#123;    sum.value += 1  &#125;  // 监视，情况一：监视【ref】定义的【基本类型】数据  const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)    if(newValue &gt;= 10)&#123;      stopWatch()    &#125;  &#125;)&lt;/script&gt;
* 情况二监视ref定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。

注意：

若修改的是ref定义的对象中的属性，newValue 和 oldValue 都是新值，因为它们是同一个对象。

若修改整个ref定义的对象，newValue 是新值， oldValue 是旧值，因为不是同一个对象了。



&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况二：监视【ref】定义的【对象类型】数据&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,watch&#125; from &#x27;vue&#x27;  // 数据  let person = ref(&#123;    name:&#x27;张三&#x27;,    age:18  &#125;)  // 方法  function changeName()&#123;    person.value.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.value.age += 1  &#125;  function changePerson()&#123;    person.value = &#123;name:&#x27;李四&#x27;,age:90&#125;  &#125;  /*     监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视    watch的第一个参数是：被监视的数据    watch的第二个参数是：监视的回调    watch的第三个参数是：配置对象（deep、immediate等等.....）   */  watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person变化了&#x27;,newValue,oldValue)  &#125;,&#123;deep:true&#125;)  &lt;/script&gt;
*  情况三监视reactive定义的【对象类型】数据，且默认开启了深度监视。
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况三：监视【reactive】定义的【对象类型】数据&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;    &lt;hr&gt;    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;test&quot;&gt;修改obj.a.b.c&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;reactive,watch&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;    name:&#x27;张三&#x27;,    age:18  &#125;)  let obj = reactive(&#123;    a:&#123;      b:&#123;        c:666      &#125;    &#125;  &#125;)  // 方法  function changeName()&#123;    person.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.age += 1  &#125;  function changePerson()&#123;    Object.assign(person,&#123;name:&#x27;李四&#x27;,age:80&#125;)  &#125;  function test()&#123;    obj.a.b.c = 888  &#125;  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的  watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person变化了&#x27;,newValue,oldValue)  &#125;)  watch(obj,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;Obj变化了&#x27;,newValue,oldValue)  &#125;)&lt;/script&gt;
* 情况四监视ref或reactive定义的【对象类型】数据中的某个属性，注意点如下：

若该属性值不是【对象类型】，需要写成函数形式。
若该属性值是依然是【对象类型】，可直接编，也可写成函数，建议写成函数。

结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;reactive,watch&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;    name:&#x27;张三&#x27;,    age:18,    car:&#123;      c1:&#x27;奔驰&#x27;,      c2:&#x27;宝马&#x27;    &#125;  &#125;)  // 方法  function changeName()&#123;    person.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.age += 1  &#125;  function changeC1()&#123;    person.car.c1 = &#x27;奥迪&#x27;  &#125;  function changeC2()&#123;    person.car.c2 = &#x27;大众&#x27;  &#125;  function changeCar()&#123;    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;  &#125;  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式  /* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)  &#125;) */  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数  watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)  &#125;,&#123;deep:true&#125;)&lt;/script&gt;
* 情况五监视上述的多个数据
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况五：监视上述的多个数据&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;reactive,watch&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;    name:&#x27;张三&#x27;,    age:18,    car:&#123;      c1:&#x27;奔驰&#x27;,      c2:&#x27;宝马&#x27;    &#125;  &#125;)  // 方法  function changeName()&#123;    person.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.age += 1  &#125;  function changeC1()&#123;    person.car.c1 = &#x27;奥迪&#x27;  &#125;  function changeC2()&#123;    person.car.c2 = &#x27;大众&#x27;  &#125;  function changeCar()&#123;    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;  &#125;  // 监视，情况五：监视上述的多个数据  watch([()=&gt;person.name,person.car],(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)  &#125;,&#123;deep:true&#125;)&lt;/script&gt;
3.10. 【watchEffect】
官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。

watch对比watchEffect


都能监听响应式数据的变化，不同的是监听数据变化的方式不同

watch：要明确指出监视的数据

watchEffect：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。




示例代码：
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;需求：水温达到50℃，或水位达到20cm，则联系服务器&lt;/h1&gt;    &lt;h2 id=&quot;demo&quot;&gt;水温：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;水位：&#123;&#123;height&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changePrice&quot;&gt;水温+1&lt;/button&gt;    &lt;button @click=&quot;changeSum&quot;&gt;水位+10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,watch,watchEffect&#125; from &#x27;vue&#x27;  // 数据  let temp = ref(0)  let height = ref(0)  // 方法  function changePrice()&#123;    temp.value += 10  &#125;  function changeSum()&#123;    height.value += 1  &#125;  // 用watch实现，需要明确的指出要监视：temp、height  watch([temp,height],(value)=&gt;&#123;    // 从value中获取最新的temp值、height值    const [newTemp,newHeight] = value    // 室温达到50℃，或水位达到20cm，立刻联系服务器    if(newTemp &gt;= 50 || newHeight &gt;= 20)&#123;      console.log(&#x27;联系服务器&#x27;)    &#125;  &#125;)  // 用watchEffect实现，不用  const stopWtach = watchEffect(()=&gt;&#123;    // 室温达到50℃，或水位达到20cm，立刻联系服务器    if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;      console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)      console.log(&#x27;联系服务器&#x27;)    &#125;    // 水温达到100，或水位达到50，取消监视    if(temp.value === 100 || height.value === 50)&#123;      console.log(&#x27;清理了&#x27;)      stopWtach()    &#125;  &#125;)&lt;/script&gt;

3.11. 【标签的 ref 属性】作用：用于注册模板引用。


用在普通DOM标签上，获取的是DOM节点。

用在组件标签上，获取的是组件实例对象。



用在普通DOM标签上：
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1 ref=&quot;title1&quot;&gt;尚硅谷&lt;/h1&gt;    &lt;h2 ref=&quot;title2&quot;&gt;前端&lt;/h2&gt;    &lt;h3 ref=&quot;title3&quot;&gt;Vue&lt;/h3&gt;    &lt;input type=&quot;text&quot; ref=&quot;inpt&quot;&gt; &lt;br&gt;&lt;br&gt;    &lt;button @click=&quot;showLog&quot;&gt;点我打印内容&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref&#125; from &#x27;vue&#x27;	  let title1 = ref()  let title2 = ref()  let title3 = ref()  function showLog()&#123;    // 通过id获取元素    const t1 = document.getElementById(&#x27;title1&#x27;)    // 打印内容    console.log((t1 as HTMLElement).innerText)    console.log((&lt;HTMLElement&gt;t1).innerText)    console.log(t1?.innerText)    		/************************************/		    // 通过ref获取元素    console.log(title1.value)    console.log(title2.value)    console.log(title3.value)  &#125;&lt;/script&gt;

用在组件标签上：
&lt;!-- 父组件App.vue --&gt;&lt;template&gt;  &lt;Person ref=&quot;ren&quot;/&gt;  &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;  import Person from &#x27;./components/Person.vue&#x27;  import &#123;ref&#125; from &#x27;vue&#x27;  let ren = ref()  function test()&#123;    console.log(ren.value.name)    console.log(ren.value.age)  &#125;&lt;/script&gt;&lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,defineExpose&#125; from &#x27;vue&#x27;	// 数据  let name = ref(&#x27;张三&#x27;)  let age = ref(18)  /****************************/  /****************************/  // 使用defineExpose将组件中的数据交给外部  defineExpose(&#123;name,age&#125;)&lt;/script&gt;



3.12. 【props】
&gt;// 定义一个接口，限制每个Person对象的格式export interface PersonInter &#123; id:string, name:string,    age:number   &#125;   // 定义一个自定义类型Personsexport type Persons = Array&lt;PersonInter&gt;

App.vue中代码：
&gt;&lt;template&gt;	&lt;Person :list=&quot;persons&quot;/&gt;&lt;/template&gt;  &lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;  import Person from &#x27;./components/Person.vue&#x27;  import &#123;reactive&#125; from &#x27;vue&#x27;    import &#123;type Persons&#125; from &#x27;./types&#x27;      let persons = reactive&lt;Persons&gt;([     &#123;id:&#x27;e98219e12&#x27;,name:&#x27;张三&#x27;,age:18&#125;,      &#123;id:&#x27;e98219e13&#x27;,name:&#x27;李四&#x27;,age:19&#125;,       &#123;id:&#x27;e98219e14&#x27;,name:&#x27;王五&#x27;,age:20&#125;     ])   &lt;/script&gt;  

Person.vue中代码：
&gt;&lt;template&gt;&lt;div class=&quot;person&quot;&gt; &lt;ul&gt;     &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;        &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;   &lt;/div&gt;   &lt;/template&gt;  &lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;import &#123;defineProps&#125; from &#x27;vue&#x27;import &#123;type PersonInter&#125; from &#x27;@/types&#x27;    // 第一种写法：仅接收// const props = defineProps([&#x27;list&#x27;])    // 第二种写法：接收+限制类型// defineProps&lt;&#123;list:Persons&#125;&gt;()    // 第三种写法：接收+限制类型+指定默认值+限制必要性let props = withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;     list:()=&gt;[&#123;id:&#x27;asdasg01&#x27;,name:&#x27;小猪佩奇&#x27;,age:18&#125;]  &#125;)   console.log(props)  &lt;/script&gt;

3.13. 【生命周期】
概念：Vue组件实例在创建时要经历一系列的初始化步骤，在此过程中Vue会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子

规律：

生命周期整体分为四个阶段，分别是：创建、挂载、更新、销毁，每个阶段都有两个钩子，一前一后。


Vue2的生命周期

创建阶段：beforeCreate、created
挂载阶段：beforeMount、mounted
更新阶段：beforeUpdate、updated
销毁阶段：beforeDestroy、destroyed


Vue3的生命周期

创建阶段：setup
挂载阶段：onBeforeMount、onMounted
更新阶段：onBeforeUpdate、onUpdated
卸载阶段：onBeforeUnmount、onUnmounted


常用的钩子：onMounted(挂载完毕)、onUpdated(更新完毕)、onBeforeUnmount(卸载之前)

示例代码：
&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!-- vue3写法 --&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;     ref,     onBeforeMount,     onMounted,     onBeforeUpdate,     onUpdated,     onBeforeUnmount,     onUnmounted   &#125; from &#x27;vue&#x27;  // 数据  let sum = ref(0)  // 方法  function changeSum() &#123;    sum.value += 1  &#125;  console.log(&#x27;setup&#x27;)  // 生命周期钩子  onBeforeMount(()=&gt;&#123;    console.log(&#x27;挂载之前&#x27;)  &#125;)  onMounted(()=&gt;&#123;    console.log(&#x27;挂载完毕&#x27;)  &#125;)  onBeforeUpdate(()=&gt;&#123;    console.log(&#x27;更新之前&#x27;)  &#125;)  onUpdated(()=&gt;&#123;    console.log(&#x27;更新完毕&#x27;)  &#125;)  onBeforeUnmount(()=&gt;&#123;    console.log(&#x27;卸载之前&#x27;)  &#125;)  onUnmounted(()=&gt;&#123;    console.log(&#x27;卸载完毕&#x27;)  &#125;)&lt;/script&gt;

3.14. 【自定义hook】
什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装，类似于vue2.x中的mixin。

自定义hook的优势：复用代码, 让setup中的逻辑更清楚易懂。


示例代码：

useSum.ts中内容如下：
import &#123;ref,onMounted&#125; from &#x27;vue&#x27;export default function()&#123;  let sum = ref(0)  const increment = ()=&gt;&#123;    sum.value += 1  &#125;  const decrement = ()=&gt;&#123;    sum.value -= 1  &#125;  onMounted(()=&gt;&#123;    increment()  &#125;)  //向外部暴露数据  return &#123;sum,increment,decrement&#125;&#125;		

useDog.ts中内容如下：
import &#123;reactive,onMounted&#125; from &#x27;vue&#x27;import axios,&#123;AxiosError&#125; from &#x27;axios&#x27;export default function()&#123;  let dogList = reactive&lt;string[]&gt;([])  // 方法  async function getDog()&#123;    try &#123;      // 发请求      let &#123;data&#125; = await axios.get(&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;)      // 维护数据      dogList.push(data.message)    &#125; catch (error) &#123;      // 处理错误      const err = &lt;AxiosError&gt;error      console.log(err.message)    &#125;  &#125;  // 挂载钩子  onMounted(()=&gt;&#123;    getDog()  &#125;)	  //向外部暴露数据  return &#123;dogList,getDog&#125;&#125;

组件中具体使用：
&lt;template&gt;  &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;increment&quot;&gt;点我+1&lt;/button&gt;  &lt;button @click=&quot;decrement&quot;&gt;点我-1&lt;/button&gt;  &lt;hr&gt;  &lt;img v-for=&quot;(u,index) in dogList.urlList&quot; :key=&quot;index&quot; :src=&quot;(u as string)&quot;&gt;   &lt;span v-show=&quot;dogList.isLoading&quot;&gt;加载中......&lt;/span&gt;&lt;br&gt;  &lt;button @click=&quot;getDog&quot;&gt;再来一只狗&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123;defineComponent&#125; from &#x27;vue&#x27;  export default defineComponent(&#123;    name:&#x27;App&#x27;,  &#125;)&lt;/script&gt;&lt;script setup lang=&quot;ts&quot;&gt;  import useSum from &#x27;./hooks/useSum&#x27;  import useDog from &#x27;./hooks/useDog&#x27;	  let &#123;sum,increment,decrement&#125; = useSum()  let &#123;dogList,getDog&#125; = useDog()&lt;/script&gt;


4. 路由4.1. 【对路由的理解】 

4.2. 【基本切换效果】
Vue3中要使用vue-router的最新版本，目前是4版本。

路由配置文件代码如下：
import &#123;createRouter,createWebHistory&#125; from &#x27;vue-router&#x27;import Home from &#x27;@/pages/Home.vue&#x27;import News from &#x27;@/pages/News.vue&#x27;import About from &#x27;@/pages/About.vue&#x27;const router = createRouter(&#123;	history:createWebHistory(),	routes:[		&#123;			path:&#x27;/home&#x27;,			component:Home		&#125;,		&#123;			path:&#x27;/about&#x27;,			component:About		&#125;	]&#125;)export default router


main.ts代码如下：
import router from &#x27;./router/index&#x27;app.use(router)app.mount(&#x27;#app&#x27;)


App.vue代码如下
&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;Vue路由测试&lt;/h2&gt;    &lt;!-- 导航区 --&gt;    &lt;div class=&quot;navigate&quot;&gt;      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt;      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt;    &lt;/div&gt;    &lt;!-- 展示区 --&gt;    &lt;div class=&quot;main-content&quot;&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;  import &#123;RouterLink,RouterView&#125; from &#x27;vue-router&#x27;  &lt;/script&gt;

4.3. 【两个注意点】

路由组件通常存放在pages 或 views文件夹，一般组件通常存放在components文件夹。

通过点击导航，视觉效果上“消失” 了的路由组件，默认是被卸载掉的，需要的时候再去挂载。



4.4.【路由器工作模式】
history模式

优点：URL更加美观，不带有#，更接近传统的网站URL。
缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有404错误。
const router = createRouter(&#123;  	history:createWebHistory(), //history模式  	/******/&#125;)

hash模式

优点：兼容性更好，因为不需要服务器端处理路径。
缺点：URL带有#不太美观，且在SEO优化方面相对较差。
const router = createRouter(&#123;  	history:createWebHashHistory(), //hash模式  	/******/&#125;)


4.5. 【to的两种写法】&lt;!-- 第一种：to的字符串写法 --&gt;&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;&lt;!-- 第二种：to的对象写法 --&gt;&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;

4.6. 【命名路由】作用：可以简化路由跳转及传参（后面就讲）。
给路由规则命名：
routes:[  &#123;    name:&#x27;zhuye&#x27;,    path:&#x27;/home&#x27;,    component:Home  &#125;,  &#123;    name:&#x27;xinwen&#x27;,    path:&#x27;/news&#x27;,    component:News,  &#125;,  &#123;    name:&#x27;guanyu&#x27;,    path:&#x27;/about&#x27;,    component:About  &#125;]

跳转路由：
&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;&lt;router-link to=&quot;/news/detail&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;



4.7. 【嵌套路由】
编写News的子路由：Detail.vue

配置路由规则，使用children配置项：
const router = createRouter(&#123;  history:createWebHistory(),	routes:[		&#123;			name:&#x27;zhuye&#x27;,			path:&#x27;/home&#x27;,			component:Home		&#125;,		&#123;			name:&#x27;xinwen&#x27;,			path:&#x27;/news&#x27;,			component:News,			children:[				&#123;					name:&#x27;xiang&#x27;,					path:&#x27;detail&#x27;,					component:Detail				&#125;			]		&#125;,		&#123;			name:&#x27;guanyu&#x27;,			path:&#x27;/about&#x27;,			component:About		&#125;	]&#125;)export default router

跳转路由（记得要加完整路径）：
&lt;router-link to=&quot;/news/detail&quot;&gt;xxxx&lt;/router-link&gt;&lt;!-- 或 --&gt;&lt;router-link :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;xxxx&lt;/router-link&gt;

记得去Home组件中预留一个&lt;router-view&gt;
&lt;template&gt;  &lt;div class=&quot;news&quot;&gt;    &lt;nav class=&quot;news-list&quot;&gt;      &lt;RouterLink v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot; :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;        &#123;&#123;news.name&#125;&#125;      &lt;/RouterLink&gt;    &lt;/nav&gt;    &lt;div class=&quot;news-detail&quot;&gt;      &lt;RouterView/&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;

4.8. 【路由传参】query参数
传递参数
&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;	跳转&lt;/router-link&gt;				&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;&lt;RouterLink   :to=&quot;&#123;    //name:&#x27;xiang&#x27;, //用name也可以跳转    path:&#x27;/news/detail&#x27;,    query:&#123;      id:news.id,      title:news.title,      content:news.content    &#125;  &#125;&quot;&gt;  &#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;

接收参数：
import &#123;useRoute&#125; from &#x27;vue-router&#x27;const route = useRoute()// 打印query参数console.log(route.query)

params参数
传递参数
&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;				&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;&lt;RouterLink   :to=&quot;&#123;    name:&#x27;xiang&#x27;, //用name跳转    params:&#123;      id:news.id,      title:news.title,      content:news.title    &#125;  &#125;&quot;&gt;  &#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;

接收参数：
import &#123;useRoute&#125; from &#x27;vue-router&#x27;const route = useRoute()// 打印params参数console.log(route.params)


备注1：传递params参数时，若使用to的对象写法，必须使用name配置项，不能用path。
备注2：传递params参数时，需要提前在规则中占位。

4.9. 【路由的props配置】作用：让路由组件更方便的收到参数（可以将路由参数作为props传给组件）
&#123;	name:&#x27;xiang&#x27;,	path:&#x27;detail/:id/:title/:content&#x27;,	component:Detail,  // props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件  // props:&#123;a:1,b:2,c:3&#125;,   // props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件  // props:true    // props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件  props(route)&#123;    return route.query  &#125;&#125;

4.10. 【 replace属性】
作用：控制路由跳转时操作浏览器历史记录的模式。

浏览器的历史记录有两种写入方式：分别为push和replace：

push是追加历史记录（默认值）。
replace是替换当前记录。


开启replace模式：
&lt;RouterLink replace .......&gt;News&lt;/RouterLink&gt;

4.11. 【编程式导航】路由组件的两个重要的属性：$route和$router变成了两个hooks
import &#123;useRoute,useRouter&#125; from &#x27;vue-router&#x27;const route = useRoute()const router = useRouter()console.log(route.query)console.log(route.parmas)console.log(router.push)console.log(router.replace)

4.12. 【重定向】
作用：将特定的路径，重新定向到已有路由。

具体编码：
&#123;    path:&#x27;/&#x27;,    redirect:&#x27;/about&#x27;&#125;

5. pinia5.1【准备一个效果】 

5.2【搭建 pinia 环境】第一步：npm install pinia
第二步：操作src/main.ts
import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;/* 引入createPinia，用于创建pinia */import &#123; createPinia &#125; from &#x27;pinia&#x27;/* 创建pinia */const pinia = createPinia()const app = createApp(App)/* 使用插件 */&#123;&#125;app.use(pinia)app.mount(&#x27;#app&#x27;)

此时开发者工具中已经有了pinia选项


5.3【存储+读取数据】
Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它。

它有三个概念：state、getter、action，相当于组件中的： data、 computed 和 methods。

具体编码：src/store/count.ts
// 引入defineStore用于创建storeimport &#123;defineStore&#125; from &#x27;pinia&#x27;// 定义并暴露一个storeexport const useCountStore = defineStore(&#x27;count&#x27;,&#123;  // 动作  actions:&#123;&#125;,  // 状态  state()&#123;    return &#123;      sum:6    &#125;  &#125;,  // 计算  getters:&#123;&#125;&#125;)

具体编码：src/store/talk.ts
// 引入defineStore用于创建storeimport &#123;defineStore&#125; from &#x27;pinia&#x27;// 定义并暴露一个storeexport const useTalkStore = defineStore(&#x27;talk&#x27;,&#123;  // 动作  actions:&#123;&#125;,  // 状态  state()&#123;    return &#123;      talkList:[        &#123;id:&#x27;yuysada01&#x27;,content:&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;&#125;,     		&#123;id:&#x27;yuysada02&#x27;,content:&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;&#125;,        &#123;id:&#x27;yuysada03&#x27;,content:&#x27;心里给你留了一块地，我的死心塌地&#x27;&#125;      ]    &#125;  &#125;,  // 计算  getters:&#123;&#125;&#125;)

组件中使用state中的数据
&lt;template&gt;  &lt;h2&gt;当前求和为：&#123;&#123; sumStore.sum &#125;&#125;&lt;/h2&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;  // 引入对应的useXxxxxStore	  import &#123;useSumStore&#125; from &#x27;@/store/sum&#x27;    // 调用useXxxxxStore得到对应的store  const sumStore = useSumStore()&lt;/script&gt;

&lt;template&gt;	&lt;ul&gt;    &lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&gt;      &#123;&#123; talk.content &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;  import axios from &#x27;axios&#x27;  import &#123;useTalkStore&#125; from &#x27;@/store/talk&#x27;  const talkStore = useTalkStore()&lt;/script&gt;

5.4.【修改数据】(三种方式)
第一种修改方式，直接修改
countStore.sum = 666

第二种修改方式：批量修改
countStore.$patch(&#123;  sum:999,  school:&#x27;atguigu&#x27;&#125;)

第三种修改方式：借助action修改（action中可以编写一些业务逻辑）
import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;  /*************/  actions: &#123;    //加    increment(value:number) &#123;      if (this.sum &lt; 10) &#123;        //操作countStore中的sum        this.sum += value      &#125;    &#125;,    //减    decrement(value:number)&#123;      if(this.sum &gt; 1)&#123;        this.sum -= value      &#125;    &#125;  &#125;,  /*************/&#125;)

组件中调用action即可
// 使用countStoreconst countStore = useCountStore()// 调用对应actioncountStore.incrementOdd(n.value)

5.5.【storeToRefs】
借助storeToRefs将store中的数据转为ref对象，方便在模板中使用。
注意：pinia提供的storeToRefs只会将数据做转换，而Vue的toRefs会转换store中数据。

&lt;template&gt;	&lt;div class=&quot;count&quot;&gt;		&lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;  import &#123; useCountStore &#125; from &#x27;@/store/count&#x27;  /* 引入storeToRefs */  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;	/* 得到countStore */  const countStore = useCountStore()  /* 使用storeToRefs转换countStore，随后解构 */  const &#123;sum&#125; = storeToRefs(countStore)&lt;/script&gt;

5.6.【getters】
概念：当state中的数据，需要经过处理后再使用时，可以使用getters配置。

追加getters配置。
// 引入defineStore用于创建storeimport &#123;defineStore&#125; from &#x27;pinia&#x27;// 定义并暴露一个storeexport const useCountStore = defineStore(&#x27;count&#x27;,&#123;  // 动作  actions:&#123;    /************/  &#125;,  // 状态  state()&#123;    return &#123;      sum:1,      school:&#x27;atguigu&#x27;    &#125;  &#125;,  // 计算  getters:&#123;    bigSum:(state):number =&gt; state.sum *10,    upperSchool():string&#123;      return this. school.toUpperCase()    &#125;  &#125;&#125;)

组件中读取数据：
const &#123;increment,decrement&#125; = countStorelet &#123;sum,school,bigSum,upperSchool&#125; = storeToRefs(countStore)

5.7.【$subscribe】通过 store 的 $subscribe() 方法侦听 state 及其变化
talkStore.$subscribe((mutate,state)=&gt;&#123;  console.log(&#x27;LoveTalk&#x27;,mutate,state)  localStorage.setItem(&#x27;talk&#x27;,JSON.stringify(talkList.value))&#125;)



5.8. 【store组合式写法】import &#123;defineStore&#125; from &#x27;pinia&#x27;import axios from &#x27;axios&#x27;import &#123;nanoid&#125; from &#x27;nanoid&#x27;import &#123;reactive&#125; from &#x27;vue&#x27;export const useTalkStore = defineStore(&#x27;talk&#x27;,()=&gt;&#123;  // talkList就是state  const talkList = reactive(    JSON.parse(localStorage.getItem(&#x27;talkList&#x27;) as string) || []  )  // getATalk函数相当于action  async function getATalk()&#123;    // 发请求，下面这行的写法是：连续解构赋值+重命名    let &#123;data:&#123;content:title&#125;&#125; = await axios.get(&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;)    // 把请求回来的字符串，包装成一个对象    let obj = &#123;id:nanoid(),title&#125;    // 放到数组中    talkList.unshift(obj)  &#125;  return &#123;talkList,getATalk&#125;&#125;)



6. 组件通信Vue3组件通信和Vue2的区别：

移出事件总线，使用mitt代替。


vuex换成了pinia。
把.sync优化到了v-model里面了。
把$listeners所有的东西，合并到$attrs中了。
$children被砍掉了。

常见搭配形式：
 

6.1. 【props】概述：props是使用频率最高的一种通信方式，常用与 ：父 ↔ 子。

若 父传子：属性值是非函数。
若 子传父：属性值是函数。

父组件：
&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件，&lt;/h3&gt;		&lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;		&lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;		&lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;	import Child from &#x27;./Child.vue&#x27;	import &#123; ref &#125; from &quot;vue&quot;;	// 数据	const car = ref(&#x27;奔驰&#x27;)	const toy = ref()	// 方法	function getToy(value:string)&#123;		toy.value = value	&#125;&lt;/script&gt;

子组件
&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h3&gt;子组件&lt;/h3&gt;		&lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;		&lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;		&lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;	import &#123; ref &#125; from &quot;vue&quot;;	const toy = ref(&#x27;奥特曼&#x27;)		defineProps([&#x27;car&#x27;,&#x27;getToy&#x27;])&lt;/script&gt;

6.2. 【自定义事件】
概述：自定义事件常用于：子 &#x3D;&gt; 父。
注意区分好：原生事件、自定义事件。


原生事件：
事件名是特定的（click、mosueenter等等）    
事件对象$event: 是包含事件相关信息的对象（pageX、pageY、target、keyCode）


自定义事件：
事件名是任意名称
事件对象$event: 是调用emit时所提供的数据，可以是任意类型！！！




示例：
&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;&lt;Child @send-toy=&quot;toy = $event&quot;/&gt;&lt;!--注意区分原生事件与自定义事件中的$event--&gt;&lt;button @click=&quot;toy = $event&quot;&gt;测试&lt;/button&gt;

//子组件中，触发事件：this.$emit(&#x27;send-toy&#x27;, 具体数据)

6.3. 【mitt】概述：与消息订阅与发布（pubsub）功能类似，可以实现任意组件间通信。
安装mitt
npm i mitt

新建文件：src\utils\emitter.ts
// 引入mitt import mitt from &quot;mitt&quot;;// 创建emitterconst emitter = mitt()/*  // 绑定事件  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;    console.log(&#x27;abc事件被触发&#x27;,value)  &#125;)  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;    console.log(&#x27;xyz事件被触发&#x27;,value)  &#125;)  setInterval(() =&gt; &#123;    // 触发事件    emitter.emit(&#x27;abc&#x27;,666)    emitter.emit(&#x27;xyz&#x27;,777)  &#125;, 1000);  setTimeout(() =&gt; &#123;    // 清理事件    emitter.all.clear()  &#125;, 3000); */// 创建并暴露mittexport default emitter

接收数据的组件中：绑定事件、同时在销毁前解绑事件：
import emitter from &quot;@/utils/emitter&quot;;import &#123; onUnmounted &#125; from &quot;vue&quot;;// 绑定事件emitter.on(&#x27;send-toy&#x27;,(value)=&gt;&#123;  console.log(&#x27;send-toy事件被触发&#x27;,value)&#125;)onUnmounted(()=&gt;&#123;  // 解绑事件  emitter.off(&#x27;send-toy&#x27;)&#125;)

【第三步】：提供数据的组件，在合适的时候触发事件
import emitter from &quot;@/utils/emitter&quot;;function sendToy()&#123;  // 触发事件  emitter.emit(&#x27;send-toy&#x27;,toy.value)&#125;

注意这个重要的内置关系，总线依赖着这个内置关系
6.4.【v-model】
概述：实现 父↔子 之间相互通信。

前序知识 —— v-model的本质
&lt;!-- 使用v-model指令 --&gt;&lt;input type=&quot;text&quot; v-model=&quot;userName&quot;&gt;&lt;!-- v-model的本质是下面这行代码 --&gt;&lt;input   type=&quot;text&quot;   :value=&quot;userName&quot;   @input=&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;&gt;

组件标签上的v-model的本质：:moldeValue ＋ update:modelValue事件。
&lt;!-- 组件标签上使用v-model指令 --&gt;&lt;AtguiguInput v-model=&quot;userName&quot;/&gt;&lt;!-- 组件标签上v-model的本质 --&gt;&lt;AtguiguInput :modelValue=&quot;userName&quot; @update:model-value=&quot;userName = $event&quot;/&gt;

AtguiguInput组件中：
&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;		&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;    &lt;input        type=&quot;text&quot;        :value=&quot;modelValue&quot;        @input=&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;    &gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;  // 接收props  defineProps([&#x27;modelValue&#x27;])  // 声明事件  const emit = defineEmits([&#x27;update:model-value&#x27;])&lt;/script&gt;

也可以更换value，例如改成abc
&lt;!-- 也可以更换value，例如改成abc--&gt;&lt;AtguiguInput v-model:abc=&quot;userName&quot;/&gt;&lt;!-- 上面代码的本质如下 --&gt;&lt;AtguiguInput :abc=&quot;userName&quot; @update:abc=&quot;userName = $event&quot;/&gt;

AtguiguInput组件中：
&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;input        type=&quot;text&quot;        :value=&quot;abc&quot;        @input=&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;    &gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;  // 接收props  defineProps([&#x27;abc&#x27;])  // 声明事件  const emit = defineEmits([&#x27;update:abc&#x27;])&lt;/script&gt;

如果value可以更换，那么就可以在组件标签上多次使用v-model
&lt;AtguiguInput v-model:abc=&quot;userName&quot; v-model:xyz=&quot;password&quot;/&gt;

6.5.【$attrs 】
概述：$attrs用于实现当前组件的父组件，向当前组件的子组件通信（祖→孙）。

具体说明：$attrs是一个对象，包含所有父组件传入的标签属性。

 注意：$attrs会自动排除props中声明的属性(可以认为声明过的 props 被子组件自己“消费”了)



父组件：
&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件&lt;/h3&gt;		&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot; :updateA=&quot;updateA&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;	import Child from &#x27;./Child.vue&#x27;	import &#123; ref &#125; from &quot;vue&quot;;	let a = ref(1)	let b = ref(2)	let c = ref(3)	let d = ref(4)	function updateA(value)&#123;		a.value = value	&#125;&lt;/script&gt;

子组件：
&lt;template&gt;	&lt;div class=&quot;child&quot;&gt;		&lt;h3&gt;子组件&lt;/h3&gt;		&lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;	import GrandChild from &#x27;./GrandChild.vue&#x27;&lt;/script&gt;

孙组件：
&lt;template&gt;	&lt;div class=&quot;grand-child&quot;&gt;		&lt;h3&gt;孙组件&lt;/h3&gt;		&lt;h4&gt;a：&#123;&#123; a &#125;&#125;&lt;/h4&gt;		&lt;h4&gt;b：&#123;&#123; b &#125;&#125;&lt;/h4&gt;		&lt;h4&gt;c：&#123;&#123; c &#125;&#125;&lt;/h4&gt;		&lt;h4&gt;d：&#123;&#123; d &#125;&#125;&lt;/h4&gt;		&lt;h4&gt;x：&#123;&#123; x &#125;&#125;&lt;/h4&gt;		&lt;h4&gt;y：&#123;&#123; y &#125;&#125;&lt;/h4&gt;		&lt;button @click=&quot;updateA(666)&quot;&gt;点我更新A&lt;/button&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;	defineProps([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;updateA&#x27;])&lt;/script&gt;

6.6. 【$refs、$parent】
概述：

$refs用于 ：父→子。
$parent用于：子→父。


原理如下：



属性
说明



$refs
值为对象，包含所有被ref属性标识的DOM元素或组件实例。


$parent
值为对象，当前组件的父组件实例对象。




6.7. 【provide、inject】
概述：实现祖孙组件直接通信

具体使用：

在祖先组件中通过provide配置向后代组件提供数据
在后代组件中通过inject配置来声明接收数据


具体编码：
【第一步】父组件中，使用provide提供数据
&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件&lt;/h3&gt;    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;    &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt;    &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt;    &lt;Child/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;  import Child from &#x27;./Child.vue&#x27;  import &#123; ref,reactive,provide &#125; from &quot;vue&quot;;  // 数据  let money = ref(100)  let car = reactive(&#123;    brand:&#x27;奔驰&#x27;,    price:100  &#125;)  // 用于更新money的方法  function updateMoney(value:number)&#123;    money.value += value  &#125;  // 提供数据  provide(&#x27;moneyContext&#x27;,&#123;money,updateMoney&#125;)  provide(&#x27;car&#x27;,car)&lt;/script&gt;


注意：子组件中不用编写任何东西，是不受到任何打扰的

【第二步】孙组件中使用inject配置项接受数据。
&lt;template&gt;  &lt;div class=&quot;grand-child&quot;&gt;    &lt;h3&gt;我是孙组件&lt;/h3&gt;    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;    &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;  import &#123; inject &#125; from &#x27;vue&#x27;;  // 注入数据 let &#123;money,updateMoney&#125; = inject(&#x27;moneyContext&#x27;,&#123;money:0,updateMoney:(x:number)=&gt;&#123;&#125;&#125;)  let car = inject(&#x27;car&#x27;)&lt;/script&gt;

6.8. 【pinia】参考之前pinia部分的讲解
6.9. 【slot】1. 默认插槽![[前端了解&#x2F;vue&#x2F;_resources&#x2F;Vue3快速上手&#x2F;b23349c818acb70a1969d7300ae27368_MD5.png]]
父组件中：        &lt;Category title=&quot;今日热门游戏&quot;&gt;          &lt;ul&gt;            &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;          &lt;/ul&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;          &lt;div class=&quot;item&quot;&gt;            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;            &lt;!-- 默认插槽 --&gt;            &lt;slot&gt;&lt;/slot&gt;          &lt;/div&gt;        &lt;/template&gt;

2. 具名插槽父组件中：        &lt;Category title=&quot;今日热门游戏&quot;&gt;          &lt;template v-slot:s1&gt;            &lt;ul&gt;              &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;            &lt;/ul&gt;          &lt;/template&gt;          &lt;template #s2&gt;            &lt;a href=&quot;&quot;&gt;更多&lt;/a&gt;          &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;          &lt;div class=&quot;item&quot;&gt;            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;            &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;            &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;          &lt;/div&gt;        &lt;/template&gt;

3. 作用域插槽
理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（新闻数据在News组件中，但使用数据所遍历出来的结构由App组件决定）

具体编码：
父组件中：      &lt;Game v-slot=&quot;params&quot;&gt;      &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt;      &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;        &lt;ul&gt;          &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;      &lt;/Game&gt;子组件中：      &lt;template&gt;        &lt;div class=&quot;category&quot;&gt;          &lt;h2&gt;今日游戏榜单&lt;/h2&gt;          &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot;&gt;&lt;/slot&gt;        &lt;/div&gt;      &lt;/template&gt;      &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt;        import &#123;reactive&#125; from &#x27;vue&#x27;        let games = reactive([          &#123;id:&#x27;asgdytsa01&#x27;,name:&#x27;英雄联盟&#x27;&#125;,          &#123;id:&#x27;asgdytsa02&#x27;,name:&#x27;王者荣耀&#x27;&#125;,          &#123;id:&#x27;asgdytsa03&#x27;,name:&#x27;红色警戒&#x27;&#125;,          &#123;id:&#x27;asgdytsa04&#x27;,name:&#x27;斗罗大陆&#x27;&#125;        ])      &lt;/script&gt;

7. 其它 API7.1.【shallowRef 与 shallowReactive 】shallowRef
作用：创建一个响应式数据，但只对顶层属性进行响应式处理。

用法：
let myVar = shallowRef(initialValue);

特点：只跟踪引用值的变化，不关心值内部的属性变化。


shallowReactive
作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的

用法：
const myObj = shallowReactive(&#123; ... &#125;);

特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。


总结
通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。

7.2.【readonly 与 shallowReadonly】readonly
作用：用于创建一个对象的深只读副本。

用法：
const original = reactive(&#123; ... &#125;);const readOnlyCopy = readonly(original);

特点：

对象的所有嵌套属性都将变为只读。
任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。


应用场景：

创建不可变的状态快照。
保护全局状态或配置不被修改。



shallowReadonly
作用：与 readonly 类似，但只作用于对象的顶层属性。

用法：
const original = reactive(&#123; ... &#125;);const shallowReadOnlyCopy = shallowReadonly(original);

特点：

只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。

适用于只需保护对象顶层属性的场景。




7.3.【toRaw 与 markRaw】toRaw
作用：用于获取一个响应式对象的原始对象， toRaw 返回的对象不再是响应式的，不会触发视图更新。

官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。


何时使用？ —— 在需要将响应式对象传递给非 Vue 的库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象


具体编码：
import &#123; reactive,toRaw,markRaw,isReactive &#125; from &quot;vue&quot;;/* toRaw */// 响应式对象let person = reactive(&#123;name:&#x27;tony&#x27;,age:18&#125;)// 原始对象let rawPerson = toRaw(person)/* markRaw */let citysd = markRaw([  &#123;id:&#x27;asdda01&#x27;,name:&#x27;北京&#x27;&#125;,  &#123;id:&#x27;asdda02&#x27;,name:&#x27;上海&#x27;&#125;,  &#123;id:&#x27;asdda03&#x27;,name:&#x27;天津&#x27;&#125;,  &#123;id:&#x27;asdda04&#x27;,name:&#x27;重庆&#x27;&#125;])// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了let citys2 = reactive(citys)console.log(isReactive(person))console.log(isReactive(rawPerson))console.log(isReactive(citys))console.log(isReactive(citys2))

markRaw
作用：标记一个对象，使其永远不会变成响应式的。

例如使用mockjs时，为了防止误把mockjs变为响应式对象，可以使用 markRaw 去标记mockjs


编码：
/* markRaw */let citys = markRaw([  &#123;id:&#x27;asdda01&#x27;,name:&#x27;北京&#x27;&#125;,  &#123;id:&#x27;asdda02&#x27;,name:&#x27;上海&#x27;&#125;,  &#123;id:&#x27;asdda03&#x27;,name:&#x27;天津&#x27;&#125;,  &#123;id:&#x27;asdda04&#x27;,name:&#x27;重庆&#x27;&#125;])// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了let citys2 = reactive(citys)

7.4.【customRef】作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。
实现防抖效果（useSumRef.ts）：
import &#123;customRef &#125; from &quot;vue&quot;;export default function(initValue:string,delay:number)&#123;  let msg = customRef((track,trigger)=&gt;&#123;    let timer:number    return &#123;      get()&#123;        track() // 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新        return initValue      &#125;,      set(value)&#123;        clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;          initValue = value          trigger() //通知Vue数据msg变化了        &#125;, delay);      &#125;    &#125;  &#125;)   return &#123;msg&#125;&#125;

组件中使用：
8. Vue3新组件8.1. 【Teleport】
什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。

&lt;teleport to=&#x27;body&#x27; &gt;    &lt;div class=&quot;modal&quot; v-show=&quot;isShow&quot;&gt;      &lt;h2&gt;我是一个弹窗&lt;/h2&gt;      &lt;p&gt;我是弹窗中的一些内容&lt;/p&gt;      &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;    &lt;/div&gt;&lt;/teleport&gt;

8.2. 【Suspense】
等待异步组件时渲染一些额外内容，让应用有更好的用户体验 
使用步骤： 
异步引入组件
使用Suspense包裹组件，并配置好default 与 fallback



import &#123; defineAsyncComponent,Suspense &#125; from &quot;vue&quot;;const Child = defineAsyncComponent(()=&gt;import(&#x27;./Child.vue&#x27;))

&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;          &lt;template v-slot:default&gt;            &lt;Child/&gt;          &lt;/template&gt;          &lt;template v-slot:fallback&gt;            &lt;h3&gt;加载中.......&lt;/h3&gt;          &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;



8.3.【全局API转移到应用对象】
app.component
app.config
app.directive
app.mount
app.unmount
app.use

8.4.【其他】
过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from。

keyCode 作为 v-on 修饰符的支持。

v-model 指令在组件上的使用已经被重新设计，替换掉了 v-bind.sync。

v-if 和 v-for 在同一个元素身上使用时的优先级发生了变化。

移除了$on、$off 和 $once 实例方法。

移除了过滤器 filter。

移除了$children 实例 propert。
……


]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Pinia源码</title>
    <url>/posts/2025/08/Fronted/Vue/pinia%E6%BA%90%E7%A0%81/a42dfghf.html</url>
    <content><![CDATA[参考资料pinia的使用(原链接)Pinia支持compositionApi同时也兼容optionsApi(this指向)Pinia可以采用多个store,store之间可以互相调用（扁平化），不用担心命名冲突问题
Pinia基本使用组合式 与 选项式 写法
import &#123;defineStore&#125; from &#x27;../pinia/store&#x27;import &#123;ref, computed&#125; from &#x27;vue&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, ()=&gt;&#123;    const count = ref(0)    const double = computed(()=&gt;&#123;        return count.value * 2    &#125;)    const increment = (num)=&gt;&#123;        count.value += num        console.log(todosStore.todos)    &#125;    return &#123;        count,        double,        increment    &#125;&#125;)// export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;//     state: () =&gt; &#123;//         return &#123;count: 0&#125;//     &#125;,//     getters: &#123;//         double() &#123;//             return this.count * 2//         &#125;//     &#125;,//     actions: &#123;//         increment(num) &#123;//             this.count += num//         &#125;//     &#125;// &#125;)
Pinia实现原理pinia中的最近数据存储在state中_s 记录了state的各个时态, 存放各个时期的state, 有利于重复使用
创建原理import &#123; PiniaSymbol &#125; from &quot;./rootStore&quot;import &#123;ref&#125; from &#x27;vue&#x27;export function createPinia () &#123;        const state = ref(&#123;&#125;)    const pinia = &#123;        install(app) &#123;            app.config.globalProperties.$pinia = pinia //更新            app.provide(PiniaSymbol, pinia)        &#125;,        state,        _s:new Map(),    &#125;    return pinia&#125;

存储原理其中参数含义如下：

id：store 的 id，必须唯一。

options： 与 Vue 的选项式 API 类似，我们也可以传入一个带有 id、 state、actions与 getters属性的 Option 对象。

storeSetup：以 setup 的方式创建，与 Vue 的 setup 函数 相似。在 storeSetup 中：

ref() 等同于 state。
computed() 等同于 getters。
function() 等同于 actions



getCurrentInstance 是 Vue 3 Composition API 中的一个函数，用于获取当前组件实例的内部对象
在调用useStore时, 首先会在_s中寻找所求值是否存在, 如果存在则直接赋值, 不存在则再创建一个新的值
export function defineStore(idOrOptions, setup) &#123;    let id    let options    //判断是组合式还是选项式    const isSetupStore = typeof setup === &#x27;function&#x27;    if(typeof idOrOptions == &#x27;string&#x27;) &#123;        id = idOrOptions        options = setup    &#125; else &#123; //不是字符串, 说明传入了对象        options = idOrOptions        id = idOrOptions.id    &#125;        function useStore() &#123;        const currentInstance = getCurrentInstance()        const pinia = currentInstance &amp;&amp; inject(PiniaSymbol)                if (!pinia._s.has(id)) &#123; //这个store时第一次使用                        if(isSetupStore)&#123;                createSetupStore(id, setup, pinia)                //创建组合式store            &#125; else &#123;                createOptionStore(id, options, pinia)                //创建后的store只需要存到_s中即可            &#125;        &#125;        //如果已经有了store, 不用创建, 直接拿到store就行了        const store = pinia._s.get(id)        return store    &#125;    return useStore&#125;

组合式this指向当传入的值中含有方法对象时, 直接处理会改变对象的this指向, 这时候需要进行特殊处理保证传入的类的this指向不改变通过wrapAction函数显示转换他们的this指向
将处理好的值与旧值进行更新 (Object.assign)加入到_s中, 在二次调用时减少计算
//setupStore 用户已经提供了完整的setup方法了, 我们只需执行setup函数即可,//通过这个返回值, 将其放在store上即可function createSetupStore(id, setup, pinia) &#123;    const store = reactive(&#123;&#125;)        //处理this指向    function wrapAction (action) &#123;        return function () &#123;            //将action中的this永远处理成store, 保证this指向正确            return action.call(store, ...arguments)        &#125;    &#125;    const setupStore = setup()    //拿到的setupStore可能没有处理this指向    //处理this    for (let prop in setupStore) &#123;        const value = setupStore[prop]        if (typeof value === &#x27;function&#x27;) &#123;            setupStore[prop] = wrapAction(value)        &#125;    &#125;    Object.assign(store, setupStore)//加入到队伍里面        pinia._s.set(id, store)    return store &#125;

选项式相比与组合式, 选项式多了一个setup()函数
在此过程中，state 的内容也会被存储到 pinia.state 中。action 则会被 wrapAction 处理
每一项 action 进行处理，目的是为了支持 $onAction 方法，此方法会在执行 action 时执行回调函数，回调函数可以接收三个参数分别是：被调用的 store、action 的名字、传递给 action 的参数。
getters处理时, 需将他的逻辑执行完后,得到的值存入store
function createOptionStore(id, options, pinia) &#123;    const &#123;state, actions, getters=&#123;&#125;&#125; = options //store里面的数据, 已定义    const store = reactive(&#123;&#125;) //pinia就是创建了一个响应式对象而已    //需要将这个api转换成组合式    function setup() &#123;        pinia.state.value[id] = state ? state() : &#123;&#125;        let localState = toRefs(pinia.state.value[id])        return Object.assign(            localState,            actions,            Object.keys(getters).reduce((computeds, getterKey)=&gt;&#123;                computeds[getterKey] = computed(()=&gt;&#123;                    return getters[getterKey].call(store)                &#125;)                return computeds            &#125;, &#123;&#125;)        )    &#125;    //减少代码的重复书写, 此时选项式store已经将数据处理, 剩下的逻辑和处理组合式一致    createSetupStore(id, setup, pinia)    return store &#125;

store中的基础api实现定义
 const actionSubscriptions = [] //所有订阅的actions时间, 都应该放在这个数组中 const partialStore = &#123;     $patch,     //订阅状态     $subscribe(callback) &#123;         watch(pinia.state.value[id], state =&gt; &#123;             callback(&#123;id&#125;, state)         &#125;)     &#125;,     //订阅用户的action操作     $onAction: addSubscription.bind(null, actionSubscriptions), //订阅&#125; //pinia就是创建了一个响应式对象而已 const store = reactive(partialStore)
patch将一个 state 补丁应用于当前状态。允许传递嵌套值。
$patch 允许两种参数传递方式，传入一个函数，或一个 state 的补丁。
    //这里需要获取原来的所有状态    function $patch(partialStateOrMutator) &#123;        //partialStateOrMutator部分状态        if(typeof partialStateOrMutator !== &#x27;function&#x27;) &#123;            //当前store中的全部状态, pinia.state.value[i]            merge(pinia.state.value[id], partialStateOrMutator)        &#125; else &#123;            partialStateOrMutator(pinia.state.value[id])        &#125;    &#125;        function merge(target, partialState) &#123;        for (const key in partialState) &#123;            if(!partialState.hasOwnProperty(key)) continue            //原始的值            const targetValue = target[key]            //后来的值            const subPatch = partialState[key]            if (isObject(targetValue) &amp;&amp; isObject(subPatch) &amp;&amp; !isRef(subPatch)) &#123; //ref也是对象                target[key] = merge(targetValue, subPatch)            &#125; else &#123;                //如果不需要合并直接用新的覆盖掉老的即可                target[key] = subPatch            &#125;        &#125;    &#125;     if(isSetupStore) &#123;        pinia.state.value[id] = &#123;&#125;        //用于存放setupStore中的状态    &#125;

reset功能: 通过建立一个新的状态对象，将 store 重设为初始状态。
重置方法只能在optionStore中书写因为在setupStore中, 用户自己控制状态; 

state: () &#x3D;&gt; ({count: 1}) 是一个函数，只要重新调用就可以获取原始值，
而 组合式 构建的话 state 以 ref() 的形式实现，无法获取原始值。

    store.$reset = function() &#123; //这个方法只支持optionAPI, 因为setupAPI中, 用户自己控制状态        const newState = state ? state() : &#123;&#125;        this.$patch(newState)    &#125;

subscribe设置一个回调，当状态发生变化时被调用。它会返回一个用来移除此回调的函数。 请注意，当在组件内调用 store.$subscribe() 时，除非 detached 被设置为 true， 否则当组件被卸载时，它将被自动清理掉。
在store中的实现
        //订阅状态        $subscribe(callback) &#123;            watch(pinia.state.value[id], state =&gt; &#123;                callback(&#123;id&#125;, state)            &#125;)        &#125;,

onAction设置一个回调，当一个 action 即将被调用时，就会被调用。 回调接收一个对象， 其包含被调用 action 的所有相关信息：

store: 被调用的 store
name: action 的名称
args: 传递给 action 的参数

除此之外，它会接收两个函数， 允许在 action 完成或失败时执行的回调。
它还会返回一个用来删除回调的函数。 请注意，当在组件内调用 store.$onAction() 时，除非 detached 被设置为 true， 否则当组件被卸载时，它将被自动清理掉。
调用方法
export function addSubscription(subscriptions, callback) &#123;    subscriptions.push(callback)//将回调函数放在数组中      const removeSubscription = () =&gt; &#123;       const idx = subscriptions.indexOf(callback)       if(idx &gt; -1) &#123;        subscriptions.splice(idx, 1)       &#125;    &#125;    return removeSubscription&#125;  export function triggerSubscriptions(subscriptions, ...args) &#123;    subscriptions.slice().forEach(cb=&gt;cb(...args))&#125;

定义
const actionSubscriptions = [] //所有订阅的actions时间, 都应该放在这个数组中const partialStore = &#123;	...        //订阅用户的action操作        $onAction: addSubscription.bind(null, actionSubscriptions),   &#125;
实现
  //处理this指向    function wrapAction (action) &#123;        return function () &#123;            const afterCallbacks = []            const onErrorCallbacks = []            const after = (callback) =&gt; &#123;                afterCallbacks.push(callback)            &#125;            const onError = (callback) =&gt; &#123;                onErrorCallbacks.push(callback)            &#125;            triggerSubscriptions(actionSubscriptions, &#123;after, onError&#125;) //让用户传递after和error            //将action中的this永远处理成store, 保证this指向正确              //回调的方式            let result            try &#123;//正常action是一个回调的情况, 可以直接拿到返回值出发after回调            result =  action.call(store, ...arguments)            triggerSubscriptions(afterCallbacks, result)            &#125; catch (e)&#123;                triggerSubscriptions(onErrorCallbacks, e)            &#125;            //如果返回值是一个Promise, 针对场景做处理              if(result instanceof Promise) &#123;                return result.then(value =&gt; &#123;                    triggerSubscriptions(afterCallbacks, value)                &#125;).catch(error =&gt; &#123;                    triggerSubscriptions(onErrorCallbacks, error)                &#125;)            &#125;              return result        &#125;    &#125;

pinia插件写法main.js中
const pinia = createPinia()function persitisPlugin() &#123; //为了用户传递参数, 所以用函数    return (&#123;store, id&#125;) =&gt; &#123; //所有的store都会执行此方法         let oldState = JSON.parse(localStorage.getItem(id) || &#x27;&#123;&#125;&#x27;)        store.$state = oldState        // store.$patch(oldState) //将老状态进行替换        store.$subscribe((mutation, state) =&gt; &#123;            localStorage.setItem(id, JSON.stringify(state))        &#125;)    &#125;&#125;pinia.use(persitisPlugin()) //use API可以去调用插件的install方法，将app注入进来app.use(pinia) //使用pinia插件


createStore中
import &#123; PiniaSymbol &#125; from &quot;./rootStore&quot;import &#123;ref&#125; from &#x27;vue&#x27;export function createPinia () &#123;    //pinia是管理多个state状态的    const state = ref(&#123;&#125;)    const _p = [] //插件    const pinia = &#123;        install(app) &#123;            app.config.globalProperties.$pinia = pinia            app.provide(PiniaSymbol, pinia)        &#125;,        use(plugin) &#123;            _p.push(plugin)            return pinia        &#125;,        state,        _s:new Map(),        _p    &#125;    return pinia&#125;
总结仓库链接这里附上整个源码
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>pinia</tag>
      </tags>
  </entry>
  <entry>
    <title>route和router的区别</title>
    <url>/posts/2025/08/Fronted/Vue/route%E5%92%8Crouter%E5%8C%BA%E5%88%AB/a4edfghf.html</url>
    <content><![CDATA[前端路由傻傻分不清？route和router的区别，看完这篇别再搞混了！一、前言：为什么这俩玩意儿容易搞混？刚学前端路由时，我也被route和router搞得头晕眼花，面试还被问：”你能说说$route和$router的区别吗？” 我支支吾吾半天，面试官的表情逐渐凝固… 😅
今天，我们就来彻底搞懂这俩兄弟，让你以后再也不怕面试官的灵魂拷问！
二、一句话总结router（路由器） ：是管理路由的老大，负责整个路由的跳转、拦截、传参等。route（路由信息） ：是当前激活的路由对象，存储当前页面的路径、参数、查询参数等信息。
举个栗子 🌰：
router 就像快递公司的调度中心，决定包裹（页面）怎么配送。route 就像你手里的快递单，记录当前包裹（页面）的信息（地址、收件人、订单号等）。
三、代码实战：Vue里的route和router1. router（Vue Router实例）router是全局路由管理器，负责跳转、拦截、动态路由等操作。
// 在Vue组件里使用export default &#123;  methods: &#123;    我的跳转方法() &#123;      // router.push() 用于跳转      this.$router.push(&#x27;/home&#x27;); // 跳转到首页            // router.replace() 替换当前路由（不记录历史）      this.$router.replace(&#x27;/login&#x27;);            // router.go() 前进/后退      this.$router.go(-1); // 返回上一页    &#125;  &#125;&#125;

2. route（当前路由信息）route是当前激活的路由对象，包含路径、参数、查询参数等信息。
export default &#123;  created() &#123;    // 获取当前路由信息    console.log(this.$route.path);    // 当前路径，比如 &quot;/user/123&quot;    console.log(this.$route.params); // 动态参数，比如 &#123; id: &quot;123&quot; &#125;    console.log(this.$route.query);   // 查询参数，比如 ?name=小杨 → &#123; name: &quot;小杨&quot; &#125;  &#125;&#125;

四、React里的类似概念React没有$router和$route，但概念是相通的：
router → BrowserRouter &#x2F; HashRouter（React Router的管理者）route → useLocation() &#x2F; useParams()（当前路由信息）
import &#123; useNavigate, useLocation, useParams &#125; from &#x27;react-router-dom&#x27;;function 我的组件() &#123;  const navigate = useNavigate(); // 相当于 this.$router  const location = useLocation(); // 相当于 this.$route  const params = useParams();     // 相当于 this.$route.params  const 跳转首页 = () =&gt; &#123;    navigate(&#x27;/home&#x27;); // 相当于 this.$router.push(&#x27;/home&#x27;)  &#125;;  return (    &lt;div&gt;      当前路径：&#123;location.pathname&#125; &lt;br /&gt;      参数：&#123;params.id&#125;    &lt;/div&gt;  );&#125;

五、常见误区 &amp; 面试题1. this.$router 和 this.$route 能互换吗？❌ 不能！
this.$router 是路由管理器（负责跳转、拦截）。this.$route 是当前路由信息（只读数据）。
2. 为什么动态路由要用params，而查询参数用query？params（如&#x2F;user&#x2F;:id）→ 是路由的一部分，适合SEO、短链接。query（如?name&#x3D;小杨）→ 是额外参数，不影响路由匹配。
3. 编程式导航能用替代吗？✅ 可以，但场景不同：
 → 模板里用（类似标签）。this.$router.push() → JS逻辑里用（比如登录后跳转）。
六、总结


对比项
router
route



作用
路由管理（跳转、拦截）
当前路由信息（路径、参数）


类比
快递公司调度中心
你手里的快递单


Vue
this.$router
this.$route


React
useNavigate()
useLocation()


记住口诀：
router管跳转，route管信息跳转找router，参数找route
七、最后的小故事曾经我在项目里疯狂用this.$route.push()，结果控制台疯狂报错，debug半小时才发现… 我把router和route写反了！  😭
所以，看完这篇，千万别再搞混了！  🚀
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/posts/2025/04/Fronted/%E4%B8%89%E4%BB%B6%E5%A5%97/01-%20HTML/2eec1551.html</url>
    <content><![CDATA[HTML标签语法规范基本语法概述1.所有标签都包括在&lt;&gt;里面2.并且一般情况下&lt;&gt;都成对出现，例如：&lt; html &gt;(开始标签) 和&lt; &#x2F;html &gt;(结束标签)，称为双标签3.有极少数标签必须是单个标签，例如：&lt; br &#x2F;&gt;
标签关系包含关系和并列关系![[Pasted image 20240415204232.png]]![[Pasted image 20240415204710.png]]
基本结构标签&lt; html&gt; 和 &lt; &#x2F;html&gt; 内包含所有内容&lt; head&gt; 和&lt; &#x2F;head&gt; 内包含头部即![[Pasted image 20240415215459.png]]&lt; title&gt;和&lt; &#x2F;title&gt; 内包含标题即![[Pasted image 20240415215620.png]]&lt; body&gt; 和&lt; &#x2F;body&gt;内包含主要内容即![[Pasted image 20240415215711.png]]
HTML常用标签标题标签分为6个等级的网页标题，&lt; h1&gt;-&lt; h6&gt;双标签如：&lt; h1&gt; &lt; &#x2F;h1&gt;特点：1.加了标题的文字会被加粗，字号也会依次变大2.一个标题独占一行效果：![[Pasted image 20240416171114.png]]
段落和换行标签段落标签可以将网页分为若干个段落。如：&lt; p&gt; 我是一个段落&lt; &#x2F;p&gt;不加段落标签的效果：![[Pasted image 20240416172237.png]]![[Pasted image 20240416172253.png]]加了段落标签的效果：![[Pasted image 20240416172531.png]]![[Pasted image 20240416172541.png]]特点：1、文本在一个段落中会根据浏览器窗口大小自动换行如：![[Pasted image 20240416172734.png]]
![[Pasted image 20240416172745.png]]
2、段落和段落之间保有空隙
换行标签让某段文本强制换行显示。 (单标签)![[Pasted image 20240416175007.png]]![[Pasted image 20240416175016.png]]特点：1、是单个标签2、标签只是简单开始新的一行，与段落不同，段落之间会插入一些间距
文本格式化标签把文字 设置粗体、斜体、下划线等效果，突出重要性加粗：&lt; strong&gt;&lt; &#x2F;strong&gt; 或者&lt; b&gt;&lt; &#x2F;b&gt;倾斜：&lt; em&gt;&lt; &#x2F;em&gt;或者&lt; i&gt;&lt; &#x2F;i&gt;删除线：&lt; del&gt;&lt; &#x2F;del&gt;或者&lt; s&gt;&lt; &#x2F;s&gt;下划线：&lt; ins&gt;&lt; &#x2F;ins&gt;或者&lt; u&gt;&lt; &#x2F;u&gt;
&lt;div&gt;和&lt;span&gt;标签他俩没有语义，它们就是一个盒子，用来装内容特点：1、&lt;div&gt;标签用来布局，但是一行只能放一个&lt;div&gt;.是大盒子2、&lt;span&gt;标签用来布局，一行上可以放多个&lt;span&gt;.是小盒子![[Pasted image 20240416195917.png]]![[Pasted image 20240416195931.png]]
图像标签和路径图像标签&lt;img /&gt; 用于定义HTML页面中的图像，是单个标签&lt;img src=&quot;图像URL&quot; /&gt;src是&lt;img&gt;标签的必须属性，用于指定图像文件的路径和文件名要使用图片在网页中，必须把图片和网页放在同一个文件夹中![[Pasted image 20240416201001.png]]注意点：1、图像标签可以有多个属性，必须写在标签名的后面2、属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开3、属性的格式：属性&#x3D;“属性值”
路径1、目录文件夹和根目录目录文件夹：普通文件夹，里面存放做页面的相关素材，如html文件、图片等根目录：打开目录文件夹的第一层就是根目录
2、路径通常建立一个文件夹来储存图像文件，这时查找图像，需要采取“路径”的方式来指定图像文件的位置相对路径：相对路径是从代码所在的这个文件出发，去寻找目标文件![[Pasted image 20240416203015.png]]
绝对路径：![[Pasted image 20240416203639.png]]
超链接标签&lt;a&gt;标签用于定义超链接，作用是从一个页面链接到另一个页面
链接的语法格式![[Pasted image 20240416204158.png]]
![[Pasted image 20240416204242.png]]
链接分类1、外部链接：例如&lt;a herf=&quot;http://www.baidu.com&quot;&gt;百度&lt; /a&gt;2、内部链接：网站内部页面之间的相互链接，直接连接内部页面名称即可，例如：&lt;a herf=&quot;index.html&quot;&gt;首页&lt; /a&gt;3、空链接：没有确定链接目标，&lt;a herf=&quot;#&quot;&gt;首页&lt; /a&gt;4、下载链接：如果herf里面地址是一个文件或者压缩包，会下载这个文件5、网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接6、锚点链接：当我们点击链接，可以快速定位到页面中的某个位置
![[Pasted image 20240416210054.png]]

HTML中的注释和特殊字符注释注释以““结束![[Pasted image 20240416210352.png]]
特殊字符![[Pasted image 20240416210706.png]]
表格标签表格的主要作用用于显示、展示数据，可以让数据显示的非常规整，可读性非常好。
表格的基本语法1、&lt;table&gt; &lt;/table&gt;是用于定义表格的标签2、&lt;tr&gt; &lt;/tr&gt;标签用于定义表格中的行，必须嵌套在&lt;table&gt; &lt;/table&gt;标签中3、&lt;td&gt; &lt;/td&gt;用于定义表格中的单元格，必须嵌套在&lt;tr&gt; &lt;/tr&gt;标签中4、字母td指表格数据，即数据单元格的内容
表头单元格标签一般表头单元格位于表格的第一列或第一行，表头单元格里面的文本内容加粗居中显示&lt;th&gt; &lt;/th&gt;标签表示HTML表格的表头部分
表格属性实际开发不常用，后面通过CSS来设置 ![[Pasted image 20240416214210.png]] 注意：属性写在table里面
表格结构标签使用场景：表格可能很长，为了更好表示表格的语义，可以将表格分为表格头部和表格主体两部分&lt;thead&gt;标签表示表格的头部区域，&lt;tbody&gt;标签表示表格的主体区域1、&lt;thead&gt; &lt;/thead&gt;用于定义表格的头部。&lt;thead&gt;内部必须拥有&lt;tr&gt;标签，一般位于第一行2、&lt;tbody&gt; &lt;/tbody&gt;用于定义表格的主体，主要用于放数据本体3、以上标签都是放在&lt;table&gt; &lt;/table&gt;标签中
合并单元格1、合并单元格的方式*跨行合并：rowspan&#x3D;“合并单元格的个数”![[Pasted image 20240416220516.png]]
*跨列合并：colspan&#x3D;“合并单元格的个数”![[Pasted image 20240416220545.png]]
2、目标单元格（写合并代码）![[Pasted image 20240416220705.png]]、
3、合并单元格三部曲先确定是跨行还是跨列合并找到目标单元格，写上合并方式&#x3D;合并的单元格数量。如：&#96; 删除多余单元格
列表标签用来布局特点：整齐、整洁、有序
无序列表&lt;ul&gt; &lt;/ul&gt; 标签表示HTML项目中的无序列表&lt;li&gt; &lt;/li&gt;标签表示列表项语法基本格式如下：&lt;ul&gt; 	 列表项1  	 列表项2  	 列表项3   *注意：* 1、 中只能嵌套 ，直接在 标签中输入其他标签或者文字的做法是不被允许的 2、 &#96;之间相当于一个容器，可以容纳所有元素3、无序列表带有自己的样式属性，但在实际使用时，我们使用CSS来设置
有序列表&lt;ol&gt; &lt;/ol&gt;标签表示HTML项目中的有序列表&lt;li&gt; &lt;/li&gt;标签表示列表项语法基本格式如下：&lt;ol&gt; 	 列表项1  	 列表项2  	 列表项3   *注意：* 1、 中只能嵌套 ，直接在 标签中输入其他标签或者文字的做法是不被允许的 2、 &#96;之间相当于一个容器，可以容纳所有元素3、有序列表带有自己的样式属性，但在实际使用时，我们使用CSS来设置
自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号&lt;dl&gt; &lt;/dl&gt;标签表示HTML项目中的自定义列表&lt;dt&gt; &lt;/dt&gt;标签表示定义项目的名字&lt;dd&gt; &lt;/dd&gt;标签表示描述每一个项目语法基本格式如下：&lt;dl&gt; 	 名词1  	 名词1解释1  	 名词1解释2   *注意：* 1、 里面只能包含 和 2、&lt;dt&gt; &lt;/dt&gt;和&lt;dd&gt; &lt;/dd&gt;个数没有限制，通常是一个&lt;dt&gt;对应多个&lt;dd&gt;
表单标签为什么需要表单目的：收集用户信息
表单的组成由表单域、表单控件（即表单元素）、提示信息3部分构成![[Pasted image 20240417153314.png]]
表单域包含表单元素的区域&lt;form&gt; &lt;/form&gt;标签表示定义表单域，以实现用户信息的收集和传递&lt;form&gt;会把它范围内的表单元素信息提交给服务器语法基本格式如下：&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot;	各种表单元素控件&lt;/form&gt;![[Pasted image 20240417171730.png]]
表单控件（表单元素）&lt;input&gt;表单元素&lt;input&gt;标签用于收集用户信息，是单个标签在&lt;input&gt;标签中，包含一个type属性，根据不同的type属性值，输入字段拥有很多种形式（可以是文本、字段、复选框、掩码后的文本控件、单选按钮、按钮等）。语法基本格式如下：&lt;input type = &quot;属性值&quot; /&gt;
![[Pasted image 20240417172528.png]]
除type属性外，&lt;input&gt;标签还有其他很多属性：![[Pasted image 20240417173755.png]]注意：1、name和value是每个表单元素都有的属性值，主要给后台人员使用2、name表单元素的名字，要求单选按钮和复选框要有相同的name值*3、checked属性主要针对于单选按钮和复选框，作用是一打开界面就默认选中某个表单元素4、maxlength是用户可以在表单元素输入的最大字符数，一般较少使用
![[Pasted image 20240417193415.png]]
![[Pasted image 20240417193426.png]]
&lt;lable&gt;标签&lt;label&gt; &lt;/label&gt;标签为input元素定义标签&lt;label&gt;标签用于绑定一个表单元素，当点击&lt;label&gt;标签内的文本时，浏览器会自动将焦点（光标）转到对应的表单元素上，用来增加用户体验语法基本格式如下：
&lt;label for=&quot;性别&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;性别&quot; /&gt;
核心：&lt;label&gt;标签的for属性应当与相关元素的id属性相同![[Pasted image 20240417194812.png]]
&lt;select&gt;表单元素使用场景：在页面中，如果有多个选择让用户选择，并且想要节约页面空间，我们可以使用&lt;select&gt;标签控件定义下拉列表![[Pasted image 20240417195224.png]]
语法基本格式如下：&lt;select&gt;	&lt;option&gt;选项1&lt;/option&gt;	&lt;option&gt;选项2&lt;/option&gt;	&lt;option&gt;选项3&lt;/option&gt;	...&lt;/select&gt;注意：1、&lt;select&gt;中至少包含一对&lt;option&gt;2、在&lt;option&gt;中定义selected&#x3D;“selected”时，当前项即为默认选中项
![[Pasted image 20240417200003.png]]
![[Pasted image 20240417200023.png]]
&lt;textarea&gt;表单元素使用场景：当用户输入内容较多的情况下，我们使用&lt;textarea&gt;标签&lt;textarea&gt;标签是用于定义多行文本输入的控件语法基本格式如下：&lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt;	文本内容&lt;/textarea&gt;
![[Pasted image 20240417201708.png]]
![[Pasted image 20240417201721.png]]
注意：1、通过&lt;textarea&gt;标签可以轻松地创建多行文本输入框2、cols&#x3D;”每行中的字符数“ ，rows&#x3D;”显示的行数”，我们在实际开发中不会使用，都是用CSS来改变大小
HTML5的新特性注意： 这些新特性都有兼容问题，基本上是IE9+以上版本的浏览器才支持
HTML新增的语义化标签1、&lt;header&gt;头部标签2、&lt;nav&gt;导航标签3、&lt;article&gt;内容标签4、section&gt;定义文档某个区域5、&lt;aside&gt;侧边栏标签6、&lt;footer&gt;尾部标签
![[Pasted image 20240417203348.png]]
![[Pasted image 20240417204528.png]]
![[Pasted image 20240417204547.png]]
HTML5新增的多媒体标签视频&lt;video&gt;当前&lt;video&gt;元素支持三种视频格式：MP4，WebM，Ogg。但尽量使用MP4格式，因为几乎所有浏览器都支持语法基本格式如下：&lt;video src=&quot;文件地址&quot; controls=&quot;contorls&quot;&gt; &lt;/video&gt;注意：如果害怕浏览器不支持当前格式，可以参照以下写法
![[Pasted image 20240417205241.png]]
![[Pasted image 20240417205638.png]]
音频&lt;audio&gt;当前&lt;audio&gt;支持3中音频格式：MP3、Wav、Ogg。但尽量使用MP3格式，因为几乎所有浏览器都支持语法基本格式如下：&lt;audio src=&quot;文件地址&quot; controls=&quot;contorls&quot;&gt; &lt;/audio&gt;注意：如果害怕浏览器不支持当前格式，可以参照以下写法
![[Pasted image 20240417205926.png]]
![[Pasted image 20240417210200.png]]
HTML5新增的input标签![[Pasted image 20240417210434.png]]
![[Pasted image 20240417211039.png]]、![[Pasted image 20240417211048.png]]
HTML5新增的表单属性![[Pasted image 20240417211533.png]]
HTML5新增的全局属性 data-*
data-* ，用于自定义数据属性
data设置的属性可以在JavaScript的DOM操作中 通过dataset轻松获取
通常用于HTML和JavaScript数据之间的传递



&lt;div class=&quot;box&quot; title=&quot;abc&quot; data-name=&quot;why&quot; data-age=&quot;18&quot;&gt;	box&lt;/div&gt;&lt;script&gt;	const boxE1 = document.querySelector(&quot;.box&quot;)	console.log(boxE1.dataset)&lt;/script&gt;

在小程序中，通过data-来传递数据

]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端三件套</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/posts/2025/04/Fronted/%E4%B8%89%E4%BB%B6%E5%A5%97/02-%20CSS/ee69e452.html</url>
    <content><![CDATA[CSS1简介使用场景：美化网页，布局页面CSS是一种标记语言CSS可以美化HTML，让HTML更漂亮，让页面布局更简单CSS最大价值：由HTML专注去做结构呈现，样式交给CSS，即结构与样式相分离
语法规范CSS规则由两个主要的部分构成：选择器以及一条或多条声明基本语法格式如下：选择器 &#123; 属性：值；  属性：值;&#125;注意：1、选择器是用与指定CSS样式的HTML标签，花括号内是对该对象设置的具体样式2、属性和属性值以“键值对”的形式出现3、属性是对指定的对象设置的样式属性，例如字体大小，文本颜色等4、属性和属性值之间用英文 “:” 分开
CSS代码风格样式格式1、紧凑格式h3&#123;color:deeppink;font-size:20px;&#125;2、展开格式h3&#123;	color:pink;	font-size:20px;&#125;推荐使用第二种格式，更直观
样式大小写1、小写h3&#123;	color:pink;&#125;2、大写H3&#123;	COLOR:PINK;&#125;强烈推荐样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外
空格规范h3 &#123;	color: pink;&#125;1、属性值前面，冒号后面，保留一个空格2、选择器（标签）和大括号之间保留空格
CSS基础选择器CSS选择器的作用选择器（选择符）就是根据不同需求把不同的标签选出来。简单来说，就是选择标签用的
选择器的分类选择器可以分为基础选择器和复合选择器两大类
基础选择器基础选择器是由单个选择器组成的基础选择器又包括：标签选择器、类选择器、id选择器、通配选择器
标签选择器标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;体验CSS语法规范&lt;/title&gt;    &lt;style&gt;        p &#123;            color: skyblue;        &#125;        div &#123;            color: pink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;有点意思&lt;/p&gt;    &lt;p&gt;男生&lt;/p&gt;    &lt;p&gt;男生&lt;/p&gt;    &lt;div&gt;女生&lt;/div&gt;    &lt;div&gt;女生&lt;/div&gt;    &lt;div&gt;女生&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240418211124.png]]
作用标签选择器可以把某一类标签全部选择出来，比如所有的&lt;div&gt;标签优点能快速为页面中同类型的标签统一设置样式缺点不能设计差异化样式，只能选择全部的当前标签
类选择器如果想要差异化选择不同的标签，单独选一个或几个标签，可以使用类选择器语法基本格式如下：.类名 &#123;	属性1: 属性值1;	...&#125;结构需要用class属性来调用class类的意思
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;体验CSS语法规范&lt;/title&gt;    &lt;style&gt;        .red &#123;            color: red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;red&quot;&gt;有点意思&lt;/p&gt;    &lt;p&gt;男生&lt;/p&gt;    &lt;p&gt;男生&lt;/p&gt;    &lt;div&gt;女生&lt;/div&gt;    &lt;div&gt;女生&lt;/div&gt;    &lt;div class=&quot;red&quot;&gt;女生&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240418212404.png]]
注意：1、类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义）2、不要使用纯数字、中文等命名3、命名要有意义，尽量让别人一眼就知道这个类名的目的4、命名规范：![[Pasted image 20240418213307.png]]
![[Pasted image 20240418213332.png]]![[Pasted image 20240418213405.png]]
类选择器口诀： 样式点定义，结构类（class）调用，一个或多个，开发最常用
类选择器——多类名给一个标签指定多个类名，从而达到更多的选择目的。1、多类名使用方式语法基本格式：&lt;div class=&quot;red font20&quot;&gt;亚瑟&lt;/div&gt;在标签class属性中写多个类名在多个类名中间必须用*空格分开
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;体验CSS语法规范&lt;/title&gt;    &lt;style&gt;        .red &#123;            color: red;        &#125;        .font &#123;            font-size: 35px;        &#125;        .backcolor &#123;            background-color: pink ;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;red font backcolor&quot;&gt;有点意思&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240419195421.png]]
2、多类名开发中的使用场景可以把一些标签元素相同的样式（共同的部分）放到一个类里面这些标签都可以调用这个公共的类，然后再调用自己独有的类从而节省CSS代码，统一修改也非常方便
id选择器id选择器可以为标有特定id的HTML元素指定特定的样式注意： HTML元素以id属性来设置id选择器，CSS中id属性以 “#” 来定义语法基本格式：#id名 &#123;	属性1：属性值1；	...&#125;例如，将id为nav元素中的内容设置为红色#nav &#123;	color: red;&#125;口诀：样式#定义，结构id调用，只能调用1次，别人切勿使用
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;体验CSS语法规范&lt;/title&gt;    &lt;style&gt;        #pink &#123;            color: pink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;pink&quot;&gt;小羊计算器&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240419200737.png]]
通配符选择器CSS中，通配符选择器使用 “#” 定义，它表示选取页面中的所有元素（标签）
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;体验CSS语法规范&lt;/title&gt;    &lt;style&gt;        * &#123;            color: pink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;pink&quot;&gt;小羊计算器&lt;/div&gt;    &lt;span&gt;欢迎使用小羊计算器&lt;/span&gt;    &lt;ul&gt;        &lt;li&gt;开始使用&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240419201910.png]]
注意：1、通配符选择器不需要调用，自动就给所有的元素使用样式2、特殊情况才使用，如清楚所有的元素标签内外边距* &#123;	margin: 0;	padding: 0;&#125;
基础选择器总结![[Pasted image 20240419202504.png]]
复合选择器
复合选择器可以更准确、更高效的选择目标元素（标签）
复合选择器是由两个或多个基础选择器，通过不同的方式组合而成
常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等

后代选择器（重要）后代选择器又称包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代语法基本格式：元素1 元素2 &#123;样式声明&#125;上述语法表示选择元素1里面的所有元素2（后代元素）例如：ul li &#123;样式声明&#125; /* 选择元素1里面的所有元素2 */

元素1和元素2中间用**空格隔开
元素1是父级，元素2是子级，最终选择的是元素2
元素2可以是儿子，也可以是孙子等，只要是元素1的后代即可
元素1和元素2可以是任意基础选择器

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot; /&gt;		&lt;meta			name=&quot;viewport&quot;			content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;		&lt;title&gt;体验CSS语法规范&lt;/title&gt;		&lt;style&gt;            ol li &#123;                color: pink;            &#125;            ol li a &#123;                color: red;            &#125;            .nav li a &#123;                color: red;            &#125;        &lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;ol&gt;            &lt;li&gt;我是ol的孩子&lt;/li&gt;            &lt;li&gt;我也是&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是孙子&lt;/a&gt;&lt;/li&gt;        &lt;/ol&gt;        &lt;ul class=&quot;nav&quot;&gt;            &lt;li&gt;我是ul的孩子&lt;/li&gt;            &lt;li&gt;我是ul的孩子&lt;/li&gt;            &lt;li&gt;我是ul的孩子&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是ul的孩子&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;	&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240423165951.png]]
子选择器（重要）子选择器只能选择作为某元素的最近一级子元素。简单理解就是选亲儿子元素语法基本格式：元素1&gt;元素2 &#123;样式声明&#125;上述语法表示选择元素1里面的所有直接后代（子元素）元素2例如：div &gt; p &#123;样式声明&#125; /* 选择div里面所有最近一级p标签元素 */

元素1和元素2中间用大于号隔开
元素1是父级，元素2是子级。最终选择的是元素2
元素2必须是亲儿子，其孙子之类都不归他管

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot; /&gt;		&lt;meta			name=&quot;viewport&quot;			content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;		&lt;title&gt;体验CSS语法规范&lt;/title&gt;		&lt;style&gt;            .nav &gt; a &#123;                color: pink;            &#125;        &lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;div class=&quot;nav&quot;&gt;            &lt;a href=&quot;#&quot;&gt;我是儿子&lt;/a&gt;            &lt;p&gt;                &lt;a href=&quot;#&quot;&gt;我是孙子&lt;/a&gt;            &lt;/p&gt;        &lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240423170941.png]]
并集选择器并集选择器可以选择多组标签，同时为他们定义相同的样式。 通常用于集体声明并集选择器是各选择器通过英文逗号(,)连接而成，任何形式的选择器都可以作为并集选择器的一部分语法基本格式：元素1，元素2 &#123;样式声明&#125;上述语法表示选择元素1和元素2例如：ul,  div {样式声明} &#x2F;* 选择ul和div标签 *&#x2F;&#96;

元素1和元素2中间用逗号隔开
逗号可以理解为和的意思
并集选择器通常用于集体声明

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot; /&gt;		&lt;meta			name=&quot;viewport&quot;			content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;		&lt;title&gt;体验CSS语法规范&lt;/title&gt;		&lt;style&gt;			/* 把熊大熊二改为粉色 */			/* div,			p &#123;				color: pink;			&#125; */			/* 把熊大熊二还有小猪一家改为粉色 */			div,			p,			.pig li &#123;				color: pink;			&#125;		&lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;div&gt;熊大&lt;/div&gt;		&lt;p&gt;熊二&lt;/p&gt;		&lt;span&gt;光头强&lt;/span&gt;		&lt;ul class=&quot;pig&quot;&gt;			&lt;li&gt;小猪佩奇&lt;/li&gt;			&lt;li&gt;猪爸爸&lt;/li&gt;			&lt;li&gt;猪妈妈&lt;/li&gt;		&lt;/ul&gt;	&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240423172936.png]]
伪类选择器伪类选择器用[[1.图像与计算机视觉类]]于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素伪类选择器书写最大的特点是用冒号(:)表示，比如 :hover、:first-child伪类选择器很多，如链接伪类、结构伪类等
链接伪类访问器a: link /*  选择所有未被访问的链接 */a: visited /*  选择所有已被访问的链接 ，即已经被访问过的链接的样式*/a: hover /*  选择鼠标指针位于其上的链接，即鼠标放在链接上样式的改变 */a: active /*  选择活动链接（鼠标按下未弹起的链接），即按下鼠标时样式的改变 */
 链接伪类选择器注意事项 1、为了确保生效，请按照LVHA的循顺序声明：:link - :visited - :hover - :active 2、因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式
链接伪类选择器实际工作开发中的写法/* a是标签选择器 所有的链接  */a &#123;	color: gray:&#125;/* :hover是链接伪类选择器 鼠标经过 */a:hover &#123;	color: red; /* 鼠标经过的时候，由原来的灰色变成了红色 */&#125;
:focus 伪类选择器:focus 伪类选择器用于选取获得焦点（光标）的表单元素，一般情况&lt;input&gt;类表单元素才能获得语法基本格式：input:focus &#123;	background-color: yellow;&#125;
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot; /&gt;		&lt;meta			name=&quot;viewport&quot;			content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;		&lt;title&gt;体验CSS语法规范&lt;/title&gt;		&lt;style&gt;			input:focus &#123;                background: pink;                color: red;            &#125;		&lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;input type=&quot;text&quot;&gt;        &lt;input type=&quot;text&quot;&gt;        &lt;input type=&quot;text&quot;&gt;	&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240423200908.png]]
结构伪类:nth-child():nth-child(x)是父元素的第x个子元素语法基本格式：元素1 元素2:nth-child(x)上述语法表示选取元素1里面的第x个元素2元素1是元素2的父亲
:nth-child(2n)是父元素的第偶数个子元素语法基本格式：元素1 元素2:nth-child(2n)上述语法表示选取元素1里面的第偶数个元素2注意：

n代表任意正整数和0
是父元素中的第偶数个子元素（第2、4、6、8……个）
跟 :nth-child(even)同义

:nth-child(2n+1)是父元素的第奇数个子元素语法基本格式：元素1 元素2:nth-child(2n+1)注意：

n代表任意正整数和0
是父元素中的第奇数个子元素（第1、3、5、7……个）
跟 :nth-child(odd)同义

:nth-child(-n+x)是父元素的前x个子元素语法基本格式：元素1 元素2:nth-child(-n+x)表示前x个子元素
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot; /&gt;		&lt;meta			name=&quot;viewport&quot;			content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;		&lt;title&gt;体验CSS语法规范&lt;/title&gt;		&lt;style&gt;			ul li:nth-child(2n) &#123;				color: red;			&#125;			ul li:nth-child(2n+1)&#123;				color: pink;			&#125;			div div:nth-child(6)&#123;				color: skyblue;			&#125;			div div:nth-child(-n+3)&#123;				color: green;			&#125;		&lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;ul&gt;			&lt;li&gt;列表元素1&lt;/li&gt;			&lt;li&gt;列表元素2&lt;/li&gt;			&lt;li&gt;列表元素3&lt;/li&gt;			&lt;li&gt;列表元素4&lt;/li&gt;			&lt;li&gt;列表元素5&lt;/li&gt;			&lt;li&gt;列表元素6&lt;/li&gt;		&lt;/ul&gt;		&lt;div&gt;			&lt;div&gt;列表元素1&lt;/div&gt;			&lt;div&gt;列表元素2&lt;/div&gt;			&lt;div&gt;列表元素3&lt;/div&gt;			&lt;div&gt;列表元素4&lt;/div&gt;			&lt;div&gt;列表元素5&lt;/div&gt;			&lt;div&gt;列表元素6&lt;/div&gt;			&lt;div&gt;列表元素7&lt;/div&gt;			&lt;div&gt;列表元素8&lt;/div&gt;			&lt;div&gt;列表元素9&lt;/div&gt;			&lt;div&gt;列表元素10&lt;/div&gt;		&lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240424164515.png]]
:nth-last-child():nth-last-child()的语法跟 :nth-child()类似，不同点是 :nth-last-child()从最后一个子元素开始往前计数:nth-last-child(1) 代表倒数第一个子元素:nth-last-child(-n+2) 代表最后2个子元素
:nth-of-type()用法跟 :nth-of-type()类似

不同点是：:nth-of-type() 计数时只计算同种类型的元素![[Pasted image 20240425182154.png]]

:nth-last-of-type() 用法跟 :nth-of-type() 类似，只是 :nth-last-of-type() 是从最后一个这种类型的子元素开始往前计数
其他结构伪类
:first-child，等同于 :nth-child(1)
:last-child，等同于 :nth-last-child(1)
:first-of-type，等同于 :nth-of-type(1)
:last-of-type，等同于 :nth-last-of-type(1)
:only-child，是父元素中唯一的子元素
:only-of-type，是父元素中唯一的这种类型的子元素
:root，根元素，就是html元素
:empty，代表里面完全空白的元素

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot; /&gt;		&lt;meta			name=&quot;viewport&quot;			content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;		&lt;title&gt;体验CSS语法规范&lt;/title&gt;		&lt;style&gt;			/* 找寻父级下的子级的第三个，再看第三个是不是div */			div &gt; div:nth-child(3) &#123;				color: red;			&#125;			/* 找寻父级下的div子级的第三个 */			div &gt; div:nth-of-type(3) &#123;				color: red;			&#125;			:root &#123;				font-size: 30px;			&#125;			:empty &#123;				background-color: pink;				width: 200px;				height: 300px;			&#125;		&lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;div&gt;			&lt;div&gt;列表元素1&lt;/div&gt;			&lt;div&gt;列表元素2&lt;/div&gt;			&lt;div&gt;列表元素3&lt;/div&gt;			&lt;div&gt;列表元素4&lt;/div&gt;			&lt;div&gt;列表元素5&lt;/div&gt;			&lt;div&gt;列表元素6&lt;/div&gt;			&lt;div&gt;列表元素7&lt;/div&gt;			&lt;div&gt;列表元素8&lt;/div&gt;			&lt;div&gt;列表元素9&lt;/div&gt;			&lt;div&gt;列表元素10&lt;/div&gt;		&lt;/div&gt;		&lt;div&gt;&lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240425184246.png]]
否定伪类:not() 的格式是 :not(x)

x是一个简单选择器
元素选择器、通用选择器、属性选择器、类选择器、id选择器、伪类（除否定伪类）

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot; /&gt;		&lt;meta			name=&quot;viewport&quot;			content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;		&lt;title&gt;体验CSS语法规范&lt;/title&gt;		&lt;style&gt;			/* 除item外的其他元素 */			div :not(.item) &#123;				color: skyblue;			&#125;		&lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;div&gt;			&lt;div class=&quot;item&quot;&gt;元素列表1&lt;/div&gt;			&lt;div class=&quot;item&quot;&gt;元素列表2&lt;/div&gt;			&lt;div class=&quot;item&quot;&gt;元素列表3&lt;/div&gt;			&lt;div class=&quot;yjy&quot;&gt;元素列表1&lt;/div&gt;			&lt;div class=&quot;yjy&quot;&gt;元素列表2&lt;/div&gt;			&lt;div class=&quot;yjy&quot;&gt;元素列表3&lt;/div&gt;			&lt;div class=&quot;qxy&quot;&gt;元素列表1&lt;/div&gt;			&lt;div class=&quot;qxy&quot;&gt;元素列表2&lt;/div&gt;			&lt;div class=&quot;qxy&quot;&gt;元素列表3&lt;/div&gt;		&lt;/div&gt;		&lt;div&gt;&lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240425185747.png]]
复合选择器总结![[Pasted image 20240423201023.png]]
CSS字体属性CSS Fonts（字体）属性用于定义字体系列、大小、粗细、文字样式
字体系列CSS使用font-family属性定义文本的字体系列语法基本格式：p &#123;	font-family: &quot;微软雅黑&quot;;&#125;div &#123;	font-family: Arial, &quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125;注意：1、各种字体之间必须使用英文状态下的逗号搁开(前一个字体不能显示，自动看下一个字体)2、一般情况下，如果有空格隔开的多个单词组成的字体，加引号3、尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示4、最常见的几个字体：body{font-family: ‘Microsoft Yahei’, tahoma, arial, ‘Hiragino Sans GB’; }
字体大小CSS使用font-size属性定义字体大小语法基本格式如下：p &#123;	font-size: 20px;&#125;注意：1、px（像素）大小是我们网页的最常用的单位2、谷歌浏览器默认的文字大小为16px3、不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小4、可以给body指定整个界面文字大小（但标题比较特殊，需要单独指定）
字体粗细CSS使用font-weight属性设置文本字体的粗细语法基本格式：p &#123;	font-weight: bold;&#125;
![[Pasted image 20240419210053.png]]注意：1、学会让加粗标签（比如h和strong等）不加粗，或者其他标签加粗2、实际开发时，我们更喜欢用数字表示粗细
文字样式CSS使用font-style属性设置文本的风格语法基本格式：p &#123;	font-style: normal;&#125;
![[Pasted image 20240419212958.png]]注意： 平时我们很少给文字加斜体，反而要给斜体标签（em, i）改为不倾斜字体
字体复合属性语法基本格式：body &#123;	font: font-style font-weight font-size/line-height font-family;&#125;注意：1、使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开2、不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性不起作用
总结![[Pasted image 20240419215118.png]]
CSS文本属性CSS Text（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等
文本颜色color属性用于定义文本颜色
语法基本格式：div &#123;	color: red;&#125;
![[Pasted image 20240421155234.png]]开发中最常用的是16进制
对齐文本text-align属性用于设置元素内文本内容的水平对齐方式语法基本格式：div &#123;	text-align: center;&#125;
![[Pasted image 20240421174347.png]]
注意： 想要图片居中对齐，需要把图片放在一个p标签内，再给p标签添加水平居中对齐
装饰文本text-decoration属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等
![[Pasted image 20240421175228.png]]最常用于取消a链接自带的下划线
文本缩进text-indent属性用来指定文本的第一行的缩进，通常是将段落的首行缩进语法基本格式：1、所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值div &#123;	text-indent: 10px;&#125;2、em是一个相对单位，就是当前元素（font-size）1个文字的大小，如果当前元素没有设置大小，则会按照父元素的一个文字大小p &#123;	text-indent: 2em;&#125;
行间距line-height属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。语法基本格式：p &#123;	line-height: 26px;&#125;
![[Pasted image 20240421210855.png]]
总结![[Pasted image 20240421211545.png]]
CSS引入方式CSS的三种样式表1、行内样式表（行内式）2、内部样式表（嵌入式）3、外部样式表（链接式）
内部样式表内部样式表（内嵌样式表）是写在HTML页面内部，是将所有的CSS代码抽取出来，单独放在一个 &lt;style&gt;标签中。语法基本格式：&lt;style&gt;	div &#123;		color: red;		font-size: 12px;	&#125;&lt;style&gt;特点：

&lt;style&gt;标签理论上可以放在HTML文档的任何地方，*但一般会放在文档的&lt;head&gt;标签中 *
通过此方式，可以方便控制当前整个页面中的元素样式设置
代码结构清晰，但是并没有实现结构与样式完全分离
使用内部样式设定CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式

行内样式表行内样式表（内联样式表）是在元素内部的style属性中设定CSS样式，适用于修改简单样式语法基本格式：&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;欢迎使用小羊计算器&lt;/div&gt;
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;体验CSS语法规范&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 style= &quot;color: pink;&quot;&gt;小羊计算器&lt;/h1&gt;    &lt;span&gt;欢迎使用小羊计算器&lt;/span&gt;    &lt;ul&gt;        &lt;li&gt;开始使用&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240422195751.png]]注意：

style其实就是标签的属性
在双引号之间，写法要符合CSS规范
可以控制当前的标签设置样式
不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用
使用行内样式表设定CSS，通常也被称为行内式引入

外部样式表实际开发都是外部样式表，适用于样式比较多的情况，核心是：样式单独写在CSS文件中，之后把CSS文件引入到HTML页面中使用引入外部样式表的步骤：1、新建一个后缀名为 .css 的样式文件，把所有的CSS代码都放入此文件中2、在HTML页面中，使用&lt;link&gt;标签引入这个文件	语法基本格式：&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt;
![[Pasted image 20240422201307.png]]

使用外部样式表设定CSS，通常也被称为外链式或外链式引入，是开发中最常用的方式

总结![[Pasted image 20240422201605.png]]
Chrome调试工具使用1. 打开调试工具打开Chrome浏览器，按下F12键或者点击页面空白处-&gt;检查
2、使用调试工具
Ctrl+滚轮可以放大开发者代码大小
左边是HTML结构，右边是CSS样式
右边CSS样式可以改动数值和查看颜色
Ctrl+0复原浏览器大小
如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误
如果有样式，但是样式前面有黄色感叹号提示，则是样式属性书写错误

CSS2Emmet语法Emmet语法前身是Zen coding, 它使用缩写来提高HTML&#x2F;CSS的编写速度，Vscode内部已经集成该语法。
快速生成HTM结构语法1、生成标签，直接输入标签名，按tab键即可 比如 div 然后tab键，就可以生成&lt;div&gt; &lt;/div&gt;2、如果想要生成多个相同标签 加上 * 就可以了 比如 div * 3 就可以快速生成3个div3、如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了4、如果有兄弟关系的标签，用+就可以了 比如 div+p5、如果生成带有类名或者id名字的，直接写 .demo 或者 #two  tab键就可以了6、如果生成的div类名是有顺序的，可以用自增符号 ￥7、如果想要在生成的标签内部写内容可以用{ }表示
快速生成CSS样式语法CSS基本采取简写模式形式即可。1、比如 w200 按tab键可以生成 width: 200px;2、比如lh26 按tab键可以生成 line-height: 26px;
CSS的元素显示模式什么是元素显示模式作用：网页的标签非常多，在不同的地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页元素显示模式就是元素（标签）以什么方式进行显示，比如&lt;div&gt;自己占一行，比如一行可以放多个&lt;span&gt;HTML元素一般分为块元素和行内元素两种类型
块元素常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;元素是最典型的块元素块级元素的特点：

自己独占一行
高度、宽度、外边距以及内边距都可以控制
宽度默认是容器（父级宽度）的100%
是一个容器及盒子，里面可以放行内或者块级元素注意：


文字类的元素内不能使用块级元素
&lt;p&gt;标签主要用于存放文字，因此&lt;p&gt;里面不能放块级元素，特别是不能放&lt;div&gt;
同理，&lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素

行内元素常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签是最典型的行内元素。行内元素的特点：

相邻行内元素在一行上，一行可以显示多个
高、宽直接设置是无效的
默认宽度就是它本身内容的宽度
行内元素只能容纳文本或其他行内元素注意：


链接里面不能再放链接
特殊情况链接&lt;a&gt;里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全

行内块元素在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，它们同时具有块元素和行内元素的特点。行内块元素的特点：

和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）
默认宽度就是它本身内容的宽度（行内元素特点）
高度、行高、外边距以及内边距都可以控制（块级元素特点）

如何指定元素的显示类型display属性用于指定元素的显示类型常见的display属性值及其含义：

block：将元素呈现为块级元素。块级元素会独占一行，并且默认情况下会在前后添加换行符。常见的块级元素包括&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;-&lt;h6&gt;等。

inline：将元素呈现为内联元素。内联元素不会独占一行，而是与其他元素在同一行内显示，并根据内容自动收缩。常见的内联元素包括&lt;span&gt;、&lt;a&gt;、&lt;strong&gt;、&lt;em&gt;等。

inline-block：将元素呈现为内联块级元素。内联块级元素与内联元素类似，可以与其他元素在同一行内显示，但可以设置宽度、高度和内外边距。常见的内联块级元素包括&lt;img&gt;、&lt;button&gt;等。

none：将元素隐藏，不在页面中显示。隐藏后的元素不占据空间。

flex：将元素呈现为弹性盒子。通过使用弹性盒子布局，可以方便地创建灵活的、自适应的布局。常见的弹性盒子属性包括flex-direction、justify-content、align-items等。

grid：将元素呈现为网格容器。使用网格布局可以将页面划分为行和列，并使元素在网格中进行布局。常见的网格属性包括grid-template-columns、grid-template-rows、grid-gap等。


总结![[Pasted image 20240423213701.png]]
CSS3（布局）CSS元素定位标准流（Normal Flow）
默认情况下，元素都是按照normal flow 进行排布
从左到右、从上到下按顺序摆放好
默认情况下，互相之间不存在层叠现象



margin-padding位置调整
在标准流中，可以使用margin、padding对元素进行定位
其中margin还可以设置负数


缺点：
设置一个元素的margin或者padding，通常会影响标准流中其他元素的定位效果
不便于实现元素叠层效果


如果希望一个元素跳出标准流，单独的对某个元素进行定位
可以通过position属性来进行设置



相对定位认识元素定位
定位允许你从正常的文档流布局中取出元素，并使它们具有不同的行为

例如放在另一个元素上面
或者始终保持在浏览器视窗内的同一位置


定位在开发中非常常见
  ![[Pasted image 20240426210030.png]]![[Pasted image 20240426210100.png]]  ![[Pasted image 20240426210111.png]]


认识position属性
利用position属性可以对元素进行定位，常用取值有5个：  static、relative、absolute、sticky、fixed
默认值：
static：默认值，静态定位


使用下面的值，可以让元素变成定位元素：
realtive：相对定位
absolute：绝对定位
fixed：固定定位
sticky：粘性定位语法基本格式：position: realtive;



position值比对![[Pasted image 20240427175031.png]]
静态定位- static
position属性的默认值
元素按照normal flow布局
left、right、top、bottom没有任何作用



相对定位-relative
元素按照normal Flow布局

可以通过left、right、top、bottom进行定位

定位参照对象是元素自己原来的位置


left、right、top、bottom用来设置元素的具体位置，对元素的作用如下图所示：
  ![[Pasted image 20240426212721.png]]

相对定位的应用场景

在不影响其他元素位置的前提下，对当前元素位置进行微调



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box &#123;            /* 相对定位 */            position: relative;            left: 30px;            bottom: 50px;    &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;span&gt;我是span元素&lt;/span&gt;    &lt;strong class=&quot;box&quot;&gt;我是strong元素&lt;/strong&gt;    &lt;img src=&quot;../pct/pic.jpeg&quot; alt=&quot;&quot;&gt;    &lt;div&gt;我是div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240426213008.png]]
练习：写3的平方+2的三次方&#x3D;17这个式子：
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        span &#123;            /* 把指数缩小一点 */            font-size: 12px;            /* 位置调整为相对定位 */            position: relative;            /* 向上移 */            bottom: 10px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;!-- 3的平方+2的三次方=17 --&gt;        3&lt;span&gt;2&lt;/span&gt; + 2&lt;span&gt;3&lt;/span&gt; = 17    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240426213542.png]]
固定定位-fixed
元素脱离normal flow(脱离标准流、脱标)
可以通过left、right、top、bottom进行定位
定位参照对象是视口（viewport）
当画布滚动时，固定不动

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        span &#123;            position: fixed;            bottom: 20px;            right: 20px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;我是div&lt;/div&gt;    &lt;span&gt;我是span&lt;/span&gt;    &lt;img src=&quot;./photo/OIP.jpg&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240427145731.png]]
画布和视口![[Pasted image 20240427150152.png]]

视口：
文档的可视区域
如上图红框所示


画布：
用于渲染文档的区域
文档内容超出视口范围，可以通过滚动查看
如上图黑框所示


宽高对比：
画布 &gt;&#x3D; 视口练习：



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .handel &#123;            /* 固定位置 */            position: fixed;            right: 30px;            bottom: 30px;        &#125;        .handel .item &#123;            width: 80px;            height: 40px;            /* 文字居中 */            text-align: center;            /* 文字高度 */            line-height: 40px;            /* 背景颜色 */            background-color: rgb(89, 90, 91);            /* 字体颜色 */            color: #fff;            /* 角落的角圆半径 */            border-radius: 8px;            /* 鼠标放上去时，光标变成小手 */            cursor: pointer;        &#125;        /* 鼠标放上去时改变背景颜色 */        .handel .item:hover &#123;            background-color: pink;        &#125;        /* 间隔 */        .top &#123;            margin-bottom: 10px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;handel&quot;&gt;        &lt;div class=&quot;item top&quot;&gt;顶部&lt;/div&gt;        &lt;div class=&quot;item bottom&quot;&gt;反馈&lt;/div&gt;    &lt;/div&gt;    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;        &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;       &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;      &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;      &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240427163004.png]]
绝对定位-absolute
元素脱离normal flow
可以通过left、right、top、bottom进行定位
定位参照对象是最邻近的定位祖先元素
如果找不到这样的祖先，参照对象是视口（这时候跟固定定位类似）


定位元素
position值不为static的元素
也就是position值为relative、absolute、fixed的元素



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        strong &#123;            /* 脱离标准流 */            position: absolute;            top: 0;            right: 0;        &#125;        .box &#123;            width: 700px;            height: 500px;            background-color: pink;            /* 给div设置定位 */            position: relative;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;span&gt;我是span元素&lt;/span&gt;        &lt;strong&gt;我是strong元素&lt;/strong&gt;        &lt;img src=&quot;./photo/OIP.jpg&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;div&gt;我是div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240427172357.png]]

在绝大多数情况下，子元素的绝对定位都是相对于父元素进行定位
如果希望子元素相对于父元素进行定位，又不希望父元素脱标，常用解决方案：
父元素设置position:relative（让父元素成为定位元素，而且父元素不脱离标准流）
子元素设置position:absolute
简称：子绝父相



将position设置为absolute&#x2F;fixed元素的特点（一）
可以随意设置宽度、高度
高度默认由内容决定
不再受标准流的约束
不再严格按照从上到下、从左到右排布
不再严格区分块级、行内级，行内块级的很多特性都会消失


不再给父元素汇报宽高数据

将position设置为absolute&#x2F;fixed元素的特点（二）
绝对定位元素
position值为absolute&#x2F;fixed的元素


对于绝对定位元素来说
定位参照对象的宽度 &#x3D; left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度
定位参照对象的高度 &#x3D; top + bottom + margin-top + margin-bottom + 绝对定位元素的实际占用高度


如果希望绝对定位元素的宽高和定位参照对象一样，可以给绝对定位元素设置以下属性
left：0、right：0、top：0、bottom：0、margin：0


如果希望绝对定位元素在定位参照对象中居中显示，可以给绝对定位元素设置以下属性
left：0、right：0、top：0、bottom：0、margin：auto
另外，还得设置具体的宽高值（小于定位参照对象的宽高）



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box &#123;            height: 500px;            width: 800px;            background-color: pink;            position: relative;        &#125;        /* 设置居中显示，且不存在兼容性问题*/        /* 上下偏移量相等，左右偏移量相等，margin设置为auto会使剩余空间平均分配到左右两侧和上下两侧 */        .containter &#123;            height: 200px;            width: 200px;            background-color: #d8afaf;            position: absolute;            left: 0;            right: 0;            top: 0;            bottom: 0;            margin: auto;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div class=&quot;containter&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240428170130.png]]
练习：
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        /* 去除链接原有样式 */        a &#123;            text-decoration: none;            color: black;        &#125;        .item &#123;            width: 140px;            margin: 0 auto;        &#125;        /* 设置为定位元素 */        .item .top &#123;            position: relative;        &#125;        .item .top img&#123;            /* 去除图片下面多出来的区域 */            display: block;        &#125;        /* 添加背景覆盖图片 */        .item .top .cover &#123;            position: absolute;            top: 0;            bottom: 0;            left: 0;            right: 0;            background-image: url(./photo/coverall.png);            background-position: 0 0;        &#125;        .item .top .info &#123;            position: absolute;            left: 0;            right: 0;            bottom: 0;            height: 27px;            line-height: 27px;            padding-left: 10px;            font-size: 12px;            color: #ccc;            background-image: url(./photo/coverall.png);            background-position: 0 -537px;        &#125;        .item .top .info .icon &#123;            position: relative;            top: 1px;            display: inline-block;            width: 14px;            height: 11px;            /* 设置间距 */            margin-right: 4px;            background-image: url(./photo/iconall.png);            background-position: 0 -24px;        &#125;        .item .bottom &#123;            display: block;            margin-top: 8px;            font-size: 14px;        &#125;        .item .bottom:hover &#123;            text-decoration: underline;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;item&quot;&gt;        &lt;div class=&quot;top&quot;&gt;            &lt;img src=&quot;./photo/wy.01.jpg&quot; alt=&quot;&quot;&gt;            &lt;a class=&quot;cover&quot; href=&quot;#&quot;&gt;&lt;/a&gt;            &lt;div class=&quot;info&quot;&gt;                &lt;i class=&quot;icon&quot;&gt;&lt;/i&gt;                &lt;span class=&quot;count&quot;&gt;4999万&lt;/span&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;a class=&quot;bottom&quot; href=&quot;#&quot;&gt;            无前奏 | 欧美女声 | 三秒爱上        &lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240428190122.png]]
left…….属性和margin-left……的区别
定位属性 vs 外边距属性：

left、right、top、bottom是用于定位元素的属性，通常与position属性（如relative、absolute、fixed）一起使用。
margin-left、margin-right、margin-top、margin-bottom是用于设置元素的外边距的属性。


控制位置 vs 控制间距：

left、right、top、bottom属性用于控制元素相对于其包含块的位置，分别表示元素的左、右、上、下偏移量。
margin-left、margin-right、margin-top、margin-bottom属性用于控制元素与其相邻元素之间的间距，分别表示元素的左、右、上、下外边距的大小。


值的类型：

left、right、top、bottom属性可以使用具体的长度值（如像素、百分比）或关键字（如auto）来指定偏移量。
margin-left、margin-right、margin-top、margin-bottom属性也可以使用具体的长度值或关键字。


应用方式：

left、right、top、bottom属性通常用于定位元素的具体位置，例如将元素相对于包含块的左上角或右下角进行定位。
margin-left、margin-right、margin-top、margin-bottom属性主要用于控制元素与其相邻元素之间的间距，例如设置元素与其相邻元素的水平或垂直间距。



需要注意的是:left、right、top、bottom属性通常与position属性一起使用，而margin-left、margin-right、margin-top、margin-bottom属性可以在任何情况下使用。另外，定位属性（如relative、absolute、fixed）会影响left、right、top、bottom属性的行为，而外边距属性不受定位属性的影响。
width：autoauto是什么：交由浏览器处理，自动调整

行内非替换元素 -&gt; width: 包裹内容
块级元素 -&gt; width: 包含块的宽度
绝对定位元素 -&gt; width: 包裹内容

粘性定位-sticky
可以看做是相对定位和绝对定位的结合体
它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点
当达到阈值点时，就会变成绝对定位
sticky是相对于最近的包含滚动视口的滚动祖先

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box &#123;            height: 300px;            width: 500px;            margin: 100px auto 0;            /* 元素内容溢出时，显示滚条 */            overflow: scroll;        &#125;        .nav &#123;            position: sticky;            background-color: pink;            /* 距离上方0的时候变成绝对定位 */            top: 0;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;h1&gt;我是标题&lt;/h1&gt;        &lt;div class=&quot;nav&quot;&gt;            &lt;span&gt;电脑&lt;/span&gt;            &lt;span&gt;手机&lt;/span&gt;            &lt;span&gt;衣服&lt;/span&gt;            &lt;span&gt;鞋子&lt;/span&gt;        &lt;/div&gt;        &lt;ul&gt;            &lt;li&gt;电脑列表1&lt;/li&gt;            &lt;li&gt;电脑列表2&lt;/li&gt;            &lt;li&gt;电脑列表3&lt;/li&gt;            &lt;li&gt;电脑列表4&lt;/li&gt;            &lt;li&gt;电脑列表5&lt;/li&gt;            &lt;li&gt;电脑列表6&lt;/li&gt;            &lt;li&gt;电脑列表7&lt;/li&gt;            &lt;li&gt;电脑列表8&lt;/li&gt;            &lt;li&gt;电脑列表9&lt;/li&gt;            &lt;li&gt;电脑列表10&lt;/li&gt;            &lt;li&gt;电脑列表11&lt;/li&gt;            &lt;li&gt;电脑列表12&lt;/li&gt;            &lt;li&gt;电脑列表13&lt;/li&gt;            &lt;li&gt;电脑列表14&lt;/li&gt;            &lt;li&gt;电脑列表15&lt;/li&gt;            &lt;li&gt;电脑列表16&lt;/li&gt;            &lt;li&gt;电脑列表17&lt;/li&gt;            &lt;li&gt;电脑列表18&lt;/li&gt;            &lt;li&gt;电脑列表19&lt;/li&gt;            &lt;li&gt;电脑列表20&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240430171525.png]]
CSS属性 - z - index
z-index属性用来设置定位元素的层叠顺序（仅对定位元素有效）
取值可以是正整数、负整数、0


比较原则
如果是兄弟关系
z-index越大，层叠在越上面
z-index相等，写在后面的那个元素层叠在上面


如果不是兄弟关系
各自从元素自己以及祖先元素中，找出最邻近的2个定位元素进行比较
而且这2个定位元素必须设置z-index的具体数值
父元素的 z-index 值会影响其子元素的堆叠顺序。如果父元素的 z-index 值较低，那么子元素即使具有较高的 z-index 值，也无法覆盖其他父元素的内容。





&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .item &#123;            height: 100px;            width: 100px;            position: fixed;        &#125;        .box1 &#123;            background-color: pink;            z-index: 1;        &#125;        .box2 &#123;            background-color: skyblue;            left: 20px;            top: 20px;        &#125;        .box3 &#123;            background-color: greenyellow;            left: 40px;            top: 40px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;        &lt;div class=&quot;item box1&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;item box2&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;item box3&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240430184648.png]]
CSS元素浮动认识浮动
float属性可以指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它
绝对定位、浮动都会让元素脱离标准流，以达到灵活布局的效果
可以通过float属性让元素产生浮动效果，float的常用取值
none：不浮动，默认值
left：向左浮动
right：向右浮动



浮动的规则
规则一
元素一旦浮动后，脱离标准流
朝着向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止
定位元素会层叠在浮动元素上面





![[Pasted image 20240430200108.png]]

规则二
如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块） 的左（右i）边界


规则三
浮动元素之间不能层叠
如果一个元素浮动，另一个元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素（左浮找左浮，右浮找右浮）
如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止




规则四
浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出（如行内级元素、inline-block元素、块级元素的文字内容）![[Pasted image 20240430200705.png]]


规则五
行内级元素、inline-block元素浮动后，其顶部将与所在行的顶部对齐可以利用将所有子元素向同一个方向浮动来解决子元素间的间隙问题



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .containter &#123;            width: 500px;            height: 300px;            background-color: pink;            margin: 100px auto;        &#125;        .box1 &#123;            background-color: skyblue;            float: left;        &#125;        .box2 &#123;            background-color: greenyellow;            float: right;        &#125;        .box3 &#123;            background-color: blanchedalmond;            float: left;        &#125;        .info &#123;            width: 300px;            height: 100px;            background-color: rgb(155, 202, 215);            margin: auto;        &#125;        .ht &#123;            width: 100px;            height: 50px;            background-color: brown;            float: left;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;containter&quot;&gt;        &lt;div class=&quot;item box1&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;item box2&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;item box3&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;info&quot;&gt;            &lt;div class=&quot;ht&quot;&gt;&lt;/div&gt;            我是div我是div我是div我是div我是div我是div我是div我是div我是div我是div        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240430201831.png]]
浮动的问题-高度塌陷
由于浮动元素脱离了标准流，变成了脱标元素，所以不再向父元素汇报高度
父元素计算总高度时，就不会计算浮动子元素的高度，导致高度塌陷的问题


解决父元素高度塌陷问题的过程，一般叫做**清浮动（清理浮动、清除浮动）
清浮动的目的是让*父元素计算总高度时，把浮动子元素的高度算进去
如何清除浮动？使用clear属性

CSS属性-clear
clear属性是做什么的？
clear属性可以指定一个元素是否必须移动（清除浮动后）到在它之前的浮动元素下面


clear的常用取值
left：要求元素的顶部低于之前生成的所有左浮动元素的底部
right：要求元素的顶部低于之前生成的所有右浮动元素的底部
both：要求元素的顶部低于之前生成的所有浮动元素的底部
none：默认值，无特殊要求



清理浮动的方法：给父元素添加after伪元素：
元素::after &#123;	content: &quot;&quot;;	clear: both;	display: block;	/*提高浏览器兼容性*/	visibility: hidden;	height: 0;&#125;元素 &#123;	*zoom: 1;/*IE6/7兼容性*/&#125;

CSS flex布局CSS Flexbox 布局指南 |CSS 技巧
认识flex布局
flexbox翻译为弹性盒子
弹性盒子是一种用于按行或按列布局元素的唯一布局方法
元素可以膨胀以填充额外的空间，收缩以适应更小的空间
通常我们使用flexbox来进行布局的方案称之为flex布局


flex布局是目前web开发中使用最多的布局方案
目前特别在移动端可以说已经完全普及
在pc端也几乎完全普及和使用，只有非常少数的网站依然在用浮动来布局



felx布局的重要概念
两个重要概念
开启了flex布局的元素叫flex containter
flex containter里面的直接子元素叫做flex item![[Pasted image 20240501213649.png]]


当flex containter中的子元素变成了flex item时，具备以下特点
flex item的布局将受flex containter属性的设置来进行控制和布局
flex item不再严格区分块级元素和行内级元素
flex item默认情况下是包裹内容的，但是可以设置宽度和高度


设置display属性为flex或者inline-flex可以成为flex containter
flex：flex containter以block-level形式存在
inline-flex：flex containter以inline-level形式存在



flex布局的模型![[Pasted image 20240501214659.png]]
flex相关的属性
应用在flex containter上的CSS属性
flex-flow
flex-direction
flex-wrap
justify-content
align-items
align-content


应用在flex items上的CSS属性
flex-grow
flex-basis
flex-shrink
order
align-self
flex



flex-containterflex-direction
flex items 默认都是沿着main axis（主轴）从main start开始往main end方向排布
flex-direction决定了main axis 的方向，有四个取值
row(默认值)、row-reverse、column、column-reverse![[Pasted image 20240501220522.png]]



flex-wrap
flex-wrap决定了flex containter是单行还是多行
nowrap(默认)：单行
wrap：多行
wrap-reverse：多行（对比wrap，cross start与cross end相反）![[Pasted image 20240501221341.png]]



flex-flow
flex-flow属性是flex-direction和flex-wrap的简写
任何顺序，并且都可以省略&lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt;



justify-content
justify-content决定了flex items在main axis上的对齐方式
flex-start(默认值)：与main start对齐
![[Pasted image 20240501223509.png]]
flex-end：与main end对齐
![[Pasted image 20240501223533.png]]
center：居中对齐
![[Pasted image 20240501223545.png]]
space-between：
flex items之间的距离相等
与main start、main end两端对齐


![[Pasted image 20240501223655.png]]
space-around：
flexitems之间的距离相等
flexitems与main start、main end之间的距离是flex items之间距离的一半


![[Pasted image 20240501223951.png]]
space-evenly：
flex items之间的距离相等
flex items与main start、main end之间的距离等于是flex items之间距离


![[Pasted image 20240501223923.png]]



align-items
align-items决定了flex items在cross axis上的对齐方式
normal：在弹性布局中，效果和stretch一样
stretch：当flex items在cross axis方向的size为auto时，会自动拉伸至填充flex containter
![[Pasted image 20240501225200.png]]
flex-start：与cross start对齐
![[Pasted image 20240501225312.png]]
flex-end：与cross end对齐
![[Pasted image 20240501225327.png]]
center：居中对齐
![[Pasted image 20240501225337.png]]
baseline：与基准线对齐
![[Pasted image 20240501225348.png]]



align-content
align-content决定了多行flex items在cross axis上的对齐方式，用法与justify-content类似
stretch（默认值）：与align-items的stretch类似
flex-start：与cross start对齐
![[Pasted image 20240501230258.png]]
flex-end：与cross end对齐
![[Pasted image 20240501230306.png]]
center：居中对齐
![[Pasted image 20240501230317.png]]
space-between：
flex items之间的距离相等
与cross start、cross end两端对齐


![[Pasted image 20240501230329.png]]
space-around：
flexitems之间的距离相等
flexitems与main start、main end之间的距离是flex items之间距离的一半


![[Pasted image 20240501230341.png]]
space-evenly：
flex items之间的距离相等
flex items与main start、main end之间的距离等于是flex items之间距离





flex-itemsorder
order决定了flex items的排布顺序
可以设置任意整数（正整数、负整数、0），值越小就越排在前面
默认值是0



align-self
flex items可以通过align-self覆盖flex containter设置的align-items
auto（默认值）：遵从flex containter的align-items设置
stretch、flex-start、flex-end、center、baseline，效果跟align-items一致



flex-grow
flex-grow决定了flex items如何扩展（拉伸、成长）
可以设置任意非负数字（正整数、正小数、0），默认值是0
当flex containter在main axis方向上有剩余size时，flex-grow属性才会有效


如果所有flex items的flex-grow总和sum超过1，每个flex item扩展的size为
flex containter的剩余size * flex-grow&#x2F;sum


flex items 扩展后的最终size不能超过max-width&#x2F;max-height

flex-shrink
flex-shrink决定了flex items如何收缩
可以设置任意非负数字（正整数、正小数、0），默认值是1
当flex items在main axis方向上超过了flex containter的size时，flex-shrink属性才会有效


如果所以flex items的flex-grow总和sum超过1，每个flex item收缩的size为
flex items超出flex containter的size * 收缩比例 &#x2F; 所有flex items的收缩比例之和


flex items 收缩后的最终size不能小于min-width&#x2F;min-height

flex-basis
flex-basis用来设置flex items在main axis方向上的basis size
auto（默认值）、具体的宽度数值


决定flex items最终base size的因素，从优先级高低
max-width \ max-height \ min-width \ min-height
flex-basis
width \ height
内容本身的size



flex
flex是flex-grow || flex-shrink || flex-basis的简写，flex属性可以指定1个、2个或3个值  none || [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]
单值语法：值必须是以下之一：
一个 &lt;flex-grow&gt; 的有效值：此时简写会扩展为 。flex: &lt;flex-grow&gt; 1 0
一个 &lt;flex-basis&gt; 的有效值：此时简写会扩展为 。flex: 1 1 &lt;flex-basis&gt;
关键字 或者全局关键字之一。none


双值语法：
第一个值必须是一个 flex-grow 的有效值。
第二个值必须是以下之一：
一个 flex-shrink 的有效值：此时简写会扩展为 。flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; 0
一个 flex-basis 的有效值：此时简写会扩展为 。flex: &lt;flex-grow&gt; 1 &lt;flex-basis&gt;




三值语法：值必须按照以下顺序指定：
一个 flex-grow 的有效值。
一个 flex-shrink 的有效值。
一个 flex-basis 的有效值。注意initial元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器。相当于将属性设置为””。flex: 0 1 auto



auto元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 “”.flex: 1 1 auto
none元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为””。flex: 0 0 auto
flex布局的常见问题如何解决如下布局的对齐问题？![[Pasted image 20240503172805.png]]解决办法：在子元素的最后添加几个空的span&#x2F;i元素，高度与其他子元素一致，添加的个数是列数-2
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .containter &#123;            width: 800px;            height: 600px;            background-color: pink;            margin: 0 auto;            display: flex;            flex-wrap: wrap;            justify-content: space-between;        &#125;        .item &#123;            width: 220px;            height: 150px;            background-color: rgb(79, 155, 200);        &#125;        i &#123;            width: 220px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;containter&quot;&gt;        &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;item item6&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;item item7&quot;&gt;7&lt;/div&gt;        &lt;div class=&quot;item item8&quot;&gt;8&lt;/div&gt;        &lt;div class=&quot;item item9&quot;&gt;9&lt;/div&gt;        &lt;div class=&quot;item item10&quot;&gt;10&lt;/div&gt;        &lt;div class=&quot;item item11&quot;&gt;11&lt;/div&gt;        &lt;!-- 添加span/i的个数是列数-2，并且宽度要和前面的div一致 --&gt;        &lt;i&gt;&lt;/i&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240503174704.png]]
布局方案总结![[Pasted image 20240501163839.png]]
额外补充知识03border图形border主要用来给盒子增加边框，但是在开发中我们也可以利用边框的特性来实现一些形状 
给一个盒子四周添加不同颜色的边框![[Pasted image 20240425192608.png]]
![[Pasted image 20240425192628.png]]
将border设置为盒子长宽的一半![[Pasted image 20240425192903.png]]
![[Pasted image 20240425192918.png]]将另外三边的颜色去除![[Pasted image 20240425193311.png]]
![[Pasted image 20240425193352.png]]
将这个盒子旋转![[Pasted image 20240425193858.png]]
![[Pasted image 20240425193914.png]]
Web网络字体Web fonts的工作原理
首先，我们需要通过一些渠道获取到希望使用的字体：

![[Pasted image 20240425194548.png]]

其次，在我们CSS代码中使用该字体：
最后，在部署静态资源时，将HTML&#x2F;CSS&#x2F;JavaScript&#x2F;Font一起部署在静态服务器中
用户角度：  1. 浏览一个网页时，因为代码中有引入字体文件，字体文件会被一起下载下来  2. 浏览器会根据使用的字体在下载的字体文件中查找、解析、使用对应的字体  3. 在浏览器中使用对应的字体显示内容

使用Web Fonts
第一步： 在字体天下网站下载一个字体（实际开发中由产品部提供）
字体天下-提供各类字体的免费下载和在线预览服务 (fonts.net.cn)
默认下载下来的是ttf文件


第二步： 使用字体
使用过程如下：
1、将字体放到对应的目录中
2、通过@font-face来引入字体，并且设置格式
3、使用字体


注意：@font-face 用于加载一个自定义的字体

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        /* 将这个字体引入到网页中 */       @font-face &#123;            font-family: &quot;why&quot;; /* 给这个字体起一个名字，方便接下来引用 */            src: url(&quot;./fonts/YeZiGongChangTangYingHei-2.ttf&quot;);       &#125;       .box &#123;        font-family: &quot;why&quot;;       &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;我是div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240425212330.png]]
Web Fonts的兼容性
我们刚才使用的字体文件是 .ttf, 他是True Type字体。
在开发中某些浏览器可能不支持该字体，所以为了浏览器的兼容性问题，我们需要有对应其他格式的字体；


True Type字体：拓展名是 .ttf
OpenType&#x2F;TrueType字体：拓展名是 .ttf、.otf, 建立在TrueType字体之上
Embedded OpenType字体：拓展名是 .eot, OpenType字体的压缩版
SVG字体：拓展名是 .svg、.svgz
WOFF表示Web Open Font Format web开放字体：拓展名是 .woff, 建立在True Type字体之上



![[Pasted image 20240425213333.png]]

如果我们要具备很强的兼容性，那么可以如下格式编写：

@font-face &#123;            font-family: &quot;why&quot;; /* 给这个字体起一个名字，方便接下来引用 */            src: url(&quot;./fonts/YeZiGongChangTangYingHei-2.eot&quot;);            src: url(&quot;./fonts/YeZiGongChangTangYingHei-2.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;),            url(&quot;./fonts/YeZiGongChangTangYingHei-2.woff&quot;) format(&quot;woff&quot;),            url(&quot;./fonts/YeZiGongChangTangYingHei-2.ttf&quot;) format(&quot;truetype&quot;),            url(&quot;./fonts/YeZiGongChangTangYingHei-2.svg#uxfonteditor&quot;) format(&quot;svg&quot;);            font-style: normal;            font-weight: normal;       &#125;


这被称为刀枪不入的 @font-face语法：是Paul Irish早期的一篇文章提及后开始流行起来
src用于指定字体资源
url指定资源的路径
format用于帮助浏览器快速识别字体的格式



Web 字体图标认识字体图标
什么是字体图标：把字体直接设计成图标的样子就叫做字体图标
字体图标的好处：
放大不会失真
可以任意切换颜色
用到很多个图标时，文件相对图片较小


字体图标的使用：
登录阿里icons（iconfont-阿里巴巴矢量图标库）
下载代码，并且拷贝到项目中


将字体文件和默认的CSS文件导入到项目中

字体图标的使用
字体图标的使用步骤：
第一步：通过link引入iconfont.css文件
第二步：使用字体图标


使用字体图标常见的两种方式：
方式一：通过对应字体图标的Unicode来显示代码
方式二：利用已经编写好的class，直接使用![[Pasted image 20240426164410.png]]第一种方式：



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        @font-face &#123;            font-family: &quot;iconfont&quot;;            src: url(./fonts01/iconfont.ttf);        &#125;        .iconfont &#123;            font-family: &quot;iconfont&quot;;            font-size: 100px;        &#125;        .music::before &#123;            content: &quot;\e617&quot;;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 直接通过内容（字符实体）展示 --&gt;    &lt;span class=&quot;iconfont&quot;&gt;&amp;#xe66a;&lt;/span&gt;    &lt;!-- 不使用字符实体的方式展示（伪元素）出来 --&gt;    &lt;span class=&quot;iconfont music&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240426162331.png]]第二种方式：使用iconfont配置的CSS：将 .ttf文件和 .css文件一起拖到项目里
![[Pasted image 20240426163726.png]]
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./fonts01/iconfont.css&quot;&gt;    &lt;style&gt;        .icon &#123;            font-size: 30px;            color: pink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;i class=&quot;iconfont icon-dashuju icon&quot;&gt;&lt;/i&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240426163746.png]]
CSS精灵图标 CSS Sprite认识精灵图
什么是CSS Sprite
是一种CSS图像合成技术，将各种小图片合并到一张图上，然后利用CSS的背景定位来显示对应的图片部分
有人翻译为：CSS雪碧、CSS精灵


使用CSS Sprite的好处
减少网页的http请求数量，加快网页响应速度，减轻服务器压力
减少图片总大小
解决了图片命名问题，只需要针对一张集合的图片命名


Sprite图片制作
方法一：Photoshop，设计人员提供
方法二： https://www.toptal.com/developers/css/sprite-generator



精灵图的使用
精灵图的原理：通过只显示图片的很小的一部分来展示
通常使用背景：
设置对应元素的宽度和高度
设置精灵图作为背景图片
调整背景图片的位置来展示


如何获取精灵图的位置
http://www.spritecow.com/



![[Pasted image 20240426172126.png]]
![[Pasted image 20240426172243.png]]
cursor属性
cursor可以设置鼠标指针（光标）在元素上面时的显示样式
cursor常见的设值有：
auto：浏览器根据上下文决定指针的显示样式，比如根据文本和非文本切换指针样式
default：由操作系统决定，一般就是一个小箭头
pointer：一只小手，鼠标挪动到链接上面默认就是这个样式
text：一条竖线，鼠标指针挪动到文本输入框上面默认就是这个样式
none：没有任何指针显示在元素上面



04CSS属性-transform
CSS transform属性允许对某一个元素进行某些形变，包括旋转，缩放，倾斜或平移等
通常行内级元素不能进行形变
对于行内非替换元素是无效的，比如span、a元素等



用法
transform属性的语法如下：![[Pasted image 20240508141635.png]]
常见的函数transform function有：
平移：translate(x, y)
缩放：scale(x, y)
旋转：rotate(deg)
倾斜：skew(deg, deg)



位移-translate
平移： translate(x, y)：这个函数用于移动元素在平面上的位置
值个数
一个值时，设置x轴上的位移
两个值时，设置x轴和y轴上的位移


值类型
数字：100px
百分比：参照物本身


translate函数是translateX()和translateY()的缩写

缩放-scale
缩放：scale(x, y)：这个函数可改变元素的大小
值个数
一个值时，设置x轴上的缩放
两个值时，设置x轴和y轴上的缩放


值类型
数字：
1：保持不变

1：放大


&lt;1：缩小


百分比：不常用


scale函数是scaleX()和scaleY()的缩写

旋转-rotate
旋转：rotate（angel)：这个函数可以让元素进行旋转
值类型：
常用单位deg：旋转的角度
正数为顺时针
负数为逆时针
transform: rotate(90deg)


rotate函数是rotateZ函数的简写写法
rotate的其他单位
度（degrees)、百分度(gradians)、弧度(radians)、圈数(turns)



倾斜-skew
倾斜：skew(x, y)：这个函数定义了一个元素在二维平面上的倾斜转换
值个数
一个值时，表示x轴上的倾斜
两个值时，表示x轴和y轴上的倾斜


值类型
deg: 旋转的角度
正数为顺时针
负数为逆时针



transform设置多个值
我们可以给transform设置多个形变的函数
![[Pasted image 20240508203909.png]]
“+”代表可以设置一个或多个值，多个值之间以空格隔开
“#”代表可以设置一个或多个值，多个值之间以“,”隔开

CSS属性：transform-origin
transform-origin：形变的原点
一个值：
设置x轴的原点


两个值：
设置x轴和y轴的原点


必须是&lt;length&gt;, &lt;percentage&gt;, 或left, right, top, bottom关键字中的一个
left、center、right、top、bottom关键字
length：从左上角开始计算
百分比：参考元素本身大小



元素水平居中和垂直居中的方案水平居中
行内级元素：
设置父元素的text-align：center


块级元素：
设置当前块级元素（需要有固定宽度）margin：0 auto


绝对定位：
元素有宽度情况下，left0+right0+margin: 0 auto


flex:
justify-content: center



垂直居中
绝对定位
元素有高度的情况下，top0+bottom0+margin: auto 0
弊端：
必须使用定位（脱离标准流）
必须给元素设置高度




flex布局
align-items：center
弊端：
当前flex布局中所有元素都会垂直居中




top+translate
先让元素向下移动父元素的50%
&#96;position：relative
top：50%  -注意：这里不能用margin-top：50%，margin-top的百分比是相对于父元素的宽度，而非高度


再让元素向上移动自身的50%
transform: translate(0, -50%)





transition动画认识transition动画
什么是transition动画？
CSS transition提供了一种在更改css属性时控制动画速度的方法
可以让css属性变化成为一个持续一段时间的过程，而不是立即生效的


通常将两个状态之间的过渡称为隐式过渡
CSS transition可以决定
哪些属性发生动画效果
何时开始（设置delay）
持续多久（设置duration）
如何动画（定义timing function，如匀速地或先快后慢）



可以做动画的CSS属性
方法一：在MDN可执行动画的CSS属性中查询
方法二：阅读CSS属性的文档说明 ![[Pasted image 20240508195925.png]]

过渡动画-transition
transition CSS属性是transition-property，transition-duration，transition-timing-function和transition-delay的一个简写属性
transition-property：指定应用过渡性的名称
all：所有属性都执行动画
none：所以属性都不执行动画
CSS属性名称：要执行动画的CSS属性名称，比如width、left、transform等


transition-duration：指定动画所需的时间
单位可以是秒(s)或毫秒（ms)


transition-timing-function：指定动画的变化曲线
transition-timing-function - CSS：层叠样式表 |MDN的 (mozilla.org)


transition-delay：指定过渡动画执行之前的等待时间
缺点：
只能定义开始状态和结束状态，不能定义中间状态
不能重复执行，除非一再触发动画
需要在特定状态下触发才能执行，比如某个属性被修改了



Animation动画认识Animation动画
CSS Animation的使用分成两个步骤
步骤一：使用@keyframes定义动画序列（每一帧动画如何执行）
步骤二：配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等



@Keyframes规则
可以使用 @Keyframes来定义多个变化状态，并且使用animation-name来声名匹配
关键帧使用percentage来指定动画发生的时间点
0% 表示动画的第一时刻，100% 表示动画的最终时刻
第一时刻和最终时刻还有特殊的别名：from和to基本语法如下：@Keyframes 名称 &#123;  0% &#123;  transform: translate(0, 0) scale(0.5, 0.5)  &#125;  50% &#123;  transform: translate(0, 200px) scale(1.2, 1.2)  &#125;  100% &#123;  transform: translate(400px, 0) scale(0.5, 0.5)  &#125;&#125;



animation属性
CSS animation 属性是animation-name，animation-duration，animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode和animation-play-style属性的一个简写属性形式
animation-name：指定执行哪一个关键帧动画
animation-duration：指定动画的持续时间
animation-timing-function：指定动画的变化曲线
animation-delay：指定延迟执行的时间
animation-iteration-count：指定动画执行的次数，执行infinite表示无限动画
animation-direction：指定方向，常用值normal和reverse
animation-fill-mode：执行动画最后保留哪一个值
none：回到没有执行动画的位置
forwards：动画最后一帧的位置
backwards：动画第一帧的位置


animation-play-state：指定动画运行或者暂停（在JS中使用，用于暂停动画）

vertical-align深入理解vertical-align-line box
vertical-align会影响行内块级元素在一个行盒中垂直方向的位置
当一个div没有设置高度的时候：
没有内容，没有高度
有内容，内容撑起来高度


内容撑起来高度的本质
内容有行高（line-height），撑起来了div的高度


行高为什么可以撑起来div的高度
这是因为line boxes的存在，并且line-boxes有一个特性，包裹每行的inline level
而其中的文字是有行高的，必须将整个行高包裹进去，才算包裹这个line-level不同情况分析


只有文字时![[Pasted image 20240508220221.png]]
有图片，有文字时![[Pasted image 20240508220246.png]]
有图片，有文字，有inline-block（比图片要大）![[Pasted image 20240508220432.png]]
有图片，有文字，有inline-block而且设置了margin-bottom![[Pasted image 20240508220529.png]]
有图片，有文字，有inline-block而且设置了margin-bottom并且有文字（当一个inline-box中有文本时，它的基线不再是底部，基线变成最后一行文本的基线）![[Pasted image 20240508220608.png]]

vertical-align的baseline
结论：line-boxes一定会想办法包裹住当前行中所有的内容
vertical-align的默认值是baseline
baseline都是哪些
文本的baseline是字母x的下方
line-block默认的baseline是margin-bottom的底部（如果没有，就是盒子的底部）
inline-block有文本时，baseline是最后一行文本的x的下方



vertical-align的其他值
不同的取值
baseline（默认值）：基线对齐
top： 把行内级盒子的顶部跟line boxes顶部对齐
middle：行内级盒子的中心点与父盒基线加上x-height一半的线对齐(不建议用来做图片的居中)
bottom：把行内级盒子的底部跟line boxes底部对齐
percentage：把行内级盒子提升或者下降一段距离（距离相对于line-height计算\元素高度），0%意味着同baseline一样
length：把行内级盒子提升或者下降一段距离，0cm意味着同baseline一样


解决图片下边缘的间隙方法
方法一：设置成top&#x2F;middle&#x2F;bottom
方法二：将图片设置为block元素



05CSS属性：white-space
white-space用于设置空白处理和换行规则
normal：合并所有连续的空白，允许单词超屏时自动换行
nowrap：合并所有连续的空白，不允许单词超屏时自动换行
pre：阻止合并所有连续的空白，不允许单词超屏时自动换行
pre-wrap：阻止合并所有连续的空白，允许单词超屏时自动换行
pre-line：合并所有连续的空白（但保留换行），允许单词超屏时自动换行



CSS属性：text-overflow
text-overflow通常用来设置文字溢出时的行为
cilp：溢出的内容直接裁剪掉（字符可能会显示不完整）
ellipsis：溢出那行的结尾处用省略号表示



CSS中的函数
CSS函数通常可以帮助我们更加灵活的来编写样式的值
几个好用的CSS函数
var：使用CSS定义的变量
calc：计算CSS值，通常用于计算元素的大小或位置
blur：毛玻璃（高斯模糊）效果
gradient：颜色渐变函数



CSS函数 - var
CSS中可以自定义属性
属性名需要以两个减号（–） 开始
属性值则可以是任何有效的CSS值



div &#123;	--why-color: red;&#125;

我们可以通过var函数来使用

span &#123;color: var(--why-color);&#125;

规则集定义的选择器，是自定义属性的可见作用域（只在选择器内部有效）
推荐将自定义属性定义在html中，也可以使用 :root选择器



CSS函数 - calc
cala()函数允许在声明CSS属性值时执行一些计算
计算支持加减乘除的运算：+ 和 -运算符的两边必须要有空白字符
通常用来设置一些元素的尺寸或者位置



.box.containter&#123;	display: inline-block;	/* width的百分比相对于包含块（通常是父元素） */	width: calc(100% - 60px);	height: 100px;	background-color: pink;&#125;
CSS函数 - blur
blur()函数将高斯模糊应用于输出图片或者元素
blur(radius)
radius，模糊的半径，用于定义高斯函数的偏差值，偏差值越大，图片越模糊


通常会和两个属性一起使用：
filter：将模糊或颜色偏移等图形效果应用于元素；



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    img &#123;      filter: blur(5px);    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;img src=&quot;../pct/pic.jpeg&quot; alt=&quot;&quot;&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240513151105.png]]

backdrop-filter：为元素后面的区域添加模糊或者其他效果

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    .box &#123;      display: inline-block;      position: relative;    &#125;    .cover &#123;      position: absolute;      top: 0;      bottom: 0;      right: 0;      left: 0;      background-color: rgba(0, 0, 0, .5);      backdrop-filter: blur(5px);    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;img src=&quot;../pct/pic.jpeg&quot; alt=&quot;&quot;&gt;    &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

![[Pasted image 20240513151848.png]]
CSS函数 - gradient
&lt;gradient&gt;是一种 &lt;image&gt;CSS数据类型的子类型，用于表现 两种或多种颜色的过渡转变
CSS的 &lt;image&gt;数据类型描述的是2D图形
比如background-image、list-style-image、border-image、content等
&lt;image&gt;常见的方式是 通过url来引入一个图片资源
它也可以通过CSS的&lt;gradient&gt;函数来设置颜色的渐变


&lt;gradient&gt;常见的函数实现
linear-gradient()：创建一个表示两种或多种颜色线性渐变的图片
radial-gradient()：创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成
repeating-linear-gradient()：创建一个由重复线性渐变组成的&lt;image&gt;
repeating-radial-gradient()：创建一个重复的原点触发渐变组成的&lt;image&gt;



linear-gradient的使用
linear-gradient：创建一个表示两种或多种颜色线性渐变的图片![[Pasted image 20240513154320.png]]
radial-gradient：创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成![[Pasted image 20240513154427.png]]

浏览器前缀
有时候会看到有些CSS属性名前面带有：-o-、-xv-、-ms-、-mso-、-webkit-![[Pasted image 20240513213207.png]]
为什么需要浏览器前缀
CSS属性刚开始并没有成为标准，浏览器为了防止后续会修改名字给新的属性添加了浏览器前缀


浏览器私有前缀，只有对应的浏览器才能解析使用
-o-、-xv-：Opera等
-ms-、-mso-：IE等
-moz-：Firefox等
-webkit-：Safari、Chrome等



FC-Formatting Context
元素在标准流里面都是属于一个FC的
块级元素的布局属于Block Formatting Context（BFC）
行内级元素的布局属于Inline Formatting Context（IFC）

BFC-Block Formatting Context![[Pasted image 20240513221209.png]]
作用概述如下：

在BFC中，box会在垂直方向上一个挨着一个排布
垂直方向的间距由margin属性决定
在同一个BFC中，相邻两个box之间的margin会折叠
在BFC中，每个元素的左边缘是紧挨着包含块的左边缘的作用：
解决margin的折叠问题
解决浮动高度塌陷问题

BFC的作用二：解决浮动高度塌陷
BFC解决高度塌陷需要满足两个条件
浮动元素的父元素触发BFC，形成独立的块级格式化上下文
浮动元素的父元素的高度是auto的


BFC的高度是auto的情况下，如下方法计算高度
如果只有inline-level，是行高的顶部和底部的距离
如果有block-level，是由最底层的块上边缘和最底层块盒子的下边缘之间的距离
如果有绝对定位元素，将被忽略
如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘



媒体查询
媒体查询是一种提供给开发者针对不同需求进行定制化开发的一个接口
可以根据设备的类型（比如屏幕设备、打印机设备）或者特定的特性（如屏幕的宽度）来修改页面
媒体查询的使用方式
一：通过 @media和@import使用不同的CSS规则![[Pasted image 20240513225836.png]]
二：使用 media属性为&lt;style&gt;、 &lt;link&gt;、 &lt;source&gt;和其他html元素指定的媒体类型![[Pasted image 20240513225905.png]]
三：使用Windows.matchMedia()和MediaQuerylist.addListener()方法来测试和监控媒体状态


比较常用的是通过@media来使用不同的CSS规则，目前掌握这个即可

媒体类型
在使用媒体查询时，你必须指定要使用的媒体类型
不选则是应用all类型


常见的媒体类型值如下
all：适用于所有设备
print：适用于在打印预览模式下在屏幕上查看的分页材料和文档
screen：主要用于屏幕
speech：主要用于语音合成器



媒体特性
媒体特性描述了浏览器、输出设备，或是预览环境的具体特征
通常会将媒体特性描述为一个表达式
每条媒体特性表达式都必须用括号括起来![[Pasted image 20240513231454.png]]



逻辑操作符
媒体查询的表达式最终会获得一个Boolean值，真或者假
结果为真，则生效
结果为假，不会生效


如果有多个条件，可以通过逻辑操作符联合复杂的媒体查询
and：and操作符用于将多个媒体查询规则组合成单条媒体查询
not：not运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false
only：only运算符仅在整个查询匹配时才用于应用样式
，(逗号)：![[Pasted image 20240513232247.png]]



]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端三件套</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript上</title>
    <url>/posts/2025/04/Fronted/%E4%B8%89%E4%BB%B6%E5%A5%97/03-%20JavaScript%E5%9F%BA%E7%A1%80/c041c21b.html</url>
    <content><![CDATA[认识JavaScript定义：

JavaScript是一种高级的、解释型的编程语言 
JavaScript是一门基于原型、头等函数的语言，是一门多范式的语言，它支持面向对象程序设计，指令式编程，以及函数式编程

JavaScript的组成JavaScript的组成包括ECMAScript、DOM、BOM

ECMAScript：定义语言规范
DOM：用于操作文档的API
BOM：用于操作浏览器的API

JavaScript的基本语法JavaScript编写方式
第一种：HTML代码行内（不推荐）

&lt;!-- 第一种：HTML代码行内 --&gt;  &lt;a href=&quot;javascript:alert(&#x27;百度一下&#x27;)&quot;&gt;百度一下&lt;/a&gt;  &lt;a href=&quot;#&quot; onclick=&quot;alert(&#x27;百度一下&#x27;)&quot;&gt;百度一下&lt;/a&gt;

第二种：script标签中

&lt;!-- 第二种：script标签中 --&gt;  &lt;a href=&quot;#&quot; class=&quot;google&quot;&gt;google一下&lt;/a&gt;  &lt;script&gt;    const googleEl = document.querySelector(&quot;.google&quot;)    googleEl.onclick = function() &#123;      alert(&quot;google一下&quot;)    &#125;  &lt;/script&gt;

第三种：外部的文件
需要通过script元素的scr属性来引入JavaScript文件



&lt;!-- 第三种：外部的script文件 --&gt;  &lt;a href=&quot;#&quot; class=&quot;bing&quot;&gt;bing一下&lt;/a&gt;  &lt;script src=&quot;./JS/01_编写.js&quot;&gt;&lt;/script&gt;

const bingEl = document.querySelector(&quot;.bing&quot;)    bingEl.onclick = function() &#123;      alert(&quot;bing一下&quot;)&#125;
noscript元素如果运行的浏览器不支持JavaScript，我们使用&lt;noscript&gt;元素来给用户更好的提示

浏览器显示包含在&lt;noscript&gt;中内容的情况：
浏览器不支持脚本
浏览器对脚本的支持被关闭



&lt;body&gt;	&lt;noscript&gt;		&lt;p&gt;您的浏览器不支持JavaScript&lt;p&gt;	&lt;noscript&gt;&lt;body&gt;
Javscript 的编写注意事项
注意一：script元素是双标签元素，不能写成单标签
在外联式引用js文件时，script标签中不可以写JavaScript代码，而且script标签不能写成单标签


注意二：省略type属性
注意三：加载顺序
JavaScript默认遵循HTML文档的加载顺序，即自上而下的加载顺序
推荐将JavaScript代码和编写位置放在body子元素的最后一行


JavaScript代码严格区分大小写

JavaScript语句和分号
编写的每一行代码都是一个语句
通常每条语句的后面会添加一个分号，表示语句的结束
存在换行符时，大多数情况下可以省略分号，JavaScript将换行符理解成“隐式”的分号，也被称之为 自动插入分号



JavaScript的注释
JavaScript的注释主要分为三种
单行注释
多行注释
文档注释（VScode中需要再单独的js文件中编写才有效）![[Pasted image 20240515133954.png]]![[Pasted image 20240515134002.png]]注意：不支持注释的嵌套



JavaScript变量和数据类型变量的命名格式
在JavaScript中命名一个变量包含两部分
变量的声明：使用var关键字在JavaScript中声明一个变量
变量的赋值：使用 &#x3D; 给变量进行赋值![[Pasted image 20240515143237.png]]![[Pasted image 20240515143305.png]]![[Pasted image 20240515143315.png]]



变量的命名规范
变量命名规则
第一个字符必须是*一个字母、下划线(_)或一个美元符号($)
不能使用关键字和保留字命名
变量严格区分大小写


变量命名规范
多个单词使用驼峰标记（小驼峰：userName,大驼峰：UserName）
赋值 &#x3D; 两边加上一个空格
变量应该见名知意



变量的注意事项
一：如果一个变量未声明就直接使用，会报错
二：如果一个变量有声明，但是没有赋值，那么默认值是undefined
三：如果没有使用var声明变量也可以，但是不推荐（实际会被添加到Windows对象上）

JavaScript的数据类型
JavaScript中的值都有特定的类型
可以将 值赋值给一个变量，那么这个变量就具备了特定的类型
一个变量可以在前一刻是字符串，下一刻是数字


8种基本数据类型
**Number
**String
**Boolean
**Undefined
**Null
**Object
Biglnt
Symbol



Number类型
Number类型代表整数和浮点数
Number有很多操作符，如 乘法*、除法&#x2F;、加法+、减法-等等
特殊数值
infinity：代表无穷大
NaN：代表计算错误，如字符串和一个数字相乘


其他进制表示方法：![[Pasted image 20240515194724.png]]
数字表示的范围：
最小数：Number.MIN_VALUE，这个值为：5e-324，小于这个的数字会被转化为0
最大数：Number.MAX_VALUE，这个值为1.7976931348623157e+308
最小整数：Number.MIN_SAFE_INTEGER，这个值为 -(2^53 - 1)
最大整数：Number.MAX_SAFE_INTEGER，这个值为 (2^53 - 1)


isNaN
用于判断是否是一个数字，是数字返回true，不是数字返回false


实例方法：
toString(base)：将数字转成字符串，并且按照base进制进行转化
base的范围从2-36，默认情况是10
注意：如果是直接对一个数字操作，需要使用 .. 运算符


toFixed(digits)：格式化一个数字（格式化后生成String类型），保留digits位的小数
digits的范围是0-20





var num = 123console.log(num.toString(2)) //1111011console.log(123..toString(2)) //1111011

类方法：
Number.parseInt(string[,radix])：将字符串解析成整数
Number.parseFloat(string)：将字符串解析成浮点数



var num = &quot;123.321&quot;console.log(Number.parseInt(num)) //123console.log(Number.parseFloat(num)) //123.321
String类型
JavaScript中的字符串必须被括在引号里
双引号：”hello” 
单引号：’hello’
反引号：hello(ES6之后学)![[Pasted image 20240515195916.png]]


前后引号类型必须一致
如果字符串里面本身包括单引号，可以使用双引号
如果字符串里面本身包括双引号，可以使用单引号


转义字符：
有一些特殊功能的字符可以通过转义字符的形式放入字符串中![[Pasted image 20240515200147.png]]


字符串的几个基本使用操作：
字符串拼接，通过+运算符![[Pasted image 20240515200348.png]]
获取字符串长度![[Pasted image 20240515200411.png]]


访问字符串的字符
方法一：通过字符串的索引 str[0]
方法二：通过str.charAt(pos)
区别：方法一没有找到会返回undefined，charAt没找到会返回空字符串


字符串的遍历
方法一：普通for循环
方法二：for .. of遍历(只有字符串和数组能这样遍历)



var ms = &quot;Hello World&quot;for (var i = 0; i &lt; ms.length; i++) &#123;	console.log(ms[i])&#125;for (var char of ms) &#123;	console.log(char)&#125;

修改字符串
toLowerCase：将所有的字符转成小写
toUpperCase：将所有的字符转成大写



var ms = &quot;Hello World&quot;var ms1 = ms.toLowerCase() //hello worldvar ms2 = ms.toUpperCase() // HELLO WORLDconsole.log(ms, ms1, ms2)

查找字符串
方法一：**查找字符串的位置：str.indexOf(searchValue [, fromIndex])
从fromIndex开始，查找searchValue的索引
没有找到返回-1，找到返回单词第一个字母的索引
lastIndexOf，从最后开始查找


方法二：**是否包含字符串：str.includes(searchString [, position])
从position位置开始查找searchString，返回true或false
ES6新增的方法


方法三：**以xxx开头：str.startWith(searchString [, position])
从position位置开始，判断字符串是否以searchString开头
ES6新增


方法四：**以xxx结尾：str.endWith(searchString [, length])
在length长度内，判断字符串是否以searchString结尾


方法五：**替换字符串：str.replace(regexp|substr, newSubStr|function)
查找到对应的字符串，并且使用新的字符串进行替代
也可以传入一个正则表达式来查找，也可以传入一个函数来替换




获取子字符串![[Pasted image 20240520155559.png]]
拼接字符串：**str.concat(str2, [, …strN])
删除首尾空格：**str.trim()
字符串分割：**str.split([separator[, limit]])
separator：以什么字符串进行分割，也可以是一个正则表达式
limit：限制返回片段的数量查看文档： String - JavaScript | MDN (mozilla.org)



Boolean类型
Boolean类型用于表示真假
仅包含两个值：true和false

Undefined类型
Undefined类型只有一个值，就是特殊值undefined
如果声明一个变量没有对其进行初始化，则默认值就是Undefined


两个注意事项
最好在定义变量的时候进行初始化
不要将一个变量赋值为undefined
如果变量刚开始什么都没有，我们可以初始化为0、空字符串、null等值





Object类型
Object往往可以表示一组数据，是其他数据的一个集合
在JavaScript中可以使用花括号{}的方式来表示一个对象![[Pasted image 20240515203651.png]]

Null类型
Null类型通常用来表示一个对象为空，常常在给一个对象进行初始化时，会赋值为null

数据类型的转换字符串string的转换
方式一：隐式转换
一个字符串和其他类型进行+操作
如果+运算符左右两边有一个是字符串，那么另一边会自动转换成字符串类型进行拼接


某些函数的执行也会自动将参数转为字符串类型，比如consloe.log函数


方式二：显示转换
调用String()函数
调用toString()方法



Number的转换
方式一：隐式转换
在算术运算中，通常会将其他类型转换成数字类型来进行运算
比如 ”6“ &#x2F; ”2“
但是如果是+运算，并且其中一边是字符串，那么还是按照字符串来连接




方式二：显示转换
调用Number()函数


其他类型转换数字规则![[Pasted image 20240515210345.png]]

Boolean的转换
发生在 逻辑运算中，也可以通过调用Boolean()显示地进行转换
转换规则：
直观上为空的值（0、空字符串、null、undefined和NaN）将变为false
其他值变为true![[Pasted image 20240515210631.png]]
注意：包含0的字符串“0”是true



typeof操作符
typeof操作符用来 确定任意变量的数据类型
返回值：
undifined表示值未定义
bollean表示值为布尔值
string表示值为字符串
number表示值为数值
object表示值为对象或null
function表示值为函数
symbol表示值为符号


typeof():
typeof(x)与 typeof x 相同，() 只是将后续内容当做一个整体



JavaScript函数
已经接触的函数
alert函数：浏览器弹出一个弹窗 
prompt函数：在浏览器弹窗中接收用户的输入
console.log函数：在控制台输入内容


声明函数使用function关键字function 函数名() &#123;  代码&#125;
arguments参数
默认情况下， arguments对象是所有（非箭头）函数中都可以用的 局部变量
该对象中存放着所有的 调用者传入的参数，从0位置开始，依次存放
arguments变量的类型是一个 object类型，而非一个数组
如果调用者传入的参数多于函数接收的参数，可以通过arguments去获取所有的参数


函数表达式

var foo = function () &#123;	console.log(&quot;foo函数&quot;)&#125;

注意：function关键字后面没有函数名
函数都是一个值（值的类型是一个对象）

JavaScript头等函数
头等函数是指在程序设计语言中，函数被当作头等公民
这意味着函数可以 作为别的函数的参数、函数的返回值、赋值给变量或存储在数据结构中


例如：函数可以在变量和变量之间相互进行赋值

function foo() &#123;console.log(&quot;foo函数执行&quot;)&#125;var bar = foobar()
回调函数
函数可以传递给另一个函数

function foo(fn) &#123;	fn()&#125;function bar() &#123;	console.log(&quot;我是bar函数被调用&quot;)&#125;foo(bar)

回调函数的案例

function request(url, callback) &#123;	console.log(&quot;根据URL向服务器发送网络请求&quot;)	console.log(&quot;需要花费比较长的时间拿到对应的结果&quot;)	var list = [&quot;javascript&quot;, &quot;javascript学习&quot;, &quot;javascript高级编程&quot;]	callback(list)&#125;request(&quot;url&quot;, function (res) &#123;	console.log(&quot;拿到结果:&quot;, res)&#125;)

高阶函数：
接受 一个或多个函数作为输入
输出一个函数


匿名函数：
在传入一个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量



立即执行函数
一个函数定义完后被立即执行
第一部分：定义一个匿名函数，这个函数有自己独立的作用域
第二部分：后面的 () 表示这个函数被执行了



//常用写法(只掌握这个写法)(function() &#123;	console.log(&quot;立即执行函数&quot;)&#125;)()//匿名写法(function(fn) &#123;	console.log(&quot;立即执行函数&quot;)&#125;());

作用：会创建一个独立的执行上下文环境，避免外界访问或修改内部的变量
应用场景一：避免变量命名重复造成内容被覆盖
应用场景二：点击按钮显示点击的第几个按钮

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;button class=&quot;btn&quot;&gt;按钮1&lt;/button&gt;  &lt;button class=&quot;btn&quot;&gt;按钮2&lt;/button&gt;  &lt;button class=&quot;btn&quot;&gt;按钮3&lt;/button&gt;  &lt;button class=&quot;btn&quot;&gt;按钮4&lt;/button&gt;    &lt;script&gt;        // 获取所有的按钮监听    var btnEls = document.querySelectorAll(&quot;.btn&quot;)    for (var i = 0; i &lt; btnEls.length; i++) &#123;      var btn = btnEls[i];      (function(m) &#123;        btn.onclick = function() &#123;          console.log(`按钮$&#123;m + 1&#125;发生了点击`)        &#125;      &#125;)(i)    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
JavaScript的面向对象
对象类型是一种 存储键值对（key-value） 的更加复杂的数据类型
对象类型可以 使用{…} 来创建，里面包含的是键值对
键值对 可以是 属性和方法
其中 key是字符串， value可以是任意类型， 包括基本数据类型、函数类型、对象类型等

创建对象
创建方式：
对象字面量：通过{}



var info = &#123;	name: &quot;jojo&quot;,	age: 20,	girfriend: &#123;		name: &quot;小羊&quot;,		age: 18,	&#125;,	running function() &#123;	console.log(&quot;running~&quot;)	&#125;&#125;
-  **new Object+动态添加属性**
- **new 其他类**


属性之间以 逗号分割

使用过程的操作：

访问对象的属性![[Pasted image 20240517224021.png]]
修改对象的属性![[Pasted image 20240517224030.png]]
添加对象的属性![[Pasted image 20240517224039.png]]
删除对象的属性：delete![[Pasted image 20240517224050.png]]


方括号

出现JavaScript无法理解的属性时，我们需要使用方括号![[Pasted image 20240517224435.png]]



对象的遍历
Objectkey() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组
遍历方式一：普通for循环![[Pasted image 20240517230541.png]]
遍历方式二：for in循环![[Pasted image 20240517230606.png]]

栈内存和堆内存
原始类型占据的空间是在栈内存中分配的
对象类型占据的空间是在堆内存中分配的
原始类型在变量中保存的是值本身
对象类型在变量中保存的是对象的”引用“![[Pasted image 20240518155438.png]]5个现象：
现象一：两个对象的比较

var obj1 = &#123;&#125;var obj2 = &#123;&#125;console.log(obj1 === obj2)//答案为false

现象二：引用的赋值

var info = &#123;	name: &quot;why&quot;,	friend: &#123;		name: &quot;kobe&quot;	&#125;&#125;var friend = info.friendfriend.name = &quot;james&quot;console.log(info.friend.name)//答案为James

现象三：值传递

function foo(a) &#123;	a = 200&#125;var num = 100foo(num)console.log(num)//答案为100

现象四：引用传递，但是在函数中创建了一个新对象，没有对传入对象进行修改

function foo(a) &#123;	a = &#123;		name: &quot;why&quot;	&#125;&#125;var obj = &#123;	name: &quot;obj&quot;&#125;foo(obj)console.log(obj)//答案为name: &quot;obj&quot;

现象五：引用传递，但是对传入的对象进行修改

function foo(a) &#123;	a.name = &quot;why&quot;&#125;var obj = &#123;	name: &quot;obj&quot;&#125;foo(obj)console.log(obj)//答案为name: &quot;why&quot;
this变量
this指向Windows

function fn () &#123;    console.log(this)   //Window&#125;fn();

this指向调用的对象

let obj = &#123;    name:&#x27;zy&#x27;,    sayHi:function() &#123;        console.log(this)    &#125;&#125;obj.sayHi() //obj   &#123;name: &quot;zy&quot;, sayHi: ƒ&#125;
创建一系列对象
方法一：工厂函数
封装一个函数，在这个函数中创建一个对象，再重复调用这个函数
对象是Object类型



function createstudent(name, age, height, address) &#123;	var stu = &#123;&#125;	stu.name = name	stu.age = age	stu.height = height	stu.address = address	stu.eating = function() &#123;		console.log(stu.name + &quot;在吃东西&quot;)	&#125;	return stu&#125;var stu1 = creat(&quot;张三&quot;, 18, 1.66, &quot;四川省&quot;)var stu2 = creat(&quot;jojo&quot;, 20, 1.80, &quot;四川省&quot;)

方法二：构造函数
也称之为 构造器，通常是我们在创建对象时会去调用的函数
JavaScript中的 构造函数扮演了其他语言中类的角色
也是一个 普通函数，如果被new操作符来调用了，那么这个函数就是一个构造函数
如果一个函数被使用new操作符来调用了，会执行以下操作
在内存中创建一个新的对象（空对象）
这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性
构造函数内部的this，会指向创建出来的新对象
执行函数的内部代码
如果构造函数没有返回非空对象，则返回创建出来的新对象


对象是构造的函数类型
名称：使用大驼峰



function Student(name, age, height) &#123;	this.name = name	this.age = age	this.height = height	this.eating = function() &#123;		console.log(this.name + &quot;在吃东西&quot;)	&#125;var stu1 = new Student(&quot;jojo&quot;, 20, 1.80)&#125;
全局对象-window作用：

查找变量时，最终会找到window头上
将一些浏览器全局提供给我们的变量&#x2F;函数&#x2F;对象，放在window对象上面
使用var定义的变量会被默认添加到window上面

JavaScript常见内置类原始类型的包装类
JavaScript的原始类型 并非对象类型，JavaScript为了可以 使其获得属性和调用方法，对其封装了对应的包装类型
常见的包装类型：String、Number、Boolean、Symbol、Biglnt类型
我们也可以自己创建一个包装类的对象（但没必要）

var name1 = &quot;why&quot;var name2 = new String(&quot;why&quot;)console.log(typeof name1) //stringconsole.log(typeof name2) //objectconsole.log(name1 === name2) //false

注意事项：null、undefined没有任何方法，也没有对应的“对象包装类”

Math对象的使用是一个 内置对象（不是一个构造函数）

Math常见的属性：
Math.PI：圆周率


Math常见的方法：
Math.floor：向下取整
Math.ceil：向上取整
Math.round：四舍五入取整
Math.random：生成[0, 1) 的随机数
Math.pow：返回x的y次幂


查看文档： 数学 - JavaScript |MDN的 (mozilla.org)

var num = 3.14console.log(Math.floor(num)) //3console.log(Math.ceil(num)) //4console.log(Math.round(num)) //3// 生成5~50随机数console.log(Math.floor(Math.random() * 45) + 5)
数组 - Array
一种有序的集合，可以通过索引来获取
创建数组的方式
方法一：![[Pasted image 20240520194120.png]]
方法二：![[Pasted image 20240520194244.png]]
在创建数组时，设置数组长度![[Pasted image 20240520194333.png]]
数组元素从0开始编号



数组的基本操作
访问数组中的元素
通过中括号[]访问
arr.at(i):
如果i &gt;&#x3D; 0，则与arr[i]完全相同
如果i为负数，则会从数组的尾部向前数





var num = [123, 234, 345, 456]    console.log(num[0]) //123    console.log(num.at(0)) //123    console.log(num[-1]) //undifined    console.log(num.at(-1)) //456    // 修改    num[0] = 132

添加、删除元素
在数组的尾端添加或者删除元素
push在末端添加元素
pop在末端取出一个元素


在数组的首段添加或者删除元素（运行速度比尾端的添加、删除操作慢）
shift取出首段的一个元素，整个数组向前移动
unshift在首段添加元素，整个数组向后移动


在中间某个位置添加或者删除
arr.splice方法可以做所有事情（添加、删除和替换）
语法结构：array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
从 start位置开始，处理数组中的元素
deleteCount：要删除的元素个数，如果为0或者负数表示不删除
item1，item2，…：在添加元素时，需要添加的元素


注意：这个方法会修改原数组





var num = [123, 234, 345, 456]    // 尾插    num.push(567, 678)    console.log(num) // 123, 234, 345, 456, 567, 678    // 尾删    num.pop()    console.log(num) // 123, 234, 345, 456, 567    // 头插    num.unshift(980, 789)    console.log(num) // 980, 789, 123, 234, 345, 456, 567    // 头删    num.shift()    console.log(num) // 789, 123, 234, 345, 456, 567    // 中间删    num.splice(1, 2) // 从索引为1开始，删除2个元素    console.log(num) // 789, 345, 456, 567    // 中间添加    num.splice(1, 0, 205, 427) // 在索引为1的前面，添加元素    console.log(num) // 789, 205, 427, 345, 456, 567    // 中间即删除又添加（即替换元素）    num.splice(1, 2, 654) // 从引为1开始，删除2个元素, 再添加元素    console.log(num) // 789, 654, 345, 456, 567

length属性

length属性用于获取数组的长度
当我们修改数组的时候，length属性会自动更新


length属性是可写的
手动增加一个大于默认length的数值，那么会增加数组的长度
减少它，数组就会被截断
清空数组最简单的方法：arr.length &#x3D; 0




数组的遍历

普通for循环遍历
for..in遍历，获取到索引值
for..of遍历，获取到每一个元素



var num = [123, 234, 345, 456]    for (var i = 0; i &lt; num.length; i++) &#123;      console.log(num[i])    &#125;    for(var index in num) &#123;      console.log(index, num[index])    &#125;    for(var item of num) &#123;      console.log(item)    &#125;


数组方法 - slice、cancat、jojin
arr.slice：用于对数组进行截取 ，返回一个新的数组，不会对原数组进行操作
arr.slice([begin[, end]])
包含begin元素不包含end元素


arr.cancat：创建一个新数组，其中包含来自其他数组和其他项的值
var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])


arr.join：将一个数组的所有元素链接成一个字符串并返回
arr.join([separator])





var num = [123, 234, 345, 456]    var num1 = num.slice(1, 3)    console.log(num1) // 234、345    var num2 = [12, 13, 14]    var num3 = num.concat(num2)    console.log(num3) // 123, 234, 345, 456, 12, 13, 14    console.log(num.join(&quot;&quot;)) //123234345456(字符串)


查找元素
arr.indexOf方法：查找某个元素的索引
arr.indexOf(searchElement[, fromIndex])
从fromIndex开始查找，如果找到返回对应的索引，没有找到返回-1
还有对应的从最后位置开始查找的lastIndexOf


arr.includes方法：判断数组是否包含某个元素
arr.includes(valueToFind[, fromIndex])
从索引from开始搜索item，如果找到返回true


forEach：遍历整个数组
array.forEach(function(currentValue, index, arr), thisValue)
function(currentValue, index, arr): 必需。对数组中每个元素要执行的函数。该函数有以下三个参数:
currentValue: 必需。当前元素的值。
index: 可选。当前元素的索引值。
arr: 可选。当前元素所属的数组对象。


thisValue: 可选。传递给函数的值，用于 this 关键词。
forEach() 方法没有返回值,它只是对数组中的每个元素执行指定的操作。


find：直接查找元素
array.find(function(currentValue, index, arr), thisValue)
function: 一个回调函数,用于测试数组的每个元素。
currentValue: 数组中正在处理的当前元素。
index(可选): 数组中正在处理的当前元素的索引。
arr(可选): 正在使用 find() 方法的数组本身。
thisValue(可选): 可以用来设置回调函数中的 this 值。
 如果在数组中找到满足条件的第一个元素,则返回该元素的值;否则返回 undefined


findIndex：直接查找索引（用法与find类似）
array.findIndex(function(currentValue, index, arr), thisValue)
 如果在数组中找到满足条件的第一个元素,则返回该元素的索引;否则返回 -1。




排序
sort：对数组进行排序，并且生成一个排序后的新数组
arr.sort([compareFunction])
compareFunction(a, b)&lt;0, a排在b前面
compareFunction(a, b)&gt;0, a排在b后面


reverse：将数组中的元素进行倒置，并且返回该数组



var students = [3, 6, 1, 7]var newStus = students.sort(function(items1, items2) &#123;	return items1 - items2 //升序 1, 3, 6, 7	// return items2 - items1 降序 7， 6， 3， 1&#125;)var newStus = students.reverse() // 7, 1, 6, 3
时间
创建Date对象
Date的构造函数
new Date()
new Date(value) (传入时间戳)
new Data(dataString)
new Data(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])





var date1 = new Date() //当前时间   var date2 = new Date(1000) //传入毫秒数，表示从1970-01-01 00:00:00 UTC 经过的毫秒数   var date3 = new Date(&quot;2024-5-27&quot;)   var date4 = new Date(2024, 05, 27, 21, 42, 00,000) //年月日时分秒毫秒   console.log(date4)
![[Pasted image 20240527214831.png]]

dateString时间的表达方式
日期有两种表达方式：RFC 2822标准（默认打印时间格式）和 ISO 8601标准
转成ISO 8601标准：data.toISOString()
YYYY：年份，0000~9999
MM：月份，01~12
DD：日，01~31
T：分隔时间和日期，无特殊含义
HH：小时，00~24
mm：分钟，00~59
ss：秒，00~59
.sss：毫秒
Z：时区




从Data获取信息
getFullYear()：获取年份（4位数）
getMonth()：获取月份，从0~11
getDate()：获取当月的具体日期，从1~31
getHours()：获取小时
getMinutes()：获取分钟
getSeconds()：获取秒钟
getMilliseconds()：获取毫秒
getDat()：一周中的第几天（周日是0开始）


Data设置信息的方法
**setFullYear(year, [month], [date])
**setMonth(month, [date])
**setDate(date)
**setHours(hour, [min], [sec], [ms])
**setMinutes(min, [sec], [ms])
**setSeconds(sec, [ms])
**setMilliseconds(ms)
setTime(milliseconds)


Date获取Unix时间戳
Unix时间戳：是一个整数值，表示从1970年1月1日00:00:00 UTC以来的毫秒数
获取时间戳：
new Date.getTime()
new Date.valueOf()
+new Date()
Date.now()


可以用时间戳来测试代码的性能


Date.parse方法
Date.parse(str)方法可以从一个字符串中读取日期，并且输出对应的Unix时间戳
作用等同于 new Date(dateString).getTime()操作
需要符合RFC2822或ISO 8601日期格式的字符串
如果输入的格式不能被解析，会返回NaN



var date = new Date() //当前时间   console.log(date)   console.log(date.toISOString())   // 获取时间信息   var year = date.getFullYear()   var month = date.getMonth() + 1   var day = date.getDate()   var hour = date.getHours()   var minute = date.getMinutes()   var second = date.getSeconds()   console.log(year, month, day, hour, minute, second)   console.log(`$&#123;year&#125;/$&#123;month&#125;/$&#123;day&#125; $&#123;hour&#125;:$&#123;minute&#125;:$&#123;second&#125;`)   // 给date设置时间   date.setFullYear(2044)   //自动校验   date.setDate(32)   console.log(date)   var startTime = Date.now()   for(var i = 0 ; i &lt; 10000; i++) &#123;     console.log(i)   &#125;   var endTime = Date.now()   console.log(endTime - startTime)
![[Pasted image 20240528205053.png]]![[Pasted image 20240528210927.png]]
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端三件套</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript下</title>
    <url>/posts/2025/04/Fronted/%E4%B8%89%E4%BB%B6%E5%A5%97/04-%20JavaScript%E9%AB%98%E7%BA%A7/b746f28d.html</url>
    <content><![CDATA[this指向this的绑定规则this的指向
在函数调用的时候，JavaScript会 默认给this绑定一个值
this的 绑定和定义的位置（即编写的位置） 没有关系
this的 绑定和调用方式以及调用的位置有关系
this 是在运行时才被绑定的

默认绑定
独立的调用函数this指向window，但在严格模式下独立调用的函数中的this指向的是Undefined(“use strict”)

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;      // 默认绑定      // 1.案例一      function foo() &#123;        console.log(this)      &#125;       foo()      // 2.案例二      function test1() &#123;        console.log(this)        test2()      &#125;      function test2() &#123;        console.log(this)        test3()      &#125;      function test3() &#123;        console.log(this)      &#125;      test1()      // 3.案例三      function project(func) &#123;        func()      &#125;      var obj = &#123;        name: &quot;jojo&quot;,        bar: function() &#123;          console.log(this)        &#125;      &#125;      project(obj.bar)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
隐式绑定&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    function foo() &#123;      console.log(this) //这里的this绑定到obj对象    &#125;    var obj = &#123;      bar: foo    &#125;    obj.bar()  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
new绑定
执行的操作
创建一个全新的对象
这个新对象会被执行prototype连接
这个新对象会绑定到函数调用的this上
如果函数没有返回其他对象，表达式会返回这个新对象



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;    function foo() &#123;      console.log(this);       this.name = &quot;why&quot;    &#125;    new foo() //this绑定foo  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
显式绑定call：func.call(thisArg, arg1, arg2, ...)apply：func.apply(thisArg, [arg1, arg2, ...]
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    var obj = &#123;      name: &quot;why&quot;    &#125;    function foo(name, age) &#123;      console.log(this)      console.log(name, age)    &#125;    foo.call(obj, &quot;jojo&quot;, 20) //执行函数，并且强制this指向obj    foo.apply(obj, [&quot;小羊&quot;, 19])  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
bind
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    function foo(name, age) &#123;      console.log(this);      console.log(name);      console.log(age);    &#125;        var obj = &#123;      name: &#x27;Tom&#x27;    &#125;    var bar = foo.bind(obj, &quot;jojo&quot;, 20)    bar()  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
绑定优先级显式 &gt; 隐式new &gt; 隐式new &gt;  bind
this面试题一![[Pasted image 20240727141059.png]]
二![[Pasted image 20240727191000.png]]
三![[Pasted image 20240727211810.png]]
![[Pasted image 20240727211824.png]]
四![[Pasted image 20240727220053.png]]
手写call、apply、bind函数day36
箭头函数
箭头函数 不会绑定this、arguments属性， 没有显示原型，不能和new一起使用
nums.forEach((item, index, arr) =&gt; &#123; &#125;)
优化：
如果只有一个参数，( )可以省略![[Pasted image 20240725150801.png]]
如果执行体只有一行代码，可以省略大括号，并且会返回这行代码的返回值![[Pasted image 20240725150853.png]]
如果执行体只返回一个对象，需要给对象加上( )![[Pasted image 20240725150934.png]]



深入浏览器的渲染原理网页被解析的过程![[Pasted image 20240801121708.png]]
浏览器的内核
常见的浏览器内核![[Pasted image 20240801123558.png]]
浏览器内核也称作浏览器排版引擎

渲染页面的详细流程![[Pasted image 20240801123756.png]]解析HTML生成 DOM Tree ，遇到css文件时，解析CSS生成 Style Rules，这两者的解析过程不产生冲突。DOM Tree 和 Style Rules生成 Render Tree（渲染树，渲染树中没有节点的位置），再通过 Layout进行布局，然后进行绘画和展示
HTML解析过程
解析HTML是所有步骤的开始（服务器给浏览器默认返回  .html 文件）
解析HTML构建 DOM Tree![[Pasted image 20240801124525.png]]

生成CSS规则
解析过程中，遇到CSS的 link元素，浏览器会下载对应的CSS文件（下载CSS文件不会影响DOM解析）
下载完CSS文件，会对CSS文件进行解析，得到对应的 Style Rules（规则树， 也可以称之为CSSOM，CSS对象模型）![[Pasted image 20240801124907.png]]

构建Render Tree
DOM Tree 和 CSSOM Tree 结合构建 Render Tree![[Pasted image 20240801125031.png]]
link元素不会阻碍DOM Tree 的构建过程，但会阻碍 Render Tree 的构建过程，因为在构建Render Tree时，需要对应的CSSOM Tree
Render Tree 和 DOM Tree 并不是一一对应的关系， display为none的元素，不会出现在Render Tree中

布局（Layout）和绘制（paint）
在Render Tree上运行 布局 来计算每个节点的几何体
Render Tree会显示节点及其他样式，但不显示 每个节点的尺寸、位置等信息
布局可以确定呈现树中 所有节点的宽度、高度和位置信息


将每个节点绘制到屏幕上
绘制时，浏览器将布局的每个frame转为屏幕上实际的像素点
包括将元素的可见部分进行绘制，如 文本、颜色、边框、阴影、替换元素（img等）



回流和重绘
回流
在第一次确定节点的大小和位置，称之为布局
之后再进行修改重新计算称为回流


引起回流的情况![[Pasted image 20240801131023.png]]
重绘
第一次渲染内容称之为绘制
之后重新渲染称之为重绘


引起重绘的情况
修改背景色、文字颜色、边框颜色、样式等![[Pasted image 20240801131232.png]]



特殊解析 - composite合成
每个合成层都是 单独渲染的
默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中
有一些属性绘创建一个新的合成层，利用GPU来加速绘制
**3D transforms
**video、canvas、iframe
**opacity动画转换时
**position: fixed(固定定位)
will-change（目前还是一个实验性的属性，提前告诉浏览器元素可能发生的变化）
**animation 或 transition 设置了 opacity(透明度)、transform


分层是以内存管理为代价提高性能，不能作为性能优化策略过度使用

script元素和页面解析的关系
浏览器在解析HTML过程中，遇到了 script元素是不能继续构建DOM树的，会停止构建，先下载JavaScript代码，并且执行JavaScript的脚本，等到JavaScript脚本执行结束后，再继续解析HTML，构建DOM树![[Pasted image 20240801142428.png]]

defer属性
defer属性告诉浏览器 不要等待脚本下载， 继续解析HTML， 构建DOM Tree， 如果脚本提前下载好了，它会 等待DOM Tree构建完成，在DOMContentLoaded事件完成前先执行defer中的代码
多个带defer的脚本会保持正确的顺序执行
defer可以提高网页的性能，推荐放在head元素中
注意： defer只适用于外部脚本，对于script默认内容会被忽略

async属性
async让一个脚本完全独立
async脚本不会阻碍浏览器的解析（与defer类似）
async脚本不能保证顺序，它独立下载、独立运行，不会等待其他脚本
async不能保证在DOMContentLoaded之前或者之后执行


defer常用于需要在文档解析后操作DOM的JavaScript代码，并且对多个script文件有顺序要求
async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的

深入JavaScript的运行原理V8引擎的执行原理![[Pasted image 20240801154302.png]]
V8引擎的架构![[Pasted image 20240801154530.png]]
JS执行上下文执行上下文
JS引擎内部有一个执行上下文栈（Execution Context Stack，简称ECS），用于执行代码的调用栈
全局的代码块为了执行会构建一个Global Execution Context（GEC），GEC会被放入ECS中执行

认识VO对象
每一个执行上下文会关联一个 VO（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中
当全局代码被执行的时候，VO就是GO对象了

函数执行上下文![[Pasted image 20240801172129.png]]
JavaScript的内存管理和闭包JavaScript内存管理
JavaScript会在 定义数据时为我们分配内存
JavaScript对于 原始数据类型内存的分配  会在执行时，直接在栈空间进行分配
对于 复杂数据类型内存的分配  会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用

垃圾回收（GC）算法引用计数
当 一个对象有一个引用指向它 时，这个对象的的引用就 +1
当 一个对象的引用为0 时，这个对象就可以被销毁掉
弊端：会产生循环引用![[Pasted image 20240802152232.png]]

标记清除
核心思路： 可达性
实现思路： 设置一个 根对象，垃圾回收器会定期从这个根对象开始，找到所有从根开始有引用到的对象，对于没有引用到的对象，认为是不可用的对象
这个算法解决了上一个算法产生的循环引用的问题![[Pasted image 20240802154857.png]]

算法优化V8引擎为了进行更好的优化，在算法实现细节上会结合一些其他算法

标记整理
回收期间会将保存的储存对象 搬运汇集到连续的内存空间，从而 整合空闲空间，避免内存碎片化


分代收集：对象被分为 新的 和 旧的
很多对象完成工作并很快死去，它们会被 很快被清理
那些长期存活的对象会变 老旧，而且 被检查的频次也会减少


**增量收集
将垃圾收集工作分成几个部分来做，然后将这几部分逐一处理，这样把一个大的延迟分成许多微小的延迟


**闲时收集
垃圾收集器 只会在CPU空闲时尝试运行，减少可能对代码执行的影响



闭包闭包的定义
一个函数和周围的环境的引用捆绑在一起，这样的组合就是闭包
闭包可以在一个内层函数中访问到其外层函数的作用域
广义理解：JavaScript中的函数都是闭包
狭义理解：JavaScript中的一个函数，如果访问了外层作用域的变量，那么它就是一个闭包

JavaScript函数的增强知识函数对象的属性和argumens属性name和length
属性name：一个函数的名词我们可以通过name来访问![[Pasted image 20240802203605.png]]
属性length：返回函数输入参数的个数（rest参数不参与参数的个数）![[Pasted image 20240802203941.png]]

认识arguments
arguments是一个类数组对象（不是一个数组类型，而是一个对象类型）
它拥有数组的一些特性，如length、可以用Index索引来访问
但没有数组的一些方法，如filter、map



arguments转Array
方法一：遍历arguments，添加到一个新数组中![[Pasted image 20240802205908.png]]
方法二：ES6中的两个方法
1.Array.from![[Pasted image 20240802210001.png]]
2.[...arguments]![[Pasted image 20240802210026.png]]


方法三：调用slice函数的call方法![[Pasted image 20240802210124.png]]

函数的剩余（rest）参数
ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中
最后一个参数是 … 为前缀，那么剩余的参数会作为一个数组放到该参数中![[Pasted image 20240803163950.png]]


剩余参数和arguments的区别
剩余参数只包含 没有对应形参的实参，arguments对象包含了 传给函数的所有实参
arguments对象不是一个数组，只是类数组对象，而rest参数是一个真正的数组，可以进行数组的所有操作


剩余参数必须放到最后一个位置，否则会报错

纯函数理解纯函数
有确定的输入，一定会产生确定的输出
函数在执行过程中，不能产生副作用

柯里化函数![[Pasted image 20240803194335.png]]
自动柯里化（了解）![[Pasted image 20240803201340.png]]
组合函数![[Pasted image 20240803203237.png]]
严格模式![[Pasted image 20240803210307.png]]
对象增强Object.defineProperty
Object.defineProperty()方法会直接在对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象：Object.defineProperty(obj, prop, descriptor)
可接受三个参数
obj：要定义属性的对象
prop：要定义或修改属性的名称或Symbol
descriptor：要定义或修改的属性描述符


返回值被传递给函数的对象

数据属性描述符![[Pasted image 20240805170950.png]]
存取属性描述符![[Pasted image 20240805172134.png]]
同时定义多个属性
Object.defineProperties()方法直接在一个对象上定义多个新的属性或修改现有属性，并且返回该对象![[Pasted image 20240805173134.png]]

ES5中的继承对象和函数的原型认识对象原型![[Pasted image 20240805192039.png]]
函数对象的原型![[Pasted image 20240805192551.png]]将方法放在原型上

*减少内存占用：
当方法定义在对象的实例上时,每个对象都会有一个独立的方法副本,这会浪费内存。
将方法放在原型上,所有对象实例共享同一个方法,大大减少了内存的使用。


提高代码复用性：
将方法放在原型上,可以让所有对象实例都能访问和使用这些方法。
这提高了代码的复用性,避免了在每个对象实例上都定义相同的方法,提高了开发效率。


*动态添加&#x2F;修改方法：
通过修改原型,可以动态地为所有对象实例添加或修改方法。
这使得代码更加灵活和可扩展。


保持对象实例的轻量级：
将方法放在原型上,可以保持对象实例本身更加简单和轻量级。
对象实例中只保存自己的属性,方法都存储在原型上,这样可以提高性能。


*继承和多态：
通过原型链机制,可以实现继承和多态。
子类可以重写或扩展从父类继承的方法,实现代码复用和多态特性。注意： 讲方法放在原型上的方法也叫做实例方法，在没有实例对象的情况下，不能调用此函数



&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    function Students(name, age, grade) &#123;      this.name = name;      this.age = age;      this.grade = grade;    &#125; // 定义构造函数        Students.prototype.running = function() &#123;      console.log(this.name + &quot; is running&quot;);    &#125; // 将方法放在原型上    var std1 = new Students(&quot;jojo&quot;, 20, 100) // 创建实例对象    std1.running()  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
constructor属性![[Pasted image 20240806141712.png]]**理解![[Pasted image 20240806145948.png]]
![[Pasted image 20240806145900.png]]

重写原型对象![[Pasted image 20240806151052.png]]![[Pasted image 20240806151113.png]]![[Pasted image 20240806151123.png]]![[Pasted image 20240806151136.png]]

通过原型链实现继承创建父类对象，并且作为子类的原型对象![[Pasted image 20240806160312.png]]![[Pasted image 20240806160344.png]]![[Pasted image 20240806160612.png]]
借用构造函数实现继承![[Pasted image 20240806161649.png]]![[Pasted image 20240806161712.png]]![[Pasted image 20240806161725.png]]

组合原型链和借用构造函数实现继承的问题![[Pasted image 20240806162633.png]]

寄生组合实现继承![[Pasted image 20240806165456.png]]最终实现方案：

将继承函数封装成工具放在JS文件中![[Pasted image 20240806170337.png]]
代码![[Pasted image 20240806170358.png]]

对象的方法补充![[Pasted image 20240806173132.png]]
ES6实现继承原型继承关系图![[Pasted image 20240806211030.png]]
class方式定义类
使用class来定义一个类：
类声明和类表达式![[Pasted image 20240807133150.png]]


在创建对象的时候想给类传递一些参数：
每个类有一个固定的构造函数方法constructor
每个类只能有一个构造函数


注意：类中定义的多个内容不需要使用 “,” 进行分割

实例方法class Person &#123;     constructor(name, age) &#123;       this.name = name       this.age = age     &#125;     //running和eating被添加在Person.prototype上     running() &#123;       console.log(`$&#123;this.name&#125; is running.`)     &#125;     eating() &#123;       console.log(`$&#123;this.name&#125; is eating.`)     &#125;   &#125;   var p1 = new Person(&quot;jojo&quot;, 20)   p1.running()   p1.eating()
类的静态方法
静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用 static关键字来定义
类方法里面的this指向类本身

&lt;script&gt;    class Person &#123;      constructor(name, age) &#123;        this.name = name        this.age = age      &#125;      static running() &#123;        console.log(`$&#123;this.name&#125; is running.`);       &#125;    &#125;    Person.running() // 静态方法可以直接通过类名调用，不需要实例化对象,这里的this指向类本身，输出Person is running.  &lt;/script&gt;
super关键字
执行 super.method(…) 来调用一个父类方法
执行 super(…) 来调用一个父类 constructor (只能在自己的constructor中调用)
注意： 在子类的构造函数中使用this或者返回默认对象之前，必须先通过super调用父类的构造函数
super的使用位置有三个：子类的构造方法、实例方法、静态方法

&lt;script&gt;    class Person &#123;      constructor(name, age) &#123;        this.name = name        this.age = age      &#125;      running() &#123;        console.log(&#x27;running&#x27;)      &#125;      eating() &#123;        console.log(&#x27;eating&#x27;)      &#125;      static sleep() &#123;        console.log(&#x27;sleeping&#x27;)      &#125;    &#125;    class Student extends Person &#123;      constructor(name, age, grade) &#123;        // 调用父类构造函数        super(name, age)        this.grade = grade      &#125;      // 重写父类方法      running() &#123;        console.log(&#x27;running in class&#x27;)        super.running() // 调用父类方法      &#125;      // 新增方法      studying() &#123;        console.log(&#x27;studying&#x27;)      &#125;      // 重写父类静态方法      static sleep() &#123;        console.log(&#x27;sleeping in class&#x27;)        super.sleep() // 调用父类静态方法      &#125;    &#125;    var stu = new Student(&quot;jojo&quot;, 18)    stu.running()    stu.eating()    stu.studying()    Student.sleep()      &lt;/script&gt;
继承内置类&lt;script&gt;    // 1、创建一个新的类，继承内置类 Array    class xyArray extends Array &#123;      get lastItem() &#123;        return this[this.length - 1]      &#125;      get firstItem() &#123;        return this[0]      &#125;    &#125;    var arr = new xyArray(1, 2, 3, 4, 5)    console.log(arr) // [1, 2, 3, 4, 5]    console.log(arr.length) // 5    console.log(arr.lastItem) // 5    console.log(arr.firstItem) // 1    // 2、直接对Array进行扩展    Array.prototype.lastItem = function() &#123;      return this[this.length - 1]    &#125;    Array.prototype.firstItem = function() &#123;      return this[0]    &#125;    var arr2 = [1, 2, 3, 4, 5]    console.log(arr2) // [1, 2, 3, 4, 5]    console.log(arr2.length) // 5    console.log(arr2.lastItem()) // 5    console.log(arr2.firstItem()) // 1  &lt;/script&gt;
类的混入mixins
JavaScript的类只支持单继承，当我们需要多继承时，可以使用混入![[Pasted image 20240807153120.png]]

ES6对象的增强字面量的增强
属性的简写

// 1、属性的增强    var name = &quot;小明&quot;    var age = 18    var obj = &#123;      name, // 等同于 name: name      age // 等同于 age: age    &#125;    function foo() &#123;      var message = &quot;Hello World&quot;      var info = &quot;This is a message from &quot;      return &#123;        message, // 等同于 message: message        info // 等同于 info: info      &#125;    &#125;    var result = foo()    console.log(result.message) // Hello World    console.log(result.info) // This is a message from 

方法的增强

// 2、方法的增强var obj = &#123;  name: &quot;小明&quot;,  age: 18,  sayHello() &#123; // 等同于 sayHello: function() &#123;...&#125;    console.log(&quot;Hello, &quot; + this.name)  &#125;&#125;obj.sayHello() // Hello, 小明

计算属性名

// 3、计算属性名    var key = &quot;address&quot;    var value = &quot;北京市海淀区&quot;    var obj = &#123;      [key]: value // 等同于 obj[key] = value    &#125;    console.log(obj.address) // 北京市海淀区
解构
数组的解构

// 1.数组的解构语法    var arr = [1, 2, 3, undefined, 5]    // 1.1基本用法    var [a, b, c] = arr    console.log(a, b, c) // 1 2 3    // 1.2按照严格的顺序    var [a, , c] = arr    console.log(a, c) // 1 3    // 1.3解构出数组    var [a, b, ...arr2] = arr    console.log(a, b, arr2) // 1 2 [3, 4, 5]    // 1.4默认值    var [a , b, c, d = 4, e] = arr    console.log(a, b, c, d, e) // 1 2 3 4 5

对象的解构

// 2.对象的解构语法    var obj = &#123;name: &#x27;zhangsan&#x27;, age: 20, city: &#x27;beijing&#x27;&#125;    // 2.1基本用法    var &#123;name, age, city&#125; = obj    console.log(name, age, city) // zhangsan 20 beijing    // 2.2对象的解构没有顺序，根据key值解构    var &#123;age, name, city&#125; = obj    console.log(name, age, city) // zhangsan 20 beijing    // 2.3解构出对象    var &#123;name, age, ...obj2&#125; = obj    console.log(name, age, obj2) // zhangsan 20 &#123;city: &quot;beijing&quot;&#125;    // 2.4默认值    var &#123;name, age, city, job = &#x27;teacher&#x27;&#125; = obj    console.log(name, age, city, job) // zhangsan 20 beijing teacher    // 2.5对变量名进行重命名    var &#123;name: myName, age: myAge, city: myCity&#125; = obj    console.log(myName, myAge, myCity) // zhangsan 20 beijing
ES6新特性let、const基本使用
let关键字：与var没有太大的区别，都是用于声明一个变量
const关键字
用const关键字声明的变量一旦被赋值，就不能被修改
如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容![[Pasted image 20240810011845.png]]


let、const都不允许重复声明变量
let、const不会给window上添加任何属性

let、const的块级作用域
let、const、function、class声明的标识符具备块级作用域的限制![[Pasted image 20240810022228.png]]
但是函数拥有块级作用域，但是在外面依然可以访问

应用场景
获取多个按钮监听点击![[Pasted image 20240810023404.png]]

模版字符串
ES6开始使用模版字符串来嵌入JS的变量或者表达式来进行拼接
使用反引号来编写字符串，称为模版字符串
再通过 ${expression} 来动态嵌入内容![[Pasted image 20240810025103.png]]



标签模版字符串
使用标签模版字符串，在调用时插入其他变量
模版字符串会被拆分
第一个元素是数组，是被模版字符串拆分的字符串组合
后面的元素是一个个模版字符串传入的内容![[Pasted image 20240810030121.png]]



展开运算符展开语法![[Pasted image 20240810032922.png]]![[Pasted image 20240810033004.png]]
Symbol![[Pasted image 20240810034748.png]]![[Pasted image 20240810034808.png]]![[Pasted image 20240810035320.png]]![[Pasted image 20240810035344.png]]
Set-MapSet
基本使用
Set中的元素不能重复
这个功能可以给数组去重![[Pasted image 20240810143447.png]]


常见属性和方法
属性
size：返回Set中元素的个数


方法
add(value)：添加某个元素，返回Set对象本身
delete(value)：从Set中删除和value值相等的元素，返回Boolean类型
has(value)：判断Set中是否存在某个元素，返回Boolean类型
clear()：清空Set中的所有的元素，没有返回值
forEach(callback, [,thisArg])：通过forEach遍历Set





WeakSet![[Pasted image 20240810145329.png]]![[Pasted image 20240810145349.png]]
Map![[Pasted image 20240810150140.png]]![[Pasted image 20240810150225.png]]
WeakMap![[Pasted image 20240810152228.png]]![[Pasted image 20240810152332.png]]
Promise
用于处理异步的解决方案


Promise 的状态: Promise 有三种状态:Pending（进行中）、Fulfilled（已成功）和 Rejected（已失败）。这些状态可以帮助我们更好地跟踪异步操作的进度。

Promise 的链式调用: 通过 .then() 和 .catch() 方法,我们可以将多个异步操作串联起来,形成一个 Promise 链。这样可以使代码更加清晰和可读。

错误处理: 在 Promise 链中,只需在最后添加一个 .catch() 方法即可捕获任何一个步骤中出现的错误,大大简化了错误处理的逻辑。

async&#x2F;await: 为了进一步简化 Promise 的使用,ES2017 引入了 async/await 语法糖。使用 async 函数可以让异步代码看起来更像同步代码,大大提高了可读性。



使用基本格式：


创建 Promise:
使用 new Promise() 创建一个新的 Promise 对象。
传递一个函数作为参数,这个函数被称为 Promise 执行器(Executor)。
在 Promise 执行器函数内部,我们执行异步操作。
如果异步操作成功,调用 resolve(result) 函数,将结果传递出去。
如果异步操作失败,调用 reject(error) 函数,将错误信息传递出去。


使用 Promise:
通过 .then() 方法处理 Promise 成功的情况。
通过 .catch() 方法处理 Promise 失败的情况。
通过 .finally() 方法处理无论成功还是失败都要执行的代码。


Promise 链式调用:   
每次调用 .then() 或 .catch() 方法都会返回一个新的 Promise 对象。
可以将多个 Promise 操作串联起来,形成 Promise 链。
下一个 .then() 方法会等待上一个 Promise 完成后再执行。



new Promise((resolve, reject) =&gt; &#123;  // 执行一些异步操作  if (/* 操作成功 */) &#123;    resolve(result);  &#125; else &#123;    reject(error);  &#125;&#125;).then(result =&gt; &#123;  // 处理成功的结果&#125;).catch(error =&gt; &#123;  // 处理失败的情况&#125;).finally(() =&gt; &#123;  // 无论成功还是失败都会执行的代码&#125;);

resolve不同值的区别


传递普通值 new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;success&#x27;);&#125;).then(result =&gt; &#123;  console.log(result); // 输出: &#x27;success&#x27;&#125;).catch(error =&gt; &#123;  console.error(error);&#125;);

如果 resolve() 函数传递一个普通值,这个值会作为 Promise 的 resolve 结果被传递到后续的 .then() 方法中。


传递 Promise 对象 new Promise((resolve, reject) =&gt; &#123;  resolve(    new Promise((innerResolve, innerReject) =&gt; &#123;      setTimeout(() =&gt; &#123;        innerResolve(&#x27;inner promise result&#x27;);      &#125;, 2000);    &#125;)  );&#125;).then(result =&gt; &#123;  console.log(result); // 输出: &#x27;inner promise result&#x27;&#125;).catch(error =&gt; &#123;  console.error(error);&#125;);

如果 resolve() 函数传递的是另一个 Promise 对象,那么外层 Promise 的状态会跟随内层 Promise 的状态进行变化。
外层 Promise 会”等待”内层 Promise 完成,然后采用内层 Promise 的状态和结果。


传递 thenable 对象 const myThenable = &#123;  then(resolve, reject) &#123;    resolve(&#x27;thenable result&#x27;);  &#125;&#125;;new Promise((resolve, reject) =&gt; &#123;  resolve(myThenable);&#125;).then(result =&gt; &#123;  console.log(result); // 输出: &#x27;thenable result&#x27;&#125;).catch(error =&gt; &#123;  console.error(error);&#125;);

如果 resolve() 函数传递的是一个具有 .then() 方法的对象(称为 thenable 对象),那么 Promise 会”等待”这个对象执行完 .then() 方法,并采用其返回的结果。


传递 throw 或 reject() new Promise((resolve, reject) =&gt; &#123;  reject(new Error(&#x27;Something went wrong&#x27;));&#125;).then(result =&gt; &#123;  console.log(result);&#125;).catch(error =&gt; &#123;  console.error(error); // 输出: Error: Something went wrong&#125;);

如果在 Promise 执行器函数内部调用 throw 或 reject() 函数,那么 Promise 的状态会变为 rejected。
后续的 .catch() 方法会捕获到这个错误,并进行处理。



ES8~ES13ES8中对象的相关属性
Object.values():
该方法返回一个给定对象自身的所有可枚举属性值的数组。
它的行为与 Object.keys() 类似,但返回的是属性值,而不是属性名。


Object.entries():
该方法返回一个给定对象自身可枚举字符串键属性 [key, value] 的数组。
这个方法提供了一种迭代一个对象的所有属性的便捷方式。


Object.getOwnPropertyDescriptors():
该方法返回指定对象所有自身属性的描述符。
这个方法在 Object.create() 时很有用,用于实现属性的复制和继承。


Trailing commas:
Trailing commas 允许在对象字面量、数组字面量、函数参数列表和函数调用中使用尾随逗号。
这可以使代码更容易维护和扩展,因为添加新属性或参数不会影响前面的代码。


Async functions:
Async functions 是 ES8 中引入的一个重要特性,用于简化异步编程。
Async 函数返回一个 Promise 对象,可以使用 await 关键字来等待 Promise 完成。



ES8-padStart和padEnd
padStart(targetLength, [padString]) 方法将当前字符串填充到指定的长度。填充从字符串的开始(左侧)应用的。

// 用 &#x27;0&#x27; 填充到长度 5console.log(&#x27;42&#x27;.padStart(5, &#x27;0&#x27;)); // Output: &#x27;00042&#x27;// 用空格填充到长度 10console.log(&#x27;foo&#x27;.padStart(10)); // Output: &#x27;       foo&#x27;

padEnd(targetLength, [padString]) 方法将当前字符串填充到指定的长度。填充从字符串的末尾(右侧)应用的。

// 用 &#x27;.&#x27; 填充到长度 5console.log(&#x27;hello&#x27;.padEnd(5, &#x27;.&#x27;)); // Output: &#x27;hello.&#x27;// 用空格填充到长度 10console.log(&#x27;foo&#x27;.padEnd(10)); // Output: &#x27;foo        &#x27;

这些方法在处理金额、日期、编号等数据格式时非常有用,可以帮助我们快速地格式化字符串。
// 格式化金额const amount = 123.45;console.log(amount.toFixed(2).padStart(10, &#x27;0&#x27;)); // Output: &#x27;0000123.45&#x27;// 格式化日期const date = &#x27;2023-5-1&#x27;;console.log(date.padStart(10, &#x27;0&#x27;)); // Output: &#x27;2023-05-01&#x27;// 隐藏卡号function hideIdCard(idCard) &#123;  return idCard.slice(-4).padStart(18, &#x27;*&#x27;);&#125;console.log(hideIdCard(&#x27;123456789012345678&#x27;)); // Output: ***************5678function hideBankCard(bankCard) &#123;  const length = bankCard.length;  const front = bankCard.slice(0, 4);  const back = bankCard.slice(-4);  return front + &#x27;*&#x27;.repeat(length - 8) + back;&#125;console.log(hideBankCard(&#x27;1234567890123456&#x27;)); // Output: 1234************3456console.log(hideBankCard(&#x27;123456789012345678&#x27;)); // Output: 1234************5678
ES9-Object spread operators
Spread 操作符 (...)Spread 操作符可以在对象字面量中使用,用于展开一个现有的对象,将其属性复制到新的对象中。

const originalObj = &#123; a: 1, b: 2 &#125;;const newObj = &#123; ...originalObj, c: 3 &#125;;console.log(newObj); // Output: &#123; a: 1, b: 2, c: 3 &#125;
在上面的例子中,我们使用 Spread 操作符 ... 将 originalObj 的属性复制到 newObj 中,并添加了一个新的属性 c。2. 合并多个对象Spread 操作符可以方便地合并多个对象:
const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; b: 3, c: 4 &#125;;const mergedObj = &#123; ...obj1, ...obj2 &#125;;console.log(mergedObj); // Output: &#123; a: 1, b: 3, c: 4 &#125;
在这个例子中,我们使用多个 Spread 操作符将 obj1 和 obj2 的属性合并到 mergedObj 中。当有重复的属性时,后面的对象的属性会覆盖前面对象的属性。3. 与解构赋值结合使用Spread 操作符也可以与对象解构赋值结合使用:
const originalObj = &#123; a: 1, b: 2, c: 3 &#125;;const &#123; a, ...rest &#125; = originalObj;console.log(a); // Output: 1console.log(rest); // Output: &#123; b: 2, c: 3 &#125;
在这个例子中,我们使用对象解构赋值提取 a 属性,并使用 Spread 操作符将剩余的属性赋值给 rest 对象。4. 浅拷贝和深拷贝需要注意的是,Spread 操作符只能进行浅拷贝,如果对象中嵌套了其他对象或数组,则需要使用其他方法实现深拷贝。
const originalObj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;const newObj = &#123; ...originalObj &#125;;console.log(newObj.b === originalObj.b); // Output: true (浅拷贝)
ES10-flat flatMap
flat()flat() 方法用于将嵌套数组”拉平”为一维数组。它接受一个可选的 depth 参数,指定要提取嵌套数组的深度。如果不传 depth 参数,默认深度为 1。

const nestedArray = [1, [2, 3], [4, [5, 6]]];console.log(nestedArray.flat()); // Output: [1, 2, 3, 4, [5, 6]]console.log(nestedArray.flat(2)); // Output: [1, 2, 3, 4, 5, 6]
在上面的例子中,第一个 flat() 调用将数组拉平一层,第二个调用将数组拉平两层。2. flatMap()flatMap() 是 map() 和 flat() 的组合。它首先使用提供的映射函数映射每个元素,然后将结果压缩成一个新数组。
const arr = [1, 2, 3, 4];const doubledAndFlattened = arr.flatMap(x =&gt; [x, x * 2]);console.log(doubledAndFlattened); // Output: [1, 2, 2, 4, 3, 6, 4, 8]
在上面的例子中,我们使用 flatMap() 将每个元素映射为一个包含原始值和其双倍值的数组,然后将这些数组压缩成一个新数组。flatMap() 的好处是,它可以在一步操作中完成映射和拉平操作,相比于先使用 map() 再使用 flat(),效率更高。
ES10-Object.fromEntries
Object.entries()Object.entries() 方法返回一个给定对象自身可枚举字符串属性 [key, value] 对组成的数组。

const obj = &#123; a: 1, b: 2, c: 3 &#125;;const entries = Object.entries(obj);console.log(entries); // Output: [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]]
这个方法在需要遍历对象属性时非常有用,比如使用 for...of 循环:
for (const [key, value] of Object.entries(obj)) &#123;  console.log(key, value);&#125;// Output:// a 1// b 2// c 3


Object.fromEntries()Object.fromEntries() 方法执行与 Object.entries() 逆向操作,将一个键值对列表转换为一个对象。

const entries = [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]];const obj = Object.fromEntries(entries);console.log(obj); // Output: &#123; a: 1, b: 2, c: 3 &#125;
这个方法在需要从其他数据结构(如 Map)转换为对象时非常有用:
const map = new Map([[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]]);const obj = Object.fromEntries(map);console.log(obj); // Output: &#123; a: 1, b: 2 &#125;
应用场景![[Pasted image 20240812145943.png]]
ES10-trimStart trimEndtrim(), trimStart() 和 trimEnd() 是 JavaScript 中用于删除字符串两端空白字符的三个方法。

trim()trim() 方法返回一个新的字符串,其中从字符串的两端删除了所有空白字符。

const str = &quot;   Hello, world!   &quot;;console.log(str.trim()); // Output: &quot;Hello, world!&quot;


trimStart()trimStart() 方法返回一个新的字符串,其中从字符串的开头删除了所有空白字符。

const str = &quot;   Hello, world!   &quot;;console.log(str.trimStart()); // Output: &quot;Hello, world!   &quot;


trimEnd()trimEnd() 方法返回一个新的字符串,其中从字符串的末尾删除了所有空白字符。

const str = &quot;   Hello, world!   &quot;;console.log(str.trimEnd()); // Output: &quot;   Hello, world!&quot;
这三个方法的主要区别在于它们删除空白字符的位置:

trim() 删除字符串两端的空白字符
trimStart() 删除字符串开头的空白字符
trimEnd() 删除字符串末尾的空白字符

ES11-BigInt要表示大于NUmber.MAX_SAFE_INTEGER的数值，需要在数值后面加上n![[Pasted image 20240812151216.png]]
ES11-Nullish Coalescing Operator (空值合并运算符)Nullish Coalescing Operator (空值合并运算符) 是 ECMAScript 2020 (ES11) 引入的一个新的运算符,它可以帮助我们处理 null 和 undefined 值。这个运算符的符号是 ??它的工作原理是:

如果左侧的操作数不是 null 或 undefined，则返回左侧的操作数。
如果左侧的操作数是 null 或 undefined，则返回右侧的操作数。下面是一些例子:

// 基本用法const username = &#x27;&#x27;;const displayName = username ?? &#x27;Guest&#x27;; // 输出: &#x27;Guest&#x27;const age = 0;const defaultAge = age ?? 30; // 输出: 0// 与逻辑OR (||) 运算符的比较const username2 = &#x27;&#x27;;const displayName2 = username2 || &#x27;Guest&#x27;; // 输出: &#x27;Guest&#x27;
在上面的例子中,当 username 为空字符串时,逻辑 OR (||) 运算符将返回 &#39;Guest&#39;。但是,空字符串在 JavaScript 中是一个有效的值,我们可能不希望将其视为”falsy”。这时,Nullish Coalescing Operator 就很有用,它只会在值为 null 或 undefined 时返回右侧操作数。
另一个常见的用例是设置默认值:
function greet(name) &#123;  const displayName = name ?? &#x27;Guest&#x27;;  console.log(`Hello, $&#123;displayName&#125;!`);&#125;greet(null); // 输出: &quot;Hello, Guest!&quot;greet(&#x27;&#x27;); // 输出: &quot;Hello, !&quot;greet(&#x27;John&#x27;); // 输出: &quot;Hello, John!&quot;
在这个例子中,如果 name 参数是 null 或 undefined，Nullish Coalescing Operator 会将 displayName 设置为 &#39;Guest&#39;。但如果 name 是一个空字符串,它仍然会被使用,因为空字符串不是 null 或 undefined。
ES11-Optional Chaining (可选链)Optional Chaining (可选链) 是 ECMAScript 2020 (ES11) 引入的一个新的运算符,用于安全地访问嵌套对象的属性。它的符号是 ?.Optional Chaining 可以帮助我们避免在访问嵌套对象属性时出现的 TypeError: Cannot read property &#39;x&#39; of undefined 错误。下面是一些例子:
// 不使用可选链let adventurer = &#123;  name: &#x27;Alice&#x27;,  cat: &#123;    name: &#x27;Dinah&#x27;  &#125;&#125;;console.log(adventurer.dog.name); // TypeError: Cannot read property &#x27;name&#x27; of undefined// 使用可选链let adventurer2 = &#123;  name: &#x27;Alice&#x27;,  cat: &#123;    name: &#x27;Dinah&#x27;  &#125;&#125;;console.log(adventurer2?.dog?.name); // undefined
在第一个例子中,尝试访问 adventurer.dog.name 会抛出 TypeError,因为 adventurer.dog 是 undefined。但在第二个例子中,使用 Optional Chaining 运算符 ?. 可以安全地访问嵌套属性。如果 adventurer2.dog 是 undefined,则整个表达式的结果也是 undefined,而不会抛出错误。
Optional Chaining 也可以与函数调用一起使用:
let customer = &#123;  name: &#x27;Carl&#x27;,  address: &#123;    city: &#x27;Seattle&#x27;  &#125;&#125;;console.log(customer.address.city); // &#x27;Seattle&#x27;console.log(customer.address?.city); // &#x27;Seattle&#x27;console.log(customer.address?.getZipCode?.());  // undefined
在最后一个例子中,即使 customer.address.getZipCode 不存在,使用 Optional Chaining 也不会抛出错误,而是返回 undefined。
ES12-FinalizationRegistryFinalizationRegistry 是 ECMAScript 2021 (ES12) 引入的一个新的 API,它允许在对象被垃圾回收时执行自定义的清理逻辑。FinalizationRegistry 的主要用途是:

监听对象的清理:当一个对象被垃圾回收时,FinalizationRegistry 会通知注册的回调函数。这可以用于执行清理操作,比如释放资源、发送通知等。
避免内存泄漏:FinalizationRegistry 可以帮助开发者避免内存泄漏,因为它可以确保在对象被销毁时执行清理逻辑。 示例:

// 创建FinalizationRegistry实例const registry = new FinalizationRegistry((value) =&gt; &#123;  console.log(`Finalized: $&#123;value&#125;`);&#125;);// 注册对象const obj = &#123; id: 1 &#125;;registry.register(obj, &#x27;object-1&#x27;);// 手动触发垃圾回收obj = null;global.gc(); // 在Node.js中手动触发// 输出: Finalized: object-1
在上述示例中:

我们创建了一个 FinalizationRegistry 实例,并传入一个回调函数,该函数将在对象被垃圾回收时被调用。
我们注册了一个对象 obj 到 FinalizationRegistry,并为其提供了一个标识符 &#39;object-1&#39;。
我们手动将 obj 设置为 null,然后调用 global.gc() 来触发垃圾回收(在 Node.js 中,需要使用 --expose-gc 标志来启用手动垃圾回收)。
当对象被垃圾回收时,FinalizationRegistry 会调用我们提供的回调函数,并输出 &#39;Finalized: object-1&#39;。FinalizationRegistry 的一个主要优点是,它不会阻止对象被垃圾回收。相反,它会在对象被回收后执行清理逻辑,这使得它比 WeakMap 和 WeakSet 更加灵活和强大。FinalizationRegistry 的典型用例包括:


清理 DOM 元素和事件监听器
关闭数据库连接或释放其他系统资源
发送对象销毁的通知

ES12-WeakRefsWeakRef 是 ECMAScript 2021 (ES12) 引入的一个新的 API,它允许创建对对象的”弱引用”。这意味着被引用的对象可以被垃圾回收器回收,即使还有 WeakRef 引用它。主要用途:

避免内存泄漏: 由于 WeakRef 不会妨碍对象被垃圾回收,因此可以帮助开发者避免内存泄漏的问题。
缓存模式: WeakRef 可以用于实现一种”缓存模式”,在需要时重新创建对象,而不是持有永久引用。
观察对象生命周期: WeakRef 可以用于观察对象的生命周期,并在对象被垃圾回收时执行相应的清理操作。示例:

// 创建一个对象const obj = &#123; id: 1 &#125;;// 创建一个 WeakRef 实例const weakRef = new WeakRef(obj);// 手动触发垃圾回收obj = null;global.gc(); // 在Node.js中手动触发// 尝试访问 WeakRef 持有的对象const refObj = weakRef.deref();if (refObj) &#123;  console.log(refObj.id); // 输出 1&#125; else &#123;  console.log(&#x27;Object has been garbage collected&#x27;);&#125;

我们创建了一个对象 obj。
我们使用 new WeakRef(obj) 创建了一个 WeakRef 实例,它持有对 obj 的引用。
我们手动将 obj 设置为 null,然后调用 global.gc() 来触发垃圾回收(在 Node.js 中,需要使用 --expose-gc 标志来启用手动垃圾回收)。
我们尝试使用 weakRef.deref() 方法访问 WeakRef 持有的对象。如果对象还存在,则输出 1。否则,输出 &#39;Object has been garbage collected&#39;。

WeakRef 的一个主要特点是,它不会阻止被引用的对象被垃圾回收。相反,一旦对象没有其他强引用,它就可以被垃圾回收,即使还有 WeakRef 引用它。这使得 WeakRef 非常适合于缓存模式和生命周期观察等用例WeakRef 通常与 FinalizationRegistry 配合使用,后者可以在对象被垃圾回收时执行清理逻辑。这种组合可以帮助开发者更好地管理内存和系统资源。
ES13-method.at()method.at() 是 ECMAScript 2022 (ES13) 引入的一个新的数组方法,它允许使用索引值访问数组元素,并且可以接受负值索引。特点:

支持负值索引: at() 方法可以接受负值索引,这意味着可以从数组末尾开始计数。例如, arr.at(-1) 返回数组的最后一个元素。
返回 undefined 而不是抛出错误: 如果使用无效的索引值(例如索引超出数组范围),at() 方法不会抛出错误,而是返回 undefined。
更简洁的语法: at() 方法提供了一种更简洁的语法来访问数组元素,相比于使用方括号语法 (arr[index]) 更加直观。示例:

const arr = [1, 2, 3, 4, 5];console.log(arr.at(2)); // 输出: 3console.log(arr.at(-1)); // 输出: 5console.log(arr.at(10)); // 输出: undefined
ES13-Object.hasOwn(obj, prop)Object.hasOwn() 是 ECMAScript 2022 (ES13) 引入的一个新的静态方法,它用于检查一个对象是否包含指定的属性。这个方法是 Object.prototype.hasOwnProperty() 方法的一种更简洁的替代方式。特点:

更简洁的语法: Object.hasOwn(obj, prop) 方法提供了一种更简洁的语法来检查对象是否包含指定的属性,相比于使用 obj.hasOwnProperty(prop) 更加简洁。   
更安全的属性检查: Object.hasOwn() 避免了原型污染问题,因为它直接在对象上检查属性,而不会受到原型链上的属性影响。这使得它更安全地用于检查对象属性。   
支持 null 和 undefined: 与 obj.hasOwnProperty(prop) 不同, Object.hasOwn() 可以接受 null 或 undefined 作为第一个参数,并在这种情况下返回 false。示例:

const obj = &#123; name: &#x27;John&#x27;, age: 30 &#125;;console.log(Object.hasOwn(obj, &#x27;name&#x27;)); // trueconsole.log(Object.hasOwn(obj, &#x27;address&#x27;)); // falseconsole.log(Object.hasOwn(null, &#x27;name&#x27;)); // falseconsole.log(Object.hasOwn(undefined, &#x27;name&#x27;)); // false
与 obj.hasOwnProperty(prop) 语法相比, Object.hasOwn() 的优势优势:

更简洁的语法,更容易阅读和理解。
避免了原型污染问题,更安全地检查对象属性。
可以处理 null 和 undefined 参数,返回 false。

Proxy-ReflectProxy基本使用
如果我们希望 监听一个对象的相关操作，那么我们可以 先创建一个代理对象（Proxy对象）
之后通过对代理对象的操作来监听我们想要对原对象进行的操作步骤：
首先需要 new Proxy对象，并且传入需要监听的对象以及一个处理对象，称之为handlerconst p = new Proxy(target, handler)
其次， 我们之后的操作都是直接对Proxy的操作，而不是原有的对象，因为我们需要在handler里

Proxy的捕获器如果想要监听某些具体的操作，就可以在handler中添加对应的 捕获器![[Pasted image 20240812213843.png]]

set函数有4个参数
target：目标对象（监听的对象）
property：将被设置的属性key
value：新属性值
receiver：调用的代理对象


get函数有3个参数
target：目标对象（监听的对象）
property：将被设置的属性key
receiver：调用的代理对象



&lt;script&gt;    const obj = &#123;      name: &quot;why&quot;,      age: 18,      height: 1.88    &#125;    const objProxy = new Proxy(obj, &#123;      set: function(target, key, value) &#123;        console.log(`属性$&#123;key&#125;被设置成$&#123;value&#125;`)        target[key] = value      &#125;,      get: function(target, key) &#123;        console.log(`属性$&#123;key&#125;被读取`)        return target[key] // 这里返回target[key]，可以让属性的读取操作正常进行      &#125;    &#125;)    objProxy.address = &quot;四川省&quot;    console.log(objProxy.address) // 四川省    objProxy.age = 20  &lt;/script&gt;
![[Pasted image 20240812215441.png]]
Reflect
作用：Reflect 是 JavaScript 中的一个内置对象,它提供了一组方法和属性,用于更好地反映和操作对象。相比于直接使用对象的属性和方法,Reflect 提供了一些额外的功能和便利。
与Object的区别： Reflect 与 Object 的方法名称很相似,但 Reflect 方法会返回操作结果,而 Object 方法则会返回操作对象本身。![[Pasted image 20240813000221.png]]
常见方法：


获取属性值:
Reflect.get(target, property[, receiver]): 获取对象 target 的属性 property 的值。


设置属性值:
Reflect.set(target, property, value[, receiver]): 设置对象 target 的属性 property 的值为 value。


删除属性:
Reflect.deleteProperty(target, property): 删除对象 target 的属性 property。


检查属性是否存在:
Reflect.has(target, property): 检查对象 target 是否拥有属性 property。


获取对象原型:
Reflect.getPrototypeOf(target): 获取对象 target 的原型。


设置对象原型:
Reflect.setPrototypeOf(target, prototype): 设置对象 target 的原型为 prototype


判断对象是否可扩展:
Reflect.isExtensible(target): 判断对象 target 是否可扩展。


冻结对象:
Reflect.preventExtensions(target): 让对象 target 变为不可扩展。


获取自身属性描述符:
Reflect.getOwnPropertyDescriptor(target, property): 获取对象 target 的属性 property 的描述符。


定义属性:
Reflect.defineProperty(target, property, descriptor): 在对象 target 上定义属性 property。


调用函数:
Reflect.apply(target, thisArgument, argumentsList): 使用给定的 this 值和参数列表调用目标函数。


使用 new 创建实例:
Reflect.construct(target, argumentsList[, newTarget]): 使用给定的构造函数 target 和参数列表创建一个新实例。![[Pasted image 20240813000437.png]]



&lt;script&gt;    const obj = &#123;      name: &quot;why&quot;,      age: 18,      get info() &#123;        return this.name      &#125;    &#125;    const objProxy = new Proxy(obj, &#123;      set(target, key, value, receiver) &#123;        // target[key] = value        // return true        // 好处1、代理对象的目的：不再直接操作原对象        // 好处2、Reflect.set()方法可以返回一个布尔值，表示是否设置成功        /* 好处3、          reciver === objProxy,就是外层的Proxy对象          Reflect.set/get最后一个参数receiver可以决定对象访问器的setter/getter的this指向        */        console.log(&quot;Proxy中的设置方法被调用&quot;)        const isSuccess = Reflect.set(target, key, value)        if(!isSuccess) &#123;          throw new Error(&quot;set failed&quot;)        &#125;      &#125;,      get(target, key, receiver) &#123;        console.log(&quot;Proxy中的获取方法被调用&quot;)        return Reflect.get(target, key, receiver)      &#125;    &#125;)    objProxy.name = &quot;kobe&quot;    console.log(objProxy.info)
Promise异步任务的处理
我们调用一个函数，这个函数中发送网络请求
如果 发送网络请求成功了，那么告知调用者发送成功，并且返回相关数据
如果 发送网络请求失败了，那么告知调用者发送失败，并且告知错误信息![[Pasted image 20240816165910.png]]

Promise的基本使用
Promise是一个类，当我们需要的时候，给予调用者一个承诺：待会儿回调函数的时候，就可以创建一个Promise对象
在通过new创建Promise对象时，我们需要传入一个回调函数，称为executor
这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject
调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数
调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数![[Pasted image 20240816172919.png]]



&lt;script&gt;    function execCode(counter) &#123;      // 异步处理      const promise = new Promise((resolve, reject) =&gt; &#123;        // 模拟异步处理        if(counter &gt; 0) &#123;          let total = 0          for(let i = 0; i &lt; counter; i++) &#123;            total += i          &#125;          resolve(total)        &#125; else &#123;          reject(`$&#123;counter&#125;输入错误`)        &#125;      &#125;)      return promise    &#125;    execCode(5).then(sucessed =&gt; &#123;      console.log(&quot;成功：&quot;, sucessed)    &#125;).catch(error =&gt; &#123;      console.log(&quot;失败：&quot;, error)    &#125;)    execCode(-5).then(sucessed =&gt; &#123;      console.log(&quot;成功：&quot;, sucessed)    &#125;).catch(error =&gt; &#123;      console.log(&quot;失败：&quot;, error)    &#125;)  &lt;/script&gt;
resolve不同值
传递普通值 new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;success&#x27;);&#125;).then(result =&gt; &#123;  console.log(result); // 输出: &#x27;success&#x27;&#125;).catch(error =&gt; &#123;  console.error(error);&#125;);

如果 resolve() 函数传递一个普通值,这个值会作为 Promise 的 resolve 结果被传递到后续的 .then() 方法中。


传递 Promise 对象 new Promise((resolve, reject) =&gt; &#123;  resolve(    new Promise((innerResolve, innerReject) =&gt; &#123;      setTimeout(() =&gt; &#123;        innerResolve(&#x27;inner promise result&#x27;);      &#125;, 2000);    &#125;)  );&#125;).then(result =&gt; &#123;  console.log(result); // 输出: &#x27;inner promise result&#x27;&#125;).catch(error =&gt; &#123;  console.error(error);&#125;);

如果 resolve() 函数传递的是另一个 Promise 对象,那么外层 Promise 的状态会跟随内层 Promise 的状态进行变化。
外层 Promise 会”等待”内层 Promise 完成,然后采用内层 Promise 的状态和结果。


传递 thenable 对象 const myThenable = &#123;  then(resolve, reject) &#123;    resolve(&#x27;thenable result&#x27;);  &#125;&#125;;new Promise((resolve, reject) =&gt; &#123;  resolve(myThenable);&#125;).then(result =&gt; &#123;  console.log(result); // 输出: &#x27;thenable result&#x27;&#125;).catch(error =&gt; &#123;  console.error(error);&#125;);

如果 resolve() 函数传递的是一个具有 .then() 方法的对象(称为 thenable 对象),那么 Promise 会”等待”这个对象执行完 .then() 方法,并采用其返回的结果。


传递 throw 或 reject() new Promise((resolve, reject) =&gt; &#123;  reject(new Error(&#x27;Something went wrong&#x27;));&#125;).then(result =&gt; &#123;  console.log(result);&#125;).catch(error =&gt; &#123;  console.error(error); // 输出: Error: Something went wrong&#125;);

如果在 Promise 执行器函数内部调用 throw 或 reject() 函数,那么 Promise 的状态会变为 rejected。
后续的 .catch() 方法会捕获到这个错误,并进行处理。



then的返回值Promise 的 then 方法的返回值是一个新的 Promise 对象。这个返回值可以用于实现链式调用。

关键点


成功回调的返回值:
如果在 then 的成功回调中返回一个值，这个值将作为下一个 then 的输入。
如果返回的是一个 Promise，下一个 then 将等待该 Promise 完成。


失败回调的返回值:
如果在 then 的失败回调中返回一个值，该值将被忽略，链中的下一个 then 将继续执行。
如果返回的是一个 Promise，同样会等待下一个 Promise 完成。




示例

const promise = new Promise((resolve, reject) =&gt; &#123;    resolve(42);&#125;);promise    .then(result =&gt; &#123;        console.log(result); // 输出: 42        return result + 1; // 返回 43    &#125;)    .then(result =&gt; &#123;        console.log(result); // 输出: 43        return Promise.resolve(result + 1); // 返回一个新的 Promise    &#125;)    .then(result =&gt; &#123;        console.log(result); // 输出: 44    &#125;);
catch的返回值Promise 的 catch 方法的返回值也会是一个新的 Promise 对象，具有和 then 方法相似的特性。具体来说，catch 主要用于处理链中的错误，但是它的返回值可以影响后续的链式调用。

关键点


处理错误并返回值:
如果 catch 处理了错误并返回一个值，这个值将作为后续链中下一个 then 的输入。


返回新 Promise:
如果在 catch 中返回一个 Promise，下一个 then 会等待这个 Promise 完成，然后将结果传递下去。




示例

const promise = new Promise((resolve, reject) =&gt; &#123;    reject(&#x27;出错了&#x27;);&#125;);promise    .then(result =&gt; &#123;        console.log(result); // 不会执行    &#125;)    .catch(error =&gt; &#123;        console.error(error); // 输出: 出错了        return &#x27;处理完毕&#x27;; // 返回一个字符串    &#125;)    .then(result =&gt; &#123;        console.log(result); // 输出: 处理完毕    &#125;);

如果我们希望后续继续执行catch，那么需要抛出一个异常![[Pasted image 20240816202837.png]]

finally的回调Promise 的 finally 方法用于在 Promise 操作结束后执行一个回调函数，无论是成功还是失败。这使得 finally 非常适合用于清理或执行一些始终需要进行的操作，比如关闭文件、清理资源等。

特点


不影响链的结果:
finally 的回调不会接收 Promise 的结果或错误。
无论前面的 then 或 catch 是否成功，finally 始终会执行。


返回值:
finally 返回一个新的 Promise，其解析方式与前面的 Promise 一致。
如果在 finally 中返回一个值或 Promise，将不会影响前面 then 或 catch 的结果。




示例

const promise = new Promise((resolve, reject) =&gt; &#123;    const success = true; // 模拟操作成功或失败    if (success) &#123;        resolve(&#x27;成功&#x27;);    &#125; else &#123;        reject(&#x27;失败&#x27;);    &#125;&#125;);promise    .then(result =&gt; &#123;        console.log(result); // 输出: 成功    &#125;)    .catch(error =&gt; &#123;        console.error(error); // 不会执行    &#125;)    .finally(() =&gt; &#123;        console.log(&#x27;清理操作&#x27;); // 输出: 清理操作    &#125;);
Promise类方法Promise 的类方法提供了用于创建和操作 Promise 实例的多种功能。以下是主要的 Promise 类方法及其描述：
1. Promise.resolve(value)
功能: 返回一个以给定值解析后的 Promise 对象。
示例:

const promise1 = Promise.resolve(42);promise1.then(value =&gt; console.log(value)); // 输出: 42

2. Promise.reject(reason)
功能: 返回一个以给定原因拒绝后的 Promise 对象。
示例:

const promise2 = Promise.reject(&#x27;出错了&#x27;);promise2.catch(error =&gt; console.error(error)); // 输出: 出错了
3. Promise.all(iterable)
功能: 接受一个可迭代对象（如数组），当所有 Promise 都已成功时，返回一个新的 Promise，并解析为一个数组，包含所有 Promise 的结果。如果其中任何一个 Promise 被拒绝，它将立即返回拒绝状态。
示例:

const promise3 = Promise.all([    Promise.resolve(1),    Promise.resolve(2),    Promise.resolve(3)]);promise3.then(values =&gt; &#123;    console.log(values); // 输出: [1, 2, 3]&#125;);

4. Promise.allSettled(iterable)
功能: 接受一个可迭代对象，返回一个新的 Promise，当所有 Promise 的状态都已确定时（不论成功还是失败），以数组的形式解析，数组中的每个对象描述了每个 Promise 的结果。
示例:

const promise4 = Promise.allSettled([    Promise.resolve(1),    Promise.reject(&#x27;失败&#x27;),    Promise.resolve(3)]);promise4.then(results =&gt; &#123;    console.log(results);    // 输出: [    //   &#123; status: &#x27;fulfilled&#x27;, value: 1 &#125;,    //   &#123; status: &#x27;rejected&#x27;, reason: &#x27;失败&#x27; &#125;,    //   &#123; status: &#x27;fulfilled&#x27;, value: 3 &#125;    // ]&#125;);

5. Promise.any(iterable)
功能: 接受一个可迭代对象，返回一个新的 Promise。只要有一个 Promise 成功，它就会解析为那个成功的值。如果所有 Promise 都被拒绝，则返回一个拒绝的 Promise，其理由是一个 AggregateError。
示例:

const promise5 = Promise.any([    Promise.reject(&#x27;失败1&#x27;),    Promise.resolve(3),    Promise.reject(&#x27;失败2&#x27;)]);promise5.then(value =&gt; &#123;    console.log(value); // 输出: 3&#125;);

6. Promise.race(iterable)
功能: 接受一个可迭代对象，返回一个新的 Promise，只要有一个 Promise 完成或被拒绝，返回的 Promise 就会返回这个完成或被拒绝的值。
示例:

const promise6 = Promise.race([    new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&#x27;快速完成&#x27;), 100)),    new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&#x27;慢完成&#x27;), 200))]);promise6.then(value =&gt; &#123;    console.log(value); // 输出: 快速完成&#125;);
迭代器和生成器什么是迭代器![[Pasted image 20240816214845.png]]![[Pasted image 20240816214905.png]]![[Pasted image 20240817154234.png]]
自定义可迭代对象![[Pasted image 20240817155356.png]]
可迭代对象的应用![[Pasted image 20240817162522.png]]
什么是生成器![[Pasted image 20240817191031.png]]
生成器函数参数返回值
在中间位置直接return

function* generatorFunction() &#123;    yield 1;    yield 2;    return &#x27;结束&#x27;; // 在这里返回，终止生成器    yield 3; // 此行不会被执行&#125;const gen = generatorFunction();console.log(gen.next()); // 输出: &#123; value: 1, done: false &#125;console.log(gen.next()); // 输出: &#123; value: 2, done: false &#125;console.log(gen.next()); // 输出: &#123; value: &#x27;结束&#x27;, done: true &#125;console.log(gen.next()); // 输出: &#123; value: undefined, done: true &#125;

给函数每次执行的时候传入参数

&lt;script&gt;    function* foo(name1) &#123;      console.log(&#x27;内部：111&#x27;);      console.log(&#x27;内部：222&#x27;);      const name2 = yield &quot;aaaa&quot;      console.log(&#x27;内部：333&#x27;);      console.log(&#x27;内部：444&#x27;);      const name3 = yield &quot;bbbb&quot;      console.log(&#x27;内部：555&#x27;);       console.log(&#x27;内部：666&#x27;);      yield &quot;cccc&quot;      return undefined    &#125;    const bar = foo(&quot;next1&quot;)    console.log(bar.next()) // &#123;value: &quot;aaaa&quot;, done: false&#125;    console.log(bar.next(&quot;next2&quot;)) // &#123;value: &quot;bbbb&quot;, done: false&#125;    console.log(bar.next(&quot;next3&quot;)) // &#123;value: &quot;cccc&quot;, done: true&#125;  &lt;/script&gt;
生成器函数提前结束

使用 return 语句



function* generatorFunction() &#123;    yield 1;    yield 2;    return &#x27;结束&#x27;; // 提前结束    yield 3; // 不会被执行&#125;const gen = generatorFunction();console.log(gen.next()); // 输出: &#123; value: 1, done: false &#125;console.log(gen.next()); // 输出: &#123; value: 2, done: false &#125;console.log(gen.next()); // 输出: &#123; value: &#x27;结束&#x27;, done: true &#125;console.log(gen.next()); // 输出: &#123; value: undefined, done: true &#125;



使用 throw 语句



function* generatorFunction() &#123;    try &#123;        yield 1;        yield 2;    &#125; catch (e) &#123;        console.log(e); // 捕获错误    &#125;    yield 3; // 如果被抛出错误，将不会执行&#125;const gen = generatorFunction();console.log(gen.next()); // 输出: &#123; value: 1, done: false &#125;console.log(gen.next()); // 输出: &#123; value: 2, done: false &#125;gen.throw(&#x27;捕获错误&#x27;); // 输出: 捕获错误console.log(gen.next()); // 输出: &#123; value: undefined, done: true &#125;



使用 return 结合 next()



function* generatorFunction() &#123;    yield 1;    yield 2;&#125;const gen = generatorFunction();console.log(gen.next()); // 输出: &#123; value: 1, done: false &#125;console.log(gen.return(&#x27;提前结束&#x27;)); // 输出: &#123; value: &#x27;提前结束&#x27;, done: true &#125;console.log(gen.next()); // 输出: &#123; value: undefined, done: true &#125;
生成器替代迭代器&lt;script&gt;    function* foo(start, end) &#123;      for(let i = start; i &lt;= end; i++) &#123;        yield i      &#125;    &#125;    const gen = foo(1, 10)    console.log(gen.next().value)    console.log(gen.next())    console.log(gen.next())    console.log(gen.next())    console.log(gen.next())    console.log(gen.next())    console.log(gen.next())    console.log(gen.next())    console.log(gen.next())    console.log(gen.next())    const names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;, &#x27;David&#x27;]    function* nameGenerator() &#123;      yield* names    &#125;    const nameGen = nameGenerator()    console.log(nameGen.next().value)    console.log(nameGen.next().value)    console.log(nameGen.next().value)    console.log(nameGen.next().value)  &lt;/script&gt;
异步处理方案&lt;script&gt;   /*     需求：     1、发送一次网络请求，等到这次网络请求的结果     2、再发送一次网络请求，并将这次网络请求的结果作为参数，再次发送网络请求     3、再次发送网络请求，并将这次网络请求的结果作为参数，再次发送网络请求     4、最后一次的网络请求的结果作为最终结果   */   // 异步请求代码结构   function requestData(url) &#123;     return new Promise((resolve, reject) =&gt; &#123;       setTimeout(() =&gt; &#123;         resolve(url)       &#125;, 2000);     &#125;)   &#125;   // 方法一：回调地域   // function getData() &#123;   //   requestData(&quot;why&quot;).then(res1 =&gt; &#123;   //     console.log(&quot;第一次结果：&quot;, res1)   //     requestData(res1 + &quot;aaa&quot;).then(res2 =&gt; &#123;   //       console.log(&quot;第二次结果：&quot;, res2)   //       requestData(res2 + &quot;bbb&quot;).then(res3 =&gt; &#123;   //         console.log(&quot;第三次结果：&quot;, res3)   //       &#125;)   //     &#125;)   //   &#125;)   // &#125;   // 方法二：使用Promise进行重构（解决回调地狱）   // function getData() &#123;   //   requestData(&quot;why&quot;).then(res1 =&gt; &#123;   //     console.log(&quot;第一次结果：&quot;, res1)   //     return requestData(res1 + &quot;aaa&quot;)   //   &#125;).then(res2 =&gt; &#123;   //     console.log(&quot;第二次结果：&quot;, res2)   //     return requestData(res2 + &quot;bbb&quot;)   //   &#125;).then(res3 =&gt; &#123;   //     console.log(&quot;第三次结果：&quot;, res3)   //     requestData(res3 + &quot;ccc&quot;)   //   &#125;)   // &#125;   // 方法三：使用生成器进行重构   // function* getData() &#123;   //   const res1 = yield requestData(&quot;why&quot;)   //   console.log(&quot;第一次结果：&quot;, res1)   //   const res2 = yield requestData(res1 + &quot;aaa&quot;)   //   console.log(&quot;第二次结果：&quot;, res2)   //   const res3 = yield requestData(res2 + &quot;bbb&quot;)   //   console.log(&quot;第三次结果：&quot;, res3)   // &#125;   // const gen = getData()   // gen.next().value.then(res1 =&gt; &#123;   //   gen.next(res1).value.then(res2 =&gt; &#123;   //     gen.next(res2).value.then(res3 =&gt; &#123;   //       gen.next(res3)   //     &#125;)   //   &#125;)   // &#125;)   // 方法四：使用async/await进行重构     async function getData() &#123;       const res1 = await requestData(&quot;why&quot;)       console.log(&quot;第一次结果：&quot;, res1)       const res2 = await requestData(res1 + &quot;aaa&quot;)       console.log(&quot;第二次结果：&quot;, res2)       const res3 = await requestData(res2 + &quot;bbb&quot;)       console.log(&quot;第三次结果：&quot;, res3)     &#125;   getData() &lt;/script&gt;
async、await - 队列异步函数async function


await关键字![[Pasted image 20240819154154.png]]处理异步请求
&lt;script&gt;    function requestData() &#123;      return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;          reject(&quot;error message&quot;)      &#125;, 2000);    &#125;)  &#125;  async function getData() &#123;    const res1 = await requestData(&quot;why&quot;)    console.log(res1)    const res2 = await requestData(&quot;how&quot;)    console.log(res2)  &#125;  getData().catch(err =&gt; &#123;    console.log(err)  &#125;)  &lt;/script&gt;
进程和线程![[Pasted image 20240819193235.png]]
浏览器中的JavaScript线程![[Pasted image 20240819205046.png]]
浏览器的事件循环![[Pasted image 20240819205801.png]]
微任务和宏任务![[Pasted image 20240819210919.png]]
Promise面试题1&lt;script&gt;    console.log(&quot;script start&quot;)    setTimeout(function () &#123;      console.log(&quot;setTimeout1&quot;)      new Promise(function (resolve) &#123;        resolve()      &#125;).then(function () &#123;        new Promise(function (resolve) &#123;          resolve()        &#125;).then(function () &#123;          console.log(&quot;then4&quot;)        &#125;)        console.log(&quot;then2&quot;)      &#125;)    &#125;)        new Promise(function (resolve) &#123;      console.log(&quot;promise1&quot;)      resolve()    &#125;).then(function () &#123;      console.log(&quot;then1&quot;)    &#125;)    setTimeout(function () &#123;      console.log(&quot;setTimeout2&quot;)    &#125;)    console.log(2)    queueMicrotask(() =&gt; &#123;      console.log(&quot;queueMicrotask1&quot;)    &#125;)    new Promise(function (resolve) &#123;      resolve()    &#125;).then(function () &#123;      console.log(&quot;then3&quot;)    &#125;)    console.log(&quot;script end&quot;)    /*     代码执行顺序：      script start      promise1      2      script end      then1      queueMicrotask1      then3      setTimeout1      then2      then4      setTimeout2    */  &lt;/script&gt;
2&lt;script&gt;    async function async1 () &#123;      console.log(&#x27;async1 start&#x27;)      await async2()      console.log(&#x27;async1 end&#x27;)    &#125;    async function async2 () &#123;      console.log(&quot;async2&quot;)    &#125;    console.log(&#x27;script start&#x27;)    setTimeout(function () &#123;      console.log(&#x27;setTimeout&#x27;)    &#125;, 0)    async1()    new Promise (function (resolve) &#123;      console.log(&#x27;promise1&#x27;)      resolve()    &#125;).then(function () &#123;      console.log(&#x27;promise2&#x27;)    &#125;)    console.log(&#x27;script end&#x27;)    /*      代码执行顺序：      script start      async1 start      async2      promise1      script end      async1 end      promise2      setTimeout    */  &lt;/script&gt;
异常处理throw关键字![[Pasted image 20240820191231.png]]
Error类型![[Pasted image 20240820191257.png]]![[Pasted image 20240820191347.png]]
异常的捕获![[Pasted image 20240820191801.png]]
Storage和正则表达式认识Storage![[Pasted image 20240821160128.png]]
Storage的基本使用&lt;script&gt;    // token操作    let token = localStorage.getItem(&quot;token&quot;)    if(!token) &#123;      console.log(&quot;从服务器获取token&quot;)      token = &quot;aaaaaaaaa&quot;      localStorage.setItem(&quot;token&quot;, token)    &#125;    // 用户名和密码操作    let username = localStorage.getItem(&quot;username&quot;)    let password = localStorage.getItem(&quot;password&quot;)    if(!username || !password) &#123;      console.log(&quot;从服务器获取用户名和密码&quot;)      username = &quot;admin&quot;      password = &quot;123456&quot;      localStorage.setItem(&quot;username&quot;, username)      localStorage.setItem(&quot;password&quot;, password)    &#125;    console.log(token)  &lt;/script&gt;
localStorage和sessionStorage的区别![[Pasted image 20240821160903.png]]
Storage工具封装class Cache &#123;  constructor(isLoacl = true) &#123;    this.storage = isLocal ? localStorage : sessionStorage  &#125;  setCache(key, value) &#123;    if(!value) &#123;      throw new Error(&quot;value error: value 必须有值&quot;)    &#125;    if(value) &#123;      this.storage.setItem(key, JSON.stringify(value))    &#125;  &#125;  getCache(key) &#123;    const res = this.storage.getItem(key)    if (res) &#123;      return JSON.parse(res)    &#125;  &#125;  removeCache(key) &#123;    this.storage.removeItem(key)  &#125;  clear() &#123;    this.storage.clear()  &#125;&#125;const localCache = new Cache(true)const sessionCache = new Cache(false)
正则表达式
使用单个字符串来描述、匹配一系列句法规则的字符串，是一种字符串匹配利器，可以帮助我们搜索、获取、替代字符串
正则表达式主要由两部分组成：模式和修饰符![[Pasted image 20240821170906.png]]

正则表达式的使用方法
JavaScript的正则表达式被用于RegExp的exec和test方法，String的match、matchAll、replace、search、split方法![[Pasted image 20240821172016.png]]![[Pasted image 20240821173022.png]] ![[Pasted image 20240821173046.png]]

修饰符flag的使用![[Pasted image 20240821173451.png]]
正则表达式规则字符类![[Pasted image 20240821174044.png]]
锚点![[Pasted image 20240821182149.png]]
转义![[Pasted image 20240821193427.png]]
集合![[Pasted image 20240821193816.png]]
量词![[Pasted image 20240821195144.png]]![[Pasted image 20240821195046.png]]
贪婪和惰性![[Pasted image 20240821200334.png]]![[Pasted image 20240821200355.png]]
捕获组![[Pasted image 20240821201218.png]]![[Pasted image 20240821201443.png]]![[Pasted image 20240821201509.png]]
正则练习-歌词解析![[Pasted image 20240822152859.png]]
function parseLyric(lyricstring) &#123;  // 根据\n切割字符串  const lyricLineStrings = lyricstring.split(&quot;\n&quot;)  // console.log(lyricLineStrings)  // 根据每一行歌词进行解析  const timeRe = /\[(\d&#123;2&#125;):(\d&#123;2&#125;)\.(\d&#123;2,3&#125;)\]/i  const lyricInfos = []  for (const lineString of lyricLineStrings) &#123;    // 获取时间    const result = lineString.match(timeRe)    if(!result) continue    const minuteTime = result[1] * 60 * 1000    const secondTime = result[2] * 1000    const millisecondTime = result[3].length === 3? result[3] : result[3] * 10    const time = minuteTime + secondTime + millisecondTime    // 获取歌词    const content = lineString.replace(timeRe, &quot;&quot;).trim()    // 保存歌词信息    lyricInfos.push(&#123;      time,      content     &#125;)  &#125;    return lyricInfos&#125;
正则练习-时间格式化![[Pasted image 20240822161914.png]]
&lt;h2 class=&quot;time&quot;&gt;&lt;/h2&gt;  &lt;script&gt;    function formatTime(timestamp, fmtString) &#123;      // 将时间戳转化为Date      const date = new Date(timestamp)      // 将正则和值匹配      const dateO = &#123;        &quot;y+&quot;: date.getFullYear(),        &quot;M+&quot;: date.getMonth() + 1,        &quot;d+&quot;: date.getDate(),        &quot;h+&quot;: date.getHours(),        &quot;m+&quot;: date.getMinutes(),        &quot;s+&quot;: date.getSeconds(),      &#125;      for (const key in dateO) &#123;        const keyRe = new RegExp(key) // 构造正则表达式        // 如果正则表达式匹配到fmtString中，则替换        if(keyRe.test(fmtString)) &#123;          const value = (dateO[key] + &quot;&quot;).padStart(2, &quot;0&quot;) // 补零          fmtString = fmtString.replace(keyRe, value) // 替换        &#125;      &#125;      return fmtString    &#125;    const timeEl = document.querySelector(&#x27;.time&#x27;)    const productJSON = &#123;      name : &quot;iphone&quot;,      newPrice : 10000,      oldPrice : 8000,      endTime : 1659252290626     &#125;    timeEl.textContent = formatTime(productJSON.endTime, &quot;yyyy/MM/dd hh:mm:ss&quot;)  &lt;/script&gt;
防抖、节流、深拷贝、事件总线防抖函数认识防抖debounce函数![[Pasted image 20240822171403.png]]
手动实现防抖函数
基本实现

&lt;script&gt;    function yy_debounce(fn, delay) &#123;      let timer = null      const _debounce = () =&gt; &#123;        if(timer) clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;          fn()          timer = null        &#125;, delay)      &#125;      return _debounce    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&quot;input&quot;)    let cnt = 1    inputEl.oninput = yy_debounce(function() &#123;      console.log(`第$&#123;cnt++&#125;次输入`)    &#125;, 1000)  &lt;/script&gt;

绑定this

&lt;script&gt;    function yy_debounce(fn, delay) &#123;      let timer = null      const _debounce = function(...args) &#123;        if(timer) clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;          fn.apply(this, args) //这里的this绑定到inputEl          timer = null        &#125;, delay)      &#125;      return _debounce    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&quot;input&quot;)    let cnt = 1    inputEl.oninput = yy_debounce(function() &#123;      console.log(`第$&#123;cnt++&#125;次输入`)    &#125;, 1000)  &lt;/script&gt;

实现取消功能

&lt;script&gt;    function yy_debounce(fn, delay) &#123;      // 用于记录上一次事件触发的timer      let timer = null      // 触发事件时执行的函数      const _debounce = function(...args) &#123;        // 如果有再次触发事件，那么取消上一次的事件        if(timer) clearTimeout(timer)        // 延迟去执行对应 fn函数        timer = setTimeout(() =&gt; &#123;          fn.apply(this, args) //这里的this绑定到inputEl          timer = null        &#125;, delay)      &#125;      // 给_debounce添加一个cancel方法，用于取消防抖      _debounce.cancel = function() &#123;        if(timer) clearTimeout(timer)      &#125;      return _debounce    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&quot;input&quot;)    let cnt = 1    inputEl.oninput = yy_debounce(function(event) &#123;      console.log(`第$&#123;cnt++&#125;次输入`)    &#125;, 1000)  &lt;/script&gt;

立即执行功能

&lt;script&gt;    function yy_debounce(fn, delay, immediate = true) &#123;      // 用于记录上一次事件触发的timer      let timer = null      let isInvoke = false // 是否立即执行      // 触发事件时执行的函数      const _debounce = function(...args) &#123;        // 如果有再次触发事件，那么取消上一次的事件        if(timer) clearTimeout(timer)        // 如果是立即执行，那么立即执行对应 fn函数        if(immediate &amp;&amp; !isInvoke) &#123;          fn.apply(this, args)          isInvoke = true          return        &#125;        // 延迟去执行对应 fn函数        timer = setTimeout(() =&gt; &#123;          fn.apply(this, args) //这里的this绑定到inputEl          // 重置timer和isInvoke          timer = null          isInvoke = false        &#125;, delay)      &#125;      // 给_debounce添加一个cancel方法，用于取消防抖      _debounce.cancel = function() &#123;        if(timer) clearTimeout(timer)        // 重置timer和isInvoke        timer = null        isInvoke = false      &#125;      return _debounce    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&quot;input&quot;)    let cnt = 1    inputEl.oninput = yy_debounce(function(event) &#123;      console.log(`第$&#123;cnt++&#125;次输入:`, this, event)    &#125;, 1000)  &lt;/script&gt;

获取返回值

&lt;script&gt;    function yy_debounce(fn, delay, immediate = true, resultCallback) &#123;      // 用于记录上一次事件触发的timer      let timer = null      let isInvoke = false // 是否立即执行      // 触发事件时执行的函数      const _debounce = function(...args) &#123;        return new Promise((resolve, reject) =&gt; &#123;          try &#123;                // 如果有再次触发事件，那么取消上一次的事件                if(timer) clearTimeout(timer)                let res = undefined                // 如果是立即执行，那么立即执行对应 fn函数                if(immediate &amp;&amp; !isInvoke) &#123;                  res = fn.apply(this, args)                  if (resultCallback) resultCallback(res)                  resolve(res)                  isInvoke = true                  return                &#125;                // 延迟去执行对应 fn函数                timer = setTimeout(() =&gt; &#123;                  res = fn.apply(this, args) //这里的this绑定到inputEl                  if (resultCallback) resultCallback(res)                  resolve(res)                  // 重置timer和isInvoke                  timer = null                  isInvoke = false                &#125;, delay);              &#125; catch (error) &#123;                reject(error)              &#125;            &#125;)          &#125;          // 给_debounce添加一个cancel方法，用于取消防抖        _debounce.cancel = function() &#123;            if(timer) clearTimeout(timer)            // 重置timer和isInvoke            timer = null             isInvoke = false        &#125;      return _debounce    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&quot;input&quot;)    const myDebounce = yy_debounce(function(name, age, height) &#123;      console.log(`name: $&#123;name&#125;, age: $&#123;age&#125;, height: $&#123;height&#125;`)      return &quot;jojo&quot;    &#125;, 1000, false)    myDebounce(&quot;jojo&quot;, 20, 1.80).then(res =&gt; &#123;      console.log(res)    &#125;)  &lt;/script&gt;
可以用underscore库
节流函数认识节流throttle函数![[Pasted image 20240825101157.png]]
手动实现节流函数
实现思路![[Pasted image 20240825103812.png]]
基本实现

&lt;script&gt;    function yy_throttle(fn, interval) &#123;      let startTime = 0      const _throttle = function() &#123;        const noeTime = new Date().getTime()        const waitTime = interval - (noeTime - startTime)        if(waitTime &lt;= 0) &#123;          fn()          startTime = noeTime        &#125;      &#125;      return _throttle    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&#x27;input&#x27;)    inputEl.oninput = yy_throttle(function() &#123;      console.log(&#x27;input&#x27;)    &#125;, 1000)  &lt;/script&gt;

this绑定

&lt;script&gt;    function yy_throttle(fn, interval) &#123;      let startTime = 0      const _throttle = function(...args) &#123;        const noeTime = new Date().getTime()        const waitTime = interval - (noeTime - startTime)        if(waitTime &lt;= 0) &#123;          fn.apply(this, args)          startTime = noeTime        &#125;      &#125;      return _throttle    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&#x27;input&#x27;)    inputEl.oninput = yy_throttle(function(event) &#123;      console.log(&#x27;input:&#x27;,this.value, event)    &#125;, 1000)  &lt;/script&gt;

控制立即执行

&lt;script&gt;    function yy_throttle(fn, interval, leading = false) &#123;      let startTime = 0      const _throttle = function(...args) &#123;        // 获取当前时间        const nowTime = new Date().getTime()        // 对立即执行函数进行控制        if(!leading &amp;&amp; startTime === 0) &#123;          startTime = nowTime        &#125;        const waitTime = interval - (nowTime - startTime)        if(waitTime &lt;= 0) &#123;          fn.apply(this, args)          startTime = nowTime        &#125;      &#125;      return _throttle    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&#x27;input&#x27;)    inputEl.oninput = yy_throttle(function(event) &#123;      console.log(&#x27;input:&#x27;,this.value, event)    &#125;, 1000)  &lt;/script&gt;

尾部执行控制

&lt;script&gt;    function yy_throttle(fn, interval, &#123;leading = false, trailing = true&#125; = &#123;&#125;) &#123;      let startTime = 0      let timer = null      const _throttle = function(...args) &#123;        // 获取当前时间        const nowTime = new Date().getTime()        // 对立即执行函数进行控制        if(!leading &amp;&amp; startTime === 0) &#123;          startTime = nowTime        &#125;        const waitTime = interval - (nowTime - startTime)        if(waitTime &lt;= 0) &#123;          if (timer) clearTimeout(timer)          fn.apply(this, args)          startTime = nowTime          timer = null          return        &#125;        // 节流函数尾部执行控制        if (trailing &amp;&amp; !timer) &#123;          timer = setTimeout(() =&gt; &#123;            fn.apply(this, args)            startTime = new Date().getTime()            timer = null          &#125;, waitTime)        &#125;      &#125;      return _throttle    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&#x27;input&#x27;)    inputEl.oninput = yy_throttle(function(event) &#123;      console.log(&#x27;input:&#x27;,this.value, event)    &#125;, 1000, &#123;trailing: true&#125;)  &lt;/script&gt;

取消尾部功能

&lt;script&gt;    function yy_throttle(fn, interval, &#123;leading = false, trailing = true&#125; = &#123;&#125;) &#123;      let startTime = 0      let timer = null      const _throttle = function(...args) &#123;        // 获取当前时间        const nowTime = new Date().getTime()        // 对立即执行函数进行控制        if(!leading &amp;&amp; startTime === 0) &#123;          startTime = nowTime        &#125;        const waitTime = interval - (nowTime - startTime)        if(waitTime &lt;= 0) &#123;          if (timer) clearTimeout(timer)          fn.apply(this, args)          startTime = nowTime          timer = null          return        &#125;        // 节流函数尾部执行控制        if (trailing &amp;&amp; !timer) &#123;          timer = setTimeout(() =&gt; &#123;            fn.apply(this, args)            startTime = new Date().getTime()            timer = null          &#125;, waitTime)        &#125;      &#125;      _throttle.cancel = function() &#123;        if(timer) clearTimeout(timer)        startTime = 0        timer = null      &#125;      return _throttle    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&#x27;input&#x27;)    const buttonEl = document.querySelector(&#x27;button&#x27;)    inputEl.oninput = yy_throttle(function(event) &#123;      console.log(&#x27;input:&#x27;,this.value, event)    &#125;, 1000, &#123;trailing: true&#125;)        buttonEl.onclick = function() &#123;      inputEl.oninput.cancel()    &#125;  &lt;/script&gt;

获取返回值

&lt;script&gt;    function yy_throttle(fn, interval, &#123;leading = false, trailing = true&#125; = &#123;&#125;) &#123;      let startTime = 0      let timer = null      const _throttle = function(...args) &#123;        // 获取当前时间        return new Promise((resolve, reject) =&gt; &#123;          try &#123;            const nowTime = new Date().getTime()            // 对立即执行函数进行控制            if(!leading &amp;&amp; startTime === 0) &#123;              startTime = nowTime            &#125;            const waitTime = interval - (nowTime - startTime)            if(waitTime &lt;= 0) &#123;              if (timer) clearTimeout(timer)              const res = fn.apply(this, args)              resolve(res)              startTime = nowTime              timer = null              return            &#125;            // 节流函数尾部执行控制            if (trailing &amp;&amp; !timer) &#123;              timer = setTimeout(() =&gt; &#123;                const res = fn.apply(this, args)                resolve(res)                startTime = new Date().getTime()                timer = null              &#125;, waitTime);            &#125;          &#125;          catch (error) &#123;            reject(error)          &#125;        &#125;)      &#125;      _throttle.cancel = function() &#123;        if(timer) clearTimeout(timer)        startTime = 0        timer = null      &#125;      return _throttle    &#125;  &lt;/script&gt;  &lt;script&gt;    const inputEl = document.querySelector(&#x27;input&#x27;)    const buttonEl = document.querySelector(&#x27;button&#x27;)    inputEl.oninput = yy_throttle(function(event) &#123;      console.log(&#x27;input:&#x27;,this.value, event)      return &quot;jojo&quot;    &#125;, 1000, &#123;trailing: true&#125;)        buttonEl.onclick = function() &#123;      inputEl.oninput.cancel()    &#125;  &lt;/script&gt;
深拷贝
深拷贝函数的基本使用

&lt;script&gt;    function isObject(obj) &#123;      const objType = typeof obj      return (obj !== null) &amp;&amp; (objType === &quot;object&quot; || objType === &quot;function&quot;)    &#125;    // 深拷贝函数    function deepCopy(obj) &#123;      if(!isObject(obj)) &#123;        return obj      &#125;      const newObj = &#123;&#125;      for (const key in obj) &#123;        newObj[key] = deepCopy(obj[key])      &#125;      return newObj    &#125;    const info = &#123;      name: &quot;jojo&quot;,      age: 20,      friend: &#123;        name: &quot;小羊&quot;,        age: 19,        address: &#123;          name: &quot;四川&quot;,          detail: &quot;成都市&quot;        &#125;      &#125;    &#125;    const newObj = deepCopy(info)    console.log(newObj)  &lt;/script&gt;

区分数组与对象

&lt;script&gt;    function isObject(obj) &#123;      const objType = typeof obj      return (obj !== null) &amp;&amp; (objType === &quot;object&quot; || objType === &quot;function&quot;)    &#125;    // 深拷贝函数    function deepCopy(obj) &#123;      if(!isObject(obj)) &#123;        return obj      &#125;      const newObj = Array.isArray(obj) ? [] : &#123;&#125;      for (const key in obj) &#123;        newObj[key] = deepCopy(obj[key])      &#125;      return newObj    &#125;    const info = &#123;      name: &quot;jojo&quot;,      age: 20,      friend: &#123;        name: &quot;小羊&quot;,        age: 19,        address: &#123;          name: &quot;四川&quot;,          detail: &quot;成都市&quot;        &#125;,        cnt: [1, 2, 3]      &#125;    &#125;    const newObj = deepCopy(info)    console.log(newObj)  &lt;/script&gt;

其他类型处理

&lt;script&gt;    function isObject(obj) &#123;      const objType = typeof obj      return (obj !== null) &amp;&amp; (objType === &quot;object&quot; || objType === &quot;function&quot;)    &#125;    // 深拷贝函数    function deepCopy(obj) &#123;      // symbol类型      if (typeof obj === &quot;symbol&quot;) &#123;        return Symbol(obj.description)      &#125;      if(!isObject(obj)) &#123;        return obj      &#125;      // set类型      if(obj instanceof Set) &#123;        const newSet = new Set()        for(const setItem of obj) &#123;          newSet.add(deepCopy(setItem))        &#125;        return newSet      &#125;      // function类型,不需要深拷贝      if(typeof obj === &quot;function&quot;) &#123;        return obj      &#125;      // key为symbol类型      const symbolKeys = Object.getOwnPropertySymbols(obj)      for(const symbolKey of symbolKeys) &#123;        obj[symbolKey] = deepCopy(obj[symbolKey])      &#125;      // 如果是对象类型      const newObj = Array.isArray(obj) ? [] : &#123;&#125;      map.set(obj, newObj)      for (const key in obj) &#123;        newObj[key] = deepCopy(obj[key])      &#125;      return newObj    &#125;    const set = new Set([1, 2, 3, 4, 5])    const s1 = Symbol(&quot;s1&quot;)    const s2 = Symbol(&quot;s2&quot;)    const info = &#123;      name: &quot;jojo&quot;,      age: 20,      friend: &#123;        name: &quot;小羊&quot;,        age: 19,        address: &#123;          name: &quot;四川&quot;,          detail: &quot;成都市&quot;        &#125;,        cnt: [1, 2, 3]      &#125;,      set: set,      running: function() &#123;        console.log(&quot;running&quot;)      &#125;,      symbolKey: Symbol,            [s1]: &quot;s1&quot;,      [s2]: &quot;s2&quot;    &#125;    const newObj = deepCopy(info)    console.log(newObj)  &lt;/script&gt;

函数的循环引用

&lt;script&gt;    function isObject(obj) &#123;      const objType = typeof obj      return (obj !== null) &amp;&amp; (objType === &quot;object&quot; || objType === &quot;function&quot;)    &#125;    // 深拷贝函数    function deepCopy(obj, map = new WeakMap()) &#123;      // symbol类型      if (typeof obj === &quot;symbol&quot;) &#123;        return Symbol(obj.description)      &#125;      if(!isObject(obj)) &#123;        return obj      &#125;      // set类型      if(obj instanceof Set) &#123;        const newSet = new Set()        for(const setItem of obj) &#123;          newSet.add(deepCopy(setItem))        &#125;        return newSet      &#125;      // function类型,不需要深拷贝      if(typeof obj === &quot;function&quot;) &#123;        return obj      &#125;      // key为symbol类型      const symbolKeys = Object.getOwnPropertySymbols(obj)      for(const symbolKey of symbolKeys) &#123;        obj[symbolKey] = deepCopy(obj[symbolKey], map)      &#125;      // 如果是对象类型      if(map.get(obj)) &#123;        return map.get(obj)      &#125;      const newObj = Array.isArray(obj) ? [] : &#123;&#125;      map.set(obj, newObj)      for (const key in obj) &#123;        newObj[key] = deepCopy(obj[key], map)      &#125;      return newObj    &#125;    const set = new Set([1, 2, 3, 4, 5])    const s1 = Symbol(&quot;s1&quot;)    const s2 = Symbol(&quot;s2&quot;)    const info = &#123;      name: &quot;jojo&quot;,      age: 20,      friend: &#123;        name: &quot;小羊&quot;,        age: 19,        address: &#123;          name: &quot;四川&quot;,          detail: &quot;成都市&quot;        &#125;,        cnt: [1, 2, 3]      &#125;,      set: set,      running: function() &#123;        console.log(&quot;running&quot;)      &#125;,      symbolKey: Symbol,            [s1]: &quot;s1&quot;,      [s2]: &quot;s2&quot;    &#125;    info.self = info    const newObj = deepCopy(info)    console.log(newObj)  &lt;/script&gt;
事件总线
实现

class yy_EventBus &#123;  constructor() &#123;    // 用于存储所有注册的事件及其对应的回调函数    this.eventMap = &#123;&#125;  &#125;  // 注册事件监听器  on(eventName, eventFn) &#123;    // 获取指定事件名称下的回调函数列表    let eventFns = this.eventMap[eventName]    // 如果列表不存在,则创建一个新的列表    if(!eventFns) &#123;      eventFns = []      this.eventMap[eventName] = eventFns    &#125;    // 将新的回调函数添加到列表中    eventFns.push(eventFn)  &#125;  // 取消事件监听器  off(eventName, eventFn) &#123;    // 获取指定事件名称下的回调函数列表    let eventFns = this.eventMap[eventName]    // 如果列表不存在,则直接返回    if (!eventFns) return     // 遍历列表,找到与传入的 eventFn 相同的函数,并从列表中移除    for(let i = 0; i &lt; eventFns.length; i++) &#123;      const fn = eventFns[i]      if(fn === eventFn) &#123;        eventFns.splice(i, 1)        break      &#125;    &#125;    // 如果列表中已经没有回调函数了,则从 eventMap 中移除该事件    if(eventFns.length === 0) &#123;      delete this.eventMap[eventName]    &#125;  &#125;  // 发布事件,触发指定事件名称下的所有回调函数  emit(eventName, ...args) &#123;    // 获取指定事件名称下的回调函数列表    let eventFns = this.eventMap[eventName]    // 如果列表不存在,则直接返回    if(!eventFns) return     // 遍历列表,依次执行回调函数,并传递参数    eventFns.forEach(fn =&gt; &#123;      fn(...args)    &#125;)  &#125;&#125;// 创建一个事件总线实例const eventBus = new yy_EventBus()// 注册事件监听器eventBus.on(&quot;navclick&quot;, (name, age, height) =&gt; &#123;  console.log(`navclick: $&#123;name&#125;, $&#123;age&#125;, $&#123;height&#125;`)&#125;)// 另一个事件监听器const click = () =&gt; &#123;  console.log(&quot;click&quot;)&#125;eventBus.on(&quot;navclick&quot;, click)// 2 秒后取消 click 监听器setTimeout(() =&gt; &#123;  eventBus.off(&quot;navclick&quot;, click)&#125;, 2000)// 点击按钮时触发事件const navBtnEl = document.querySelector(&quot;.nav-btn&quot;)navBtnEl.onclick = function() &#123;  console.log(&quot;navBtnEl clicked&quot;)  eventBus.emit(&quot;navclick&quot;, &quot;张三&quot;, 25, 170)&#125;
JavaScript网络编程前后端分离的优势![[Pasted image 20240825203521.png]]

服务器端渲染过程![[Pasted image 20240825203823.png]]
前后端分离渲染过程![[Pasted image 20240825203756.png]]

Http协议什么是Http![[Pasted image 20240825204441.png]]![[Pasted image 20240825204459.png]]
网页中资源的获取![[Pasted image 20240825204658.png]]
Http的组成![[Pasted image 20240825211123.png]]
Http的版本![[Pasted image 20240825211713.png]]
Http的请求方式![[Pasted image 20240825212611.png]]
Header![[Pasted image 20240826111103.png]]![[Pasted image 20240826110852.png]]
Response响应状态码![[Pasted image 20240826120304.png]]

MDN响应码地址：HTTP 响应状态码 - HTTP | MDN (mozilla.org)![[Pasted image 20240826120226.png]]

XHR发送请求XHR发送请求的基本过程AJAX发送请求![[Pasted image 20240826150750.png]]
&lt;script&gt;    // 1.创建XMLHttpRequest对象    const xhr = new XMLHttpRequest()    // 2.监听状态的改变    xhr.onreadystatechange = function() &#123;      // 将字符串转化为json对象      if (xhr.readyState !== XMLHttpRequest.DONE) return       const resJSON = JSON.parse(xhr.response)      const banner = resJSON.data.banner      console.log(banner)    &#125;    // 3.配置请求open    xhr.open(&quot;get&quot;, &quot;http://123.207.32.32:8000/home/multidata&quot;) // 请求方式和请求地址    // 4.发送请求send    xhr.send()  &lt;/script&gt;
XMLHttpRequest的state![[Pasted image 20240826153519.png]]![[Pasted image 20240826153458.png]]
其他事件监听![[Pasted image 20240826154018.png]]
响应数据和类型![[Pasted image 20240826160123.png]]
HTTP响应的状态status![[Pasted image 20240826160737.png]]
GET&#x2F;POST请求传递参数![[Pasted image 20240826212439.png]]![[Pasted image 20240826212419.png]]
ajax网络请求封装
可以使用axios库
ajax封装

function ajax(&#123;  url,  method = &quot;get&quot;,  data = &#123;&#125;,  success,  failure&#125; = &#123;&#125;) &#123;  // 1.创建XMLHttpRequest对象  const xhr = new XMLHttpRequest()  // 2.监听数据  xhr.onload = function() &#123;    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;      success &amp;&amp; success(xhr.response)    &#125; else &#123;      failure &amp;&amp; failure(&#123; status: xhr.status, message: xhr.statusText&#125;)    &#125;  &#125;  // 3.设置类型  xhr.responseType = &quot;json&quot;  // 4.配置请求open  if(method.toUpperCase() === &quot;GET&quot;) &#123;    const queryStrings = []    for (const key in data) &#123;      queryStrings.push(`$&#123;key&#125;=$&#123;data[key]&#125;`)    &#125;    url = url + &quot;?&quot; + queryStrings.join(&quot;&amp;&quot;)    xhr.open(method, url)    xhr.send()  &#125; else &#123;    xhr.open(method, url)    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)    xhr.send(JSON.stringify(data))  &#125;&#125;

ajax-promise封装

function ajax(&#123;  url,  method = &quot;get&quot;,  data = &#123;&#125;,&#125; = &#123;&#125;) &#123;  return new Promise((resolve, reject) =&gt; &#123;    // 1.创建XMLHttpRequest对象    const xhr = new XMLHttpRequest()    // 2.监听数据    xhr.onload = function() &#123;      if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;        resolve(xhr.response)      &#125; else &#123;        reject(&#123; status: xhr.status, message: xhr.statusText&#125;)      &#125;    &#125;    // 3.设置类型    xhr.responseType = &quot;json&quot;    // 4.配置请求open    if(method.toUpperCase() === &quot;GET&quot;) &#123;      const queryStrings = []      for (const key in data) &#123;        queryStrings.push(`$&#123;key&#125;=$&#123;data[key]&#125;`)      &#125;      url = url + &quot;?&quot; + queryStrings.join(&quot;&amp;&quot;)      xhr.open(method, url)      xhr.send()    &#125; else &#123;      xhr.open(method, url)      xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)      xhr.send(JSON.stringify(data))    &#125;  &#125;)&#125;
过期时间和取消请求![[Pasted image 20240827115020.png]]
Fetch和Fetch API认识Fetch和API![[Pasted image 20240827133055.png]]![[Pasted image 20240827133115.png]]
Fetch数据的响应![[Pasted image 20240827133215.png]]![[Pasted image 20240827134223.png]]![[Pasted image 20240827134242.png]]![[Pasted image 20240827134254.png]]![[Pasted image 20240827134308.png]]
XMLHttpRequest文件上传![[Pasted image 20240827164139.png]]![[Pasted image 20240827164146.png]]![[Pasted image 20240827164213.png]]
Fetch文件上传![[Pasted image 20240827164955.png]]
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端三件套</tag>
      </tags>
  </entry>
</search>
